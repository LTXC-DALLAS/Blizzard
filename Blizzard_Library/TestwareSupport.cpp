#include "TestwareSupport.h"


BoolS   gTWInitialized = false;
BoolS   gVarFileCreated = false;
BoolS   gCloEnable = false;
IntS    gCloFunction = 0;
StringS gCloFileName = "";
BoolM   gFirstFail = true;

BoolS gCloGenerateOk = true; 
BoolS gCorrLockOutPassed = true; 

TIDatalog TIDlog;

TIDatalog::TIDatalog() 
{
}

TIDatalog::~TIDatalog()
{
}


int TIDatalog::PrintVarFileHeader (const IntS &fileHandle) 
{
// :TODO: implement function
    return (0);
}

int TIDatalog::WriteVar (const StringS &varName, const StringS &varUnits, const FloatS &varLoLimit, const FloatS &varHiLimit, const IntS &testId) 
////////////////////////////////////
// WriteVar for Float test types  //
////////////////////////////////////

{
    IntS var_file;

    StringS prog_path = SYS.GetProgramPath();
    StringS var_file_path = prog_path + "/autogenerated_varfile.vars";
    if (!gVarFileCreated) 
    {
        var_file = IO.Open (var_file_path,"w");
        gVarFileCreated = true;
        PrintVarFileHeader (var_file);
    }
    else 
    {
        var_file = IO.Open (var_file_path, "a");
    }
    if (var_file == 0) 
    {
        std::cout << "Opening file " << var_file_path << " failed! Aborting writing to var file." << std::endl;
        return (1);
    }
    
    
    IO.Print (var_file, "\n");
    IO.Print (var_file, "parm=%s\n", varName);
    IO.Print (var_file, "type=FLOAT\n");
    
    if (varUnits != "") 
        IO.Print (var_file, "uom=%s\n", varUnits);

    if (varLoLimit != UTL_VOID) 
    {
        IO.Print (var_file, "test_low=%e\n", varLoLimit);
    } 
    if (varHiLimit != UTL_VOID) 
    {
        IO.Print (var_file, "test_high=%e\n", varHiLimit);
    } 
    StringS local_test_name = RunTime.GetActiveTest().GetName();
    IO.Print (var_file, "test_name=%s\n", local_test_name);
    IO.Print (var_file, "test_number=%d\n", testId);
    IO.Close (var_file);
    return (0);
}

int TIDatalog::WriteVar (const StringS &varName, const IntS &varLoLimit, const IntS &varHiLimit, const IntS &testId) 
////////////////////////////////////
// WriteVar for Int test types    //
////////////////////////////////////

{
    IntS var_file;

    StringS prog_path = SYS.GetProgramPath();
    StringS var_file_path = prog_path + "/autogenerated_varfile.vars";
    if (!gVarFileCreated) 
    {
        var_file = IO.Open (var_file_path,"w");
        gVarFileCreated = true;
        PrintVarFileHeader (var_file);
    }
    else 
    {
        var_file = IO.Open (var_file_path, "a");
    }
    if (var_file == 0) 
    {
        std::cout << "Opening file " << var_file_path << " failed! Aborting writing to var file." << std::endl;
        return (1);
    }
    
    
    IO.Print (var_file, "\n");
    IO.Print (var_file, "parm=%s\n", varName);
    IO.Print (var_file, "type=INT\n");

    if (varLoLimit != UTL_VOID) 
    {
        IO.Print (var_file, "test_low=%d\n", varLoLimit);
    } 
    if (varHiLimit != UTL_VOID) 
    {
        IO.Print (var_file, "test_high=%d\n", varHiLimit);
    } 
    StringS local_test_name = RunTime.GetActiveTest().GetName();
    IO.Print (var_file, "test_name=%s\n", local_test_name);
    IO.Print (var_file, "test_number=%d\n", testId);
    IO.Close (var_file);
    return (0);
}

int TIDatalog::WriteVar (const StringS &varName, const IntS &testId) 
///////////////////////////////////////
// WriteVar for String vars          //
///////////////////////////////////////

{
    IntS var_file;

    StringS prog_path = SYS.GetProgramPath();
    StringS var_file_path = prog_path + "/autogenerated_varfile.vars";
    if (!gVarFileCreated) 
    {
        var_file = IO.Open (var_file_path,"w");
        gVarFileCreated = true;
        PrintVarFileHeader (var_file);
    }
    else 
    {
        var_file = IO.Open (var_file_path, "a");
    }
    if (var_file == 0) 
    {
        std::cout << "Opening file " << var_file_path << " failed! Aborting writing to var file." << std::endl;
        return (1);
    }
    
    
    IO.Print (var_file, "\n");
    IO.Print (var_file, "parm=%s\n", varName);
    IO.Print (var_file, "type=STRING\n");

    StringS local_test_name = RunTime.GetActiveTest().GetName();
    IO.Print (var_file, "test_name=%s\n", local_test_name);
    IO.Print (var_file, "test_number=%d\n", testId);
    IO.Close (var_file);
    return (0);
}


void TIDatalog::FailCLOGenerate () {
    gCloGenerateOk = false;
    std::cout << "CLO Generate has failed." << std::endl;
    if (IO.Exist (gCloFileName)) {
        delete (gCloFileName);
        std::cout << "CLO file " << gCloFileName << " deleted." << std::endl;
    }
    return;
}

TMResultM TIDatalog::FloatValue (const FloatM &dataToTest, const PinML &testPins, LimitStruct &testLimit,
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;

    if (!testLimit.Valid())
    {
        return (test_result);
    }
        
    if (gCloFunction == CLO_NONE)
        test_result = DLOG.ValueLS (testPins, dataToTest, testLimit, true);
    
    // :TODO: Add in FAIL_TEST stuff...not sure how to do it using standard
    // TWPDL calls just yet
    
    if (useTestware) 
    {
        FloatM tw_value;
        if (SYS.TesterSimulated())
        {
            if (testLimit.GetSimulateValue().Valid())
                tw_value = testLimit.GetSimulateValue().GetFloatM();
            else
                tw_value = dataToTest;   // use whatever is in dataToTest to avoid UTL_VOID from testLimit sim value
        }
        else
        {
            tw_value = dataToTest;
        }
        StringS test_units = testLimit.GetUnits();
        StringS tw_units;
        FloatM lo_limit = testLimit.GetLowLimit().GetFloatM();
        FloatM hi_limit = testLimit.GetHighLimit().GetFloatM();
        StringS tw_name = testLimit.GetName();
        
        if (gCloFunction == CLO_NONE) 
        {
            if (test_units == "" or test_units == "=")
                tw_units = "";
            else 
            {
                IntS position = test_units.Find("=");
                if (position >= 0)
                {
                    IntS substr_length = test_units.Length() - (position + 1); //position is 0-based, length 1-based
                    tw_units = test_units.Substring(position, substr_length);
                }
                else
                    tw_units = test_units;
            }
            if (WRITE_TW_VARS_FILE) 
            {
                SITE site = ActiveSites.Begin().GetValue();
                IntS test_id = testLimit.GetTestNumber();
                WriteVar (tw_name, tw_units, lo_limit[site], hi_limit[site], test_id);
            }
            
            TWPDLDataLogRealVariable (tw_name, tw_units, tw_value, testwareDatatype);           
        }
        else if ((gCloFunction == CLO_GENERATE) && gCloGenerateOk && doClo) {
        // :TODO: implement CLO stuff
//            if (ValuePasses (tw_value[site_list.Begin()], lo_limit, hi_limit)) {
//                CLOGenerateDataNoLimit (gCloFileName, tw_name, tw_value[site_list.Begin()]);
//            }
//            else {
//                std::cout << "Value doesn't pass for test: " << tw_name << std::endl;
//                std::cout << "Lo = " << lo_limit << "; Value = " << tw_value[site_list.Begin()] << "; Hi = " << hi_limit << ";" << std::endl;
//                FailCLOGenerate();
//             }
        }
        else if ((gCloFunction == CLO_VERIFY) && doClo) 
        {
//            CLO_param_passed = CLOVerifyReadingNoLimit (gCloFileName, tw_name, tw_value[site_list.Begin()]);
//            gCorrLockOutPassed = gCorrLockOutPassed & CLO_param_passed;
        }
        if (doClo && ((gCloFunction == CLO_GENERATE && gCloGenerateOk) || (gCloFunction == CLO_VERIFY && gCorrLockOutPassed))) 
        {
//            my_test_limit.test_result[site_list.Begin()] = TM_PASS;
        }
        else if (doClo && ((gCloFunction == CLO_GENERATE && (!gCloGenerateOk)) || (gCloFunction == CLO_VERIFY && (!gCorrLockOutPassed)))) 
        {
//            my_test_limit.test_result[site_list.Begin()] = TM_FAIL;
        }
    }
    return (test_result);
}

TMResultM TIDatalog::FloatValue (const FloatM1D &dataToTest, const PinML &testPins, LimitStruct &testLimit,
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    
    if (!testLimit.Valid())
    {
        return(test_result);
    }
        
    if (gCloFunction == CLO_NONE)
    {
            test_result = DLOG.ValueLS (testPins, dataToTest, testLimit);
    }           
    
    // :TODO: Add in FAIL_TEST stuff...not sure how to do it using standard
    // TWPDL calls just yet
    
    if (useTestware) 
    {
        FloatM1D tw_value(dataToTest.GetSize(), 0);
        
        if (SYS.TesterSimulated()) 
        {
            if (testLimit.GetSimulateValue().Valid())
                tw_value = testLimit.GetSimulateValue().GetFloatM();
            else
                tw_value = dataToTest;  // use whatever is in dataToTest to avoid UTL_VOID from testLimit sim value
        }
        else
        {
            tw_value = dataToTest;
        }
            
        StringS test_units = testLimit.GetUnits();
        StringS tw_units;
        FloatM lo_limit = testLimit.GetLowLimit().GetFloatM();
        FloatM hi_limit = testLimit.GetHighLimit().GetFloatM();
        StringS tw_name = testLimit.GetName();
        
        if (gCloFunction == CLO_NONE) 
        {
            if (test_units == "" or test_units == "=")
                tw_units = "";
            else 
            {
                IntS position = test_units.Find("=");
                if (position >= 0)
                {
                    IntS substr_length = test_units.Length() - (position + 1); //position is 0-based, length 1-based
                    tw_units = test_units.Substring(position, substr_length);
                }
                else
                    tw_units = test_units;
            }
            
            if (testPins.GetNumPins() < 2) // don't loop, only one test
            {
                if (WRITE_TW_VARS_FILE) 
                {
                    SITE site = ActiveSites.Begin().GetValue();
                    IntS test_id = testLimit.GetTestNumber();
                    WriteVar (tw_name, tw_units, lo_limit[site], hi_limit[site], test_id);
                }
            
                TWPDLDataLogRealVariable (tw_name, tw_units, tw_value[0], testwareDatatype);  
            }
            else
            {
                IntS index = 0;
                for (PinMLIter pin_iter = testPins.Begin(); !pin_iter.End(); ++pin_iter, ++index)
                {
                    StringS tw_name_plus_pin = tw_name + "_" + (*pin_iter).GetName();
                    
                    if (WRITE_TW_VARS_FILE) 
                    {
                        SITE site = ActiveSites.Begin().GetValue();
                        IntS test_id = testLimit.GetTestNumber() + index;
                        WriteVar (tw_name_plus_pin, tw_units, lo_limit[site], hi_limit[site], test_id);
                    }
            
                    TWPDLDataLogRealVariable (tw_name_plus_pin, tw_units, tw_value[index], testwareDatatype); 
                }
            }
        }
        else if ((gCloFunction == CLO_GENERATE) && gCloGenerateOk && doClo) {
        // :TODO: implement CLO stuff
//            if (ValuePasses (tw_value[site_list.Begin()], lo_limit, hi_limit)) {
//                CLOGenerateDataNoLimit (gCloFileName, tw_name, tw_value[site_list.Begin()]);
//            }
//            else {
//                std::cout << "Value doesn't pass for test: " << tw_name << std::endl;
//                std::cout << "Lo = " << lo_limit << "; Value = " << tw_value[site_list.Begin()] << "; Hi = " << hi_limit << ";" << std::endl;
//                FailCLOGenerate();
//             }
        }
        else if ((gCloFunction == CLO_VERIFY) && doClo) 
        {
//            CLO_param_passed = CLOVerifyReadingNoLimit (gCloFileName, tw_name, tw_value[site_list.Begin()]);
//            gCorrLockOutPassed = gCorrLockOutPassed & CLO_param_passed;
        }
        if (doClo && ((gCloFunction == CLO_GENERATE && gCloGenerateOk) || (gCloFunction == CLO_VERIFY && gCorrLockOutPassed))) 
        {
//            my_test_limit.test_result[site_list.Begin()] = TM_PASS;
        }
        else if (doClo && ((gCloFunction == CLO_GENERATE && (!gCloGenerateOk)) || (gCloFunction == CLO_VERIFY && (!gCorrLockOutPassed))))
        {
//            my_test_limit.test_result[site_list.Begin()] = TM_FAIL;
        }
    }
    return (test_result);
}

TMResultM TIDatalog::FloatValue (const FloatM &dataToTest, const PinML &testPins, ObjectS &testLimit,
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    if (!testLimit.Valid())
    {
        return (test_result);
    }
    
    LimitStruct limit_struct(testLimit);
    test_result = FloatValue (dataToTest, testPins, limit_struct, useTestware, testwareDatatype, doClo);
    return (test_result);
    
}

TMResultM TIDatalog::FloatValue (const FloatM1D &dataToTest, const PinML &testPins, ObjectS &testLimit,
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    if (!testLimit.Valid())
    {
        return (test_result);
    }
    
    LimitStruct limit_struct(testLimit);
    test_result = FloatValue (dataToTest, testPins, limit_struct, useTestware, testwareDatatype, doClo);
    return (test_result);
    
}

TMResultM TIDatalog::IntValue (const IntM &dataToTest, const PinML &testPins, LimitStruct &testLimit,
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    
    if (!testLimit.Valid())
        return(test_result);
        
    if (gCloFunction == CLO_NONE)
        test_result = DLOG.ValueLS (testPins, dataToTest, testLimit);
    
    // :TODO: Add in FAIL_TEST stuff...not sure how to do it using standard
    // TWPDL calls just yet
     
    if (useTestware) 
    {
        IntM tw_value;
        if (SYS.TesterSimulated())
        {
            if (testLimit.GetSimulateValue().Valid())
                tw_value = testLimit.GetSimulateValue().GetIntM();
            else
                tw_value = dataToTest;   // use whatever is in dataToTest to avoid UTL_VOID from testLimit sim value
        }
        else
        {
            tw_value = dataToTest;
        }
        
        StringS tw_units;
        IntM lo_limit = testLimit.GetLowLimit().GetIntM();
        IntM hi_limit = testLimit.GetHighLimit().GetIntM();
        StringS tw_name = testLimit.GetName();
        
        if (gCloFunction == CLO_NONE) 
        {
            if (WRITE_TW_VARS_FILE) 
            {
                SITE site = ActiveSites.Begin().GetValue();
                IntS test_id = testLimit.GetTestNumber();
                WriteVar (tw_name, lo_limit[site], hi_limit[site], test_id);
            }
            
            TWPDLDataLogVariable (tw_name, tw_value, testwareDatatype);           
        }
        else if ((gCloFunction == CLO_GENERATE) && gCloGenerateOk && doClo) {
        // :TODO: implement CLO stuff
//            if (ValuePasses (tw_value[site_list.Begin()], lo_limit, hi_limit)) {
//                CLOGenerateDataNoLimit (gCloFileName, tw_name, tw_value[site_list.Begin()]);
//            }
//            else {
//                std::cout << "Value doesn't pass for test: " << tw_name << std::endl;
//                std::cout << "Lo = " << lo_limit << "; Value = " << tw_value[site_list.Begin()] << "; Hi = " << hi_limit << ";" << std::endl;
//                FailCLOGenerate();
//             }
        }
        else if ((gCloFunction == CLO_VERIFY) && doClo) 
        {
//            CLO_param_passed = CLOVerifyReadingNoLimit (gCloFileName, tw_name, tw_value[site_list.Begin()]);
//            gCorrLockOutPassed = gCorrLockOutPassed & CLO_param_passed;
        }
        if (doClo && ((gCloFunction == CLO_GENERATE && gCloGenerateOk) || (gCloFunction == CLO_VERIFY && gCorrLockOutPassed)))
        {
//            my_test_limit.test_result[site_list.Begin()] = TM_PASS;
        }
        else if (doClo && ((gCloFunction == CLO_GENERATE && (!gCloGenerateOk)) || (gCloFunction == CLO_VERIFY && (!gCorrLockOutPassed))))
        {
//            my_test_limit.test_result[site_list.Begin()] = TM_FAIL;
        }
    }
    return (test_result);
}

TMResultM TIDatalog::IntValue (const IntM1D &dataToTest, const PinML &testPins, LimitStruct &testLimit,
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    
    if (!testLimit.Valid())
        return(test_result);
        
    if (gCloFunction == CLO_NONE)
        DLOG.ValueLS (testPins, dataToTest, testLimit);
    
    // :TODO: Add in FAIL_TEST stuff...not sure how to do it using standard
    // TWPDL calls just yet
    
    if (useTestware) 
    {
        IntM1D tw_value(dataToTest.GetSize(), 0);
        
        if (SYS.TesterSimulated()) 
        {
            if (testLimit.GetSimulateValue().Valid())
                tw_value = testLimit.GetSimulateValue().GetIntM();
            else
                tw_value = dataToTest;  // use whatever is in dataToTest to avoid UTL_VOID from testLimit sim value
        }
        else
        {
            tw_value = dataToTest;
        }
            
        StringS test_units = testLimit.GetUnits();
        StringS tw_units;
        IntM lo_limit = testLimit.GetLowLimit().GetIntM();
        IntM hi_limit = testLimit.GetHighLimit().GetIntM();
        StringS tw_name = testLimit.GetName();
        
        if (gCloFunction == CLO_NONE) 
        {  
            if (testPins.GetNumPins() < 2) // don't loop, only one test
            {
                if (WRITE_TW_VARS_FILE) 
                {
                    SITE site = ActiveSites.Begin().GetValue();
                    IntS test_id = testLimit.GetTestNumber();
                    WriteVar (tw_name, lo_limit[site], hi_limit[site], test_id);
                }
            
                TWPDLDataLogVariable (tw_name, tw_value[0], testwareDatatype);  
            }
            else
            {
                IntS index = 0;
                for (PinMLIter pin_iter = testPins.Begin(); !pin_iter.End(); ++pin_iter, ++index)
                {
                    StringS tw_name_plus_pin = tw_name + "_" + (*pin_iter).GetName();
                    
                    if (WRITE_TW_VARS_FILE) 
                    {
                        SITE site = ActiveSites.Begin().GetValue();
                        IntS test_id = testLimit.GetTestNumber() + index;
                        WriteVar (tw_name_plus_pin, tw_units, lo_limit[site], hi_limit[site], test_id);
                    }
            
                    TWPDLDataLogRealVariable (tw_name_plus_pin, tw_units, tw_value[index], testwareDatatype); 
                }
            }
        }
        else if ((gCloFunction == CLO_GENERATE) && gCloGenerateOk && doClo) {
        // :TODO: implement CLO stuff
//            if (ValuePasses (tw_value[site_list.Begin()], lo_limit, hi_limit)) {
//                CLOGenerateDataNoLimit (gCloFileName, tw_name, tw_value[site_list.Begin()]);
//            }
//            else {
//                std::cout << "Value doesn't pass for test: " << tw_name << std::endl;
//                std::cout << "Lo = " << lo_limit << "; Value = " << tw_value[site_list.Begin()] << "; Hi = " << hi_limit << ";" << std::endl;
//                FailCLOGenerate();
//             }
        }
        else if ((gCloFunction == CLO_VERIFY) && doClo) 
        {
//            CLO_param_passed = CLOVerifyReadingNoLimit (gCloFileName, tw_name, tw_value[site_list.Begin()]);
//            gCorrLockOutPassed = gCorrLockOutPassed & CLO_param_passed;
        }
        if (doClo && ((gCloFunction == CLO_GENERATE && gCloGenerateOk) || (gCloFunction == CLO_VERIFY && gCorrLockOutPassed)))
        {
//            my_test_limit.test_result[site_list.Begin()] = TM_PASS;
        }
        else if (doClo && ((gCloFunction == CLO_GENERATE && (!gCloGenerateOk)) || (gCloFunction == CLO_VERIFY && (!gCorrLockOutPassed))))
        {
//            my_test_limit.test_result[site_list.Begin()] = TM_FAIL;
        }
    }
    return (test_result);
}

TMResultM TIDatalog::IntValue (const IntM &dataToTest, const PinML &testPins, ObjectS &testLimit,
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    if (!testLimit.Valid())
    {
        return (test_result);
    }
    
    LimitStruct limit_struct(testLimit);
    test_result = IntValue (dataToTest, testPins, limit_struct, useTestware, testwareDatatype, doClo);
    return (test_result);
    
}

TMResultM TIDatalog::IntValue (const IntM1D &dataToTest, const PinML &testPins, ObjectS &testLimit,
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    if (!testLimit.Valid())
    {
        return (test_result);
    }
    
    LimitStruct limit_struct(testLimit);
    test_result = IntValue (dataToTest, testPins, limit_struct, useTestware, testwareDatatype, doClo);
    return (test_result);
    
}

