 /****************************************************************************/
 /*  A00 : Initial version of F035 Flash VLCT Codes.  KChau 11/07/06           */
 /*                                                                            */
 /*  A1.1 : Released with VT/BCC enable.                        KChau 11/10/09 */
 /*                                                                            */
 /* 11/18/09  KChau                                                            */
 /*           -Updated F021_ReadIDOTP_func to reflect new OTP offset/format.   */
 /*            Also added check/compare OTP ID contents between banks.         */
 /*           -Updated F021_Read_func to datalog only for bank/sector deplete  */
 /*            test and not bin out.                                           */
 /*                                                                            */
 /*  A1.2 : Released with using new OTP format.                 KChau 11/19/09 */
 /*                                                                            */
 /* 11/30/09  KChau                                                            */
 /*           -Updated F021_RefArr_Erase_func to log pre-ers ipmos_ev to tw.   */
 /*           -Removed 8us override in various proc/func since new shell has   */
 /*            it as default ppw.                                              */
 /*           -Added F021_RestoreOTPInfo_func for use at MP3 after stresses.   */
 /*           -Updated F021_Bank_Para_MBox_func to log tw of min/max sense amp */
 /*            number and its measured value. Also added selectable log tw all */
 /*            sense amp measured values via GL_DO_TWLOGALL_IPROG_DRV/ISA_LD/  */
 /*            ISA_NLD config variables.                                       */
 /*                                                                            */
 /*  A1.3 : Released with new OTP format with 8us ppw.          KChau 11/30/09 */
 /*                                          MeasPinTMU_func                                  */
 /* 12/09/09  KChau                                                            */
 /*           -Removed tpad ramping in F021_Flash_Leak_func, F021_Stress_func  */
 /*            as o"scope show not needed. Also set tpad prior entering tcrnum */
 /*            13,15..17 for leak test.                                        */
 /*           -Corrected total prog, cmpt pulse, & tnum tw string in procedure */
 /*            F021_Log_FailPat_To_TW.                                         */
 /*           -Updated F021_RefArr_Erase_func to support reprobe on adaptive   */
 /*            RefArray erase.                                                 */
 /*                                                                            */
 /*  A1.4 : Released with Charz routines.                       KChau 12/18/09 */
 /*                                                                            */
 /* 01/14/10  KChau                                                            */
 /*           -Added bcc ratio and read option for TNUM in GetVT/BCCTnum.      */
 /*           -Added funcs/procedures for flash ESDA (NonSCRAM).               */
 /*                                                                            */
 /*  A1.5 : Released for bug fix.                               KChau 01/21/10 */
 /*                                                                            */
 /* 01/25/10  KChau                                                            */
 /*           -Added PMOS soft trim.                                           */
 /*           -Added option to use either VT or BCC as DRL value in OTP.       */
 /*           -Added special case for bcc0 such that if no converge both ends  */
 /*            (passing) then returns 5ua and count as passed result.          */
 /*           -Modified BCC TW log with internal value (ratio).                */
 /* 03/12/10  KChau                                                            */
 /*           -WEBS: Flash_Test.BTS_F021_VLCTSTD.4 -- Added special case in    */
 /*            VT/BCC & Delta functions so not to disable fail site to allow   */
 /*            continuing go thru test flow to gather data for CHKVT0DRL &     */
 /*            CHKVT1DRL.  Then disable fail site after all drl delta check &  */
 /*            before DRL flowbyte write.                                      */
 /*                                                                            */
 /*  A1.6 : Released with PMOS Trim.                            KChau 03/15/10 */
 /*                                                                            */
 /* 04/13/10  KChau                                                            */
 /*           -Added otp erase prior restore OTP in GoRestoreOTP_OnFail.       */
 /*                                                                            */
 /*  A1.7 : Released with Redundancy, fake repair, flash PBIST. KChau 04/09/10 */
 /*                                                                            */
 /* 05/17/10  KChau                                                            */
 /*           -Removed special case option for EGFG1/2 in BCC/VT/Delta func.   */
 /*           -WEBS: VLCTSTD.10 -- changed BCC delta calc to use post-pre.     */
 /*           -Renamed TW on read ipmos pre ref array erase to IPMOS_RD        */
 /*            (was IPMOS_EV).                                                 */
 /* 05/20/10  KChau                                                            */
 /*           -WEBS VLCTSTD.15 -- Changed BCC delta calculation to convert     */
 /*            value to their respective IRatio prior comparing against limits */
 /*            in F021_BCC_Delta_func.                                         */
 /*                                                                            */
 /*  A1.8 : Released for EFR.                                   KChau 05/25/10 */
 /*                                                                            */
 /* 05/26/10  KChau                                                            */
 /*           -Modified VT/BCC_Delta_func to use PREVTYPE[vt_type] for calc.   */
 /*           -Added dump to file raw esda data on pbist.                      */
 /*           -Added Set_TPADS_ByOrder to bring up TPads in sequence defined   */
 /*            in TPadSeq record for stress tests.                             */
 /* 06/10/10  KChau                                                            */
 /*           -Modified Erase_func so not to fail if erspulse equal 0 since it */
 /*            can do erase w/o precon in f021.                                */
 /*                                                                            */
 /*  A1.9 : Released for Yield Learning.                        KChau 06/08/10 */
 /*                                                                            */
 /* 07/01/10  KChau                                                            */
 /*           -Modified VHV_ER_CT_Trim_func and RAM_Upload_VHV_CT_TrimVal to   */
 /*            change ER Start/Stop in OTP template for SM reg.                */
 /*                                                                            */
 /* 07/21/10  KChau                                                            */
 /*           -Changed BCC PGMFF delta limit to +/-16uA @MP3, was +/-8uA.      */
 /*                                                                            */
 /*  A1.10 : Released for Yield Learning.                       KChau 07/01/10 */
 /*                                                                            */
 /* 08/06/10  KChau                                                            */
 /*           -Modified/added to support OTP template data write shell changes */
 /*            F021_Program_func, Run_Update_FakeRepair,                       */
 /*            RAM_Upload_VHV_PMOS_EngOvride                                   */
 /*                                                                            */
 /****************************************************************************/
 /* 07/15/10  KChau                                                            */
 /*           -Added SCRAM support for ramread and ESDA.                       */
 /* 07/22/10  KChau                                                            */
 /*           -Making changes for TV2.0                                        */
 /*           -Modified F021_MainIref_SoftTrim_func.                           */
 /*           -Modified TL_Run_BCCVT, F021_BCC_func, F021_BCC_Delta_func to    */
 /*            store bcc value with its internal ratio value.                  */
 /*           -Implemented esda for bcc & delta tests.                         */
 /*           -Added F021_VHV_SLOPECT_SoftTrim_func.                           */
 /*           -Added VHVSlopeCT,VSA5CT efuse softtrim to RAM_Upload_SoftTrim,  */
 /*            RAM_Upload_SoftTrim_All, RAM_Clear_SoftTrim_All.                */
 /*           -Changed F021_VHV_ER_CT_Trim_func llim to equal target.          */
 /* 09/01/10  KChau                                                            */
 /*           -Making changes on various func/proc due to shell changes.       */
 /*           -Modified F021_MainBG/MainIref_SoftTrim_Direct_func with         */
 /*            enhanced algo to search with smaller ranges for TTR.            */
 /* 09/17/10  KChau                                                            */
 /*           -Updated RAM_Upload_VHV_CT, RAM_Upload_VHV_PMOS_EngOvride, and   */
 /*            F021_VHV_ER_CT_Trim_func to swizzle VHV_ER_CT_TRIM/STARTSAVED   */
 /*            due to shell change for TV2.0 only.                             */
 /* 09/30/10  KChau                                                            */
 /*           -Added bi-directional communication VT for non-pbist.            */
 /* 10/07/10  KChau                                                            */
 /*           -Updated VHV ER/PG/PV CT trim with new CT range.                 */
 /*           -Added clear BCC MP2 for re-probe capability.                    */
 /*           -Added internal VT routine.                                      */
 /* 11/16/10  KChau                                                            */
 /*           -Added engovride VRD CT (3.6V) and force Iref 20ua for VT1.      */
 /*           -Added ipmos trim option using pmos, nmos irefrd, nmos irefev.   */
 /*                                                                            */
 /*  A2.3 : Updated with ipmos trim option.                     KChau 11/17/10 */
 /*                                                                            */
 /* 12/03/10  KChau                                                            */
 /*           -WEBS: VLCTSTD.24 -- corrected VHV ESTART CT.                    */
 /*                                                                            */
 /*  A2.3.2 : Released with baseline ipmos trim.                KChau 12/03/10 */
 /*                                                                            */
 /* 01/07/11  KChau                                                            */
 /*           -WEBS: VLCTSTD.26 -- corrected logic bug in VHV trim that caused */
 /*            storing wrong trim solution.                                    */
 /*           -Updated VHV, BG, Iref trim algo for TTR.                        */
 /*           -Added mask 1s for BCC0 on chkboard pattern due to shell changes.*/
 /*           -Added FOSC efuse program.                                       */
 /*                                                                            */
 /*  A2.4 : Released with one pass flash efuse pgm.             KChau 01/15/11 */
 /*                                                                            */
 /* 03/07/11  KChau                                                            */
 /*           -Updated TL_Run_BCCVT to support QUADTYPE.                       */
 /* 03/17/11  KChau                                                            */
 /*           -Added override PG CT 0x1ff in F021_VHV_SLOPECT_SoftTrim_func.   */
 /*           -Modified TL_Run_BCCVT to do only bank1 if VT CHK DRL.           */
 /* 03/30/11  KChau                                                            */
 /*           -Added clear otp chksum in RestoreOTPInfo_func.                  */
 /*           -Added one extra step if CT overshoot in ER/PG/PV trim func.     */
 /* 04/05/11  KChau                                                            */
 /*           -Fixed over flow string in writeramcontent.                      */
 /*           -Modified TL_Run_BCCVT to do only bank1 & 2 if VT CHK DRL.       */
 /* 04/07/11  KChau                                                            */
 /*           -Modified RefArr_Erase to apply erase pulse regardless of pre    */
 /*            measurement on non-adaptive erase.                              */
 /*           -Modified TL_Run_BCCVT to do only last bank if VT CHK DRL.       */
 /*           -Modified stress_func to run once if vhv stress.                 */
 /*           -Modified BCC_Delta_func with different limits for EMU bank.     */
 /*                                                                            */
 /*  A2.7 : Released with changes for qual revG.                KChau 04/15/11 */
 /*                                                                            */
 /* 04/11/11  KChau                                                            */
 /*           -Modified VHV_*_CT_Trim_func, RAM_Upload_VHV_CT_TrimVal,         */
 /*            RAM_Upload_VHV_PMOS_EngOvride to support new VHV address due to */
 /*            shell changes.                                                  */
 /*           -Modified scram to use one source/capture ramread_mbox_scram     */
 /*            pattern instead of 3 different patterns.                        */
 /*           -Added code to support single jtag data in/out.                  */
 /*           -Added code to support DMLED ram access.                         */
 /*           -Modified flowcheck, readbccotp to support skip mp2 flow.        */
 /* 04/29/11  KChau                                                            */
 /*           -Changed flash efuse read/prog reference by NonMBist type        */
 /*            instead of Custom type, and using device specific rd/pg option  */
 /*            defined in f021_config.p, i.e. GL_EFUSE_RD/PG_CODEOPTION.       */
 /*                                                                            */
 /****************************************************************************/
 /*                                                                            */
 /* 05/19/11  KChau                                                            */
 /*           -Modified TL_Run_BCCVT to enable internal VT0 and datalog BCC0   */
 /*            on last bank of CHKVT0 and EGFG4.                               */
 /*           -Added F021_Read/WriteVT0BCC1OTP_func for mixed DRL0/1.          */
 /*           -Added FlashCode_WR_EXE_func.                                    */
 /* 05/25/11  KChau                                                            */
 /*           -Added SAmp_Noise_Screen_func.                                   */
 /*           -Added Special_Program_func for 1 pulse screen w/ softbin.       */
 /*           -Added Efuse Bit17 blow for bank0/1, not bank2.                  */
 /*                                                                            */
 /*  B1.0 : Released for qual with internal VT0 enabled.        KChau 05/27/11 */
 /*                                                                            */
 /* 05/31/11  KChau                                                            */
 /*           -Added VT/BCC for Random code.                                   */
 /* 06/02/11  KChau                                                            */
 /*           -Added DRL VT0 Median or delta-delta limit.                      */
 /* 06/29/11  KChau                                                            */
 /*           -Added TL_EngOvride_VHV_MAXEP_ESTART_ESTEP_CT,                   */
 /*            TL_EngOvride_VHV_ER_CT_MS, TL_Meas_VHV_ER_OvrCT,                */
 /*            TL_StairStep_Erase for stair step erase DOE.                    */
 /*           -WEBS: VLCTSTD.35 -- added bank datawidth=64 on FLES bank.       */
 /*           -WEBS: VLCTSTD.36 -- disable IPMOS Odd trim on FLES bank.        */
 /*           -Unified RAM address/access for all platforms using byte address.*/
 /*            ReadRamAddress,GetRamContent*,WriteRamContent* input addr param */
 /*            is cpu byte address. It would then translate to physcical/pmt   */
 /*            address based on defined platform.                              */
 /*           -Modified SAMP_Noise_Screen_func to log failaddr/data as string. */
 /*           -Added PBIST internal VT0 support.                               */
 /*           -Added TL_Schmoo_Freq routine.                                   */
 /* 07/11/11  KChau                                                            */
 /*           -Expanded SAMP_Noise_Screen_func to perform charz w/ varying     */
 /*            predefined Read PC/Efuse bits via TL_EngOvride_RPC_EF.          */
 /*                                                                            */
 /*  B1.1 : Released to support C2000 and Stellaris platforms.  KChau 06/29/11 */
 /*                                                                            */
 /* 07/15/11  KChau                                                            */
 /*           -Updated Run_Update_FakeRepair as shell changed.                 */
 /*           -Modified BCC_BinSearch and MeasInternalVT to save last failing  */
 /*            info for sense amp accuracy charz.                              */
 /* 07/20/11  KChau                                                            */
 /*           -Updated TL_EngOvride_RPC_EF, SAMP_Noise_Screen_func to support  */
 /*            override bank efuse bit23-13 & rdpc via mailbox.                */
 /* 07/26/11  KChau                                                            */
 /*           -Updated SAMP_Noise_Screen_func to reformat charz twlogstr       */
 /*            (e.g Z_SAN_VMX_B0Q0_PC0_01UA_FBIT) for ease of data processing. */
 /* 08/01/11  KChau                                                            */
 /*           -Changed VHV CT trim to check against llim instead of llim_pre   */
 /*            to tighten post-trim distribution.                              */
 /*           -Modified FlowCheck_func to disable fail site even COF.          */
 /*           -Added TL_EngOvride_RDM0_NMOS, TL_SWEEP_RDM0_NMOS.               */
 /* 08/04/11  KChau                                                            */
 /*           -WEBS: VLCTSTD.40 -- added check efuse error status reg and fail */
 /*            if errorCode = 0x15/0x5 even ECC is correcting single bit error.*/
 /*           -WEBS: VLCTSTD.41 -- corrected internal VT TT log to TW.         */
 /* 08/08/11  KChau                                                            */
 /*           -Modified ReadLog1OTP to support OTP format W3/W4 on 64bit bank. */
 /*           -Added TL_Display_W34 64bit bank ratio decode display.           */
 /* 08/11/11  KChau                                                            */
  /*           -Changed VHV ER CT START to 6 steps on HDPUMP, 7 on ESPUMP.      */
 /*                                                                            */
 /*  B2.3 : Released for revI qual.                             KChau 08/12/11 */
 /*                                                                            */
 /* 08/22/11  KChau                                                            */
 /*           -Added DRL BCC1 median delta.                                    */
 /*                                                                            */
 /*  B2.3.1 : Released for revI qual.                           KChau 08/23/11 */
 /*                                                                            */
 /* 09/16/11  KChau                                                            */
 /*           -Changed F021_VT_Delta_func to use DRLVT0_L/UDELTA limits on OTP */
 /*            as well as bank2 has different limit @MP3.                      */
 /*                                                                            */
 /*  B2.3.3 : Released for revI qual.                           KChau 09/16/11 */
 /*                                                                            */
 /* 09/20/11  KChau                                                            */
 /*           -Modified VHV PG/ERS/PV CT trim and BandGap direct trim with     */
 /*            adaptive algo for TTR and tighter distribution.                 */
 /*           -Added TL_Boost_RefArray to boost refarray to ~ird target.       */
 /*           -Added F021_LPO_Trim_func, MBox_Upload_LPO_CAL for LF/HF trim    */
 /*            using DCC. Also modified F021_ReadIDOTP_func, Write_OTP_MBox,   */
 /*            and OTP_WrEngRow_func for read/write LPO value out/in OTP.      */
 /*           -WEBS: VLCTSTD.42 -- write pump trim solutions to OTP.           */
 /*            Modified EFChkSum write to include bg/iref/fosc/vas5/slope trim */
 /*            into OTP trim solution fields.                                  */
 /*                                                                            */
 /*  B2.4 : Released for revK wafers.                           KChau 09/20/11 */
 /*                                                                            */
 /* 10/28/11  KChau                                                            */
 /*           -Modified FlashCode_WR_EXE_func to support Stellaris for writing */
 /*            SCPL into customer OTP.                                         */
 /*           -Added FlashCode_RdPsa_func to support arbitrary target/data     */
 /*            field including customer otp for Stellaris.                     */
 /*           -Modified MBox_Upload_RCODE_PSA to support various FlashCodeType.*/
 /*           -Added MeasPinTMU_func, F021_FOSC_SoftTrim_External_func to trim */
 /*            FOSC using external pin via DMA TMU for device doesn"t have DCC.*/
 /*           -Removed unused func/procedures.                                 */
 /*           -Added VHV slopect override in MeasInternalVT for ESPUMP.        */
 /*           -Added pump trim extraction in GetTrimCode_On_EFStr on ESPUMP for*/
 /*            usage in internal vt.                                           */
 /*           -Added internal BCC1 support in TL_Run_BCCVT, MeasInternalVT.    */
 /*           -Fixed array overflow in VHV_PG/ER/PV_CT_Trim_func.              */
 /*           -Modified bank_para_mbox_func to do one SA for catalog flow.     */
 /*           -Updated FlowCheck_func to support catalog flow at final test.   */
 /*                                                                            */
 /*  B3.0 : Released for Catalog Flow.                          KChau 11/24/11 */
 /*                                                                            */
 /****************************************************************************/


#include <f021_func.h>
#include <string_utils.h>
#include <iomanip>
using namespace std; 


void GetVITypesFromTPMeasType(TPMeasType meastype, VIForceTypeS &viforce_type, 
                                                   VIMeasureTypeS &vimeas_type)
{
// So far, it works out that if we are measuring current, we force voltage
// and vice-versa...so no force I meas I in this library.
// If we are just forcing voltage, we say that we are 
// measuring current so that the measure range gets set and doesn't 
// interfere with the force. (Some instruments have a separate measure 
// range than the clamp settings, which can still cause clamping.
   switch (meastype)
   {
      case ForceVoltType:
      case MeasCurrType:
         viforce_type = VI_FORCE_V;
         vimeas_type = VI_MEASURE_I;
         break;
      case ForceCurrType:
      case MeasVoltType:
         viforce_type = VI_FORCE_I;
         vimeas_type = VI_MEASURE_V;
         break;
      default:
         viforce_type = UTL_VOID;
         vimeas_type = UTL_VOID;
         break;
   }
}

void PatternDigitalCapture(StringS patternBurst, PinML capturePins, StringS capName, UnsignedS maxCapCount, 
                           UnsignedM1D &captureArr, const UnsignedM1D &simValue, UnsignedS wordSize = UTL_VOID, 
                           WordOrientationS wordOrientation = WORD_MSB_FIRST)
{
   BoolM timed_out;
   
   // if no wordSize is given, then we do parallel even if that means a 1-bit parallel
   // if more than 1 capture pin, it has to be parallel
   if (wordSize == UTL_VOID || (capturePins.GetNumPins() > 1)) 
   {
      DIGITAL.DefineParallelCapture(capturePins, capName, maxCapCount);
   } else {
      DIGITAL.DefineSerialCapture(capturePins, capName, maxCapCount, wordSize, wordOrientation);
   }
   DIGITAL.StartCapture(capName);
   DIGITAL.ExecutePattern(patternBurst);
   timed_out = DIGITAL.WaitForCapture(capName);
   DIGITAL.ReadCapture(capName, captureArr, simValue);
   if (timed_out.AnyEqual(true)) 
   {
      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
      {
         if (timed_out[*si])
         {
            cout << "Digital capture timed out on site " << *si << " for thread " 
                 << patternBurst << " capture " << capName << endl;
         }
      }
   }
}

// /*ElimSpace remove space from string until encounter alpha-numeric*/
//void ElimSpaceStr(    StringS inputstr)
//{
//   IntS length,spaceidx;
//   char achar;
//   BoolS firsttime;
//
//   spaceidx = instr(inputstr," ");
//   firsttime = true;
//   
//   while(spaceidx!=0) do
//   {
//      length = len(inputstr);
//      if((length>0) and firsttime)  
//      {
//         inputstr = mid(inputstr,spaceidx+1,(length-spaceidx));
//         firsttime = false;
//      }
//      else if(length>0)  
//         inputstr = mid(inputstr,spaceidx+1,(length-1));
//      
//      achar = inputstr[1];
//      if(((achar >== chr(ord("A"))) and (achar <== chr(ord("z")))) or
//         ((inputstr[1] >== "0") and (inputstr[1] <== "9")))  
//         spaceidx = 0
//      else
//         spaceidx = instr(inputstr," ");
//   } 
//}   /* ElimSpaceStr */
//      
//void PrintDUTSetup()
//{
//   DCSetup twDCSetup;
//   IntS supplyIdx;
//   PinM supplyName;
//   FloatS FloatS1;
//   TWUnit unit1;
//   FloatS vProg,iProg;
//   StringS psValue;
//   StringS tempString;
//   BoolS PgmInvert;
//   FloatS PgmFRQ,PgmClkVIH,PgmClkVIL;   
//
//   if(v_any_dev_active)  
//   {
//      if(TIStdScreenPrint)  
//      {
//         SetupGet(twDCSetup);
//         
//         psValue = "";
//         for (supplyIdx = 1;supplyIdx <= GroupGetCount(SupplyGroup);supplyIdx++)
//         {
//            supplyName = GroupGetElement(SupplyGroup, supplyIdx);
//            STDGetVI(supplyName, vProg, iProg);
//            
//            TWTRealToReal(vProg, real1, unit1);
//            if ( psValue == "" )  
//               WriteString(psValue, real1:-1:5);
//            else
//            {
//               WriteString(tempString, ",", real1:-1:5);
//               psValue = psValue +  tempString;
//            } 
//         } 
//         
//         cout << "DCTableName : " << TWDCSetup << 
//                 " ;PowerSupply Value : " << PSValue << endl;
//         Clockget(s_clock1a,pgminvert,pgmfrq,pgmclkvih,pgmclkvil);
//         cout << "Clock @ " << pgmfrq << endl;
//      }   /*if tistdscreenprint*/
//   } 
//}   /* PrintDUTSetup */

TMResultM F021_InitFLGlobalvars_func()
{
   IntS bank;
   SITE site;
   IntS index;
   StringS this_wfrid,lotid;
   StringS scribeid;
   IntS maxstrnum;
   TPModeType tcrmode;
   IntS vt_mode; 
   
   // Expression processor evaluates OpVar RunAllTests
   // and places the value in the BoolS RunAllTests
   RunAllTests = "RunAllTests";
   
   // Moved this here instead of elsewhere in the flow. It isn't used until the 
   // Flash stuff after this function anyway.
   reload_flashshell = false;  /*This is added to reload the flash shell after we calculate VHV soft trims.  Due to the nature
     of the flash tests following VHV, we need to load the PMOS trims for the PMOS currents and the VHV CT's for programming/erasing
     and BCC's/VT's.  Once the flash stability issue has been resolved, this variable will not be necessary  JRR 0501512 */

   
   if(tistdscreenprint)  
   {
      IO.Print(IO.Stdout,"+++++ F021_InitFLGlobalvars_func +++++\n");
      if(TI_FlashDebug)  
      {
         IO.Print(IO.Stdout,"GL_F021_LOG_FAILPAT[site] = false\n");
         IO.Print(IO.Stdout,"GL_F021_COF_PASS[site] = true\n");
         IO.Print(IO.Stdout,"GL_F021_COF_1STFAILTEST[site] = NULL_TestName\n");
         IO.Print(IO.Stdout,"GL_FLASH_SAVESITES[site] = true\n");
         IO.Print(IO.Stdout,"GL_FLASH_RETEST[site] = false\n");
         IO.Print(IO.Stdout,"GL_FLASH_RETEST_GEC[site] = false\n");
         IO.Print(IO.Stdout,"PUMP_PARA_VALUE[pre/post] = 0V\n");
      } 

       /*initialize new DUTs as not yet logged fail to tw*/
      GL_F021_LOG_FAIL_PATT = false;

       /*init for COF continue on fail. true=nofail*/
      GL_F021_COF_PASS = true;
      maxstrnum = 10;
      // No need for site loop, vars are SV Types and can initialize without loops
      // if every value is the same
      
//      GL_F021_COF_1STFAILTEST = "";
      for (index = 1;index <= maxstrnum;index++) // kept because only <=maxstrnum being init-ed
      {
         GL_F021_COF_INFOS.SetValue(index, "");
//         GL_F021_COF_INFOS_FULL.SetValue(index, false);
      } 
       /*init for deplete bank/sect*/
      GL_F021_LOG_SOFTBIN_STAT = "";
      GL_F021_LOG_SOFTBIN_PATT = "";
      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
         GL_F021_LOG_SOFTBIN_PATT = GL_F021_LOG_SOFTBIN_PATT + "2";
      GL_F021_LOG_SOFTBIN_PATT = GL_F021_LOG_SOFTBIN_PATT + "__";
      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
      {
         for (index = 0;index <= F021_Flash.MAXSECT[bank];index++)
            GL_F021_LOG_SOFTBIN_PATT = GL_F021_LOG_SOFTBIN_PATT + "2";
         GL_F021_LOG_SOFTBIN_PATT = GL_F021_LOG_SOFTBIN_PATT + "_";
      }                

      
       /*init pump var to 0v*/
      PUMP_PARA_VALUE = 0.0V;  // no need to loop...SV Type and all values getting 0.


      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
      {
         for (vt_mode = CHKVT0;vt_mode <= ERSSTRVT0;vt_mode++) // all vttypes
         {
            for (index = 0;index <= 15;index++)
            {
               BANK_VT_VALUE[bank][index][vt_mode][pre] = 0.0V;
               BANK_VT_VALUE[bank][index][vt_mode][post] = 0.0V;
               BANK_BCC_VALUE[bank][index][vt_mode][pre] = 0uA;
               BANK_BCC_VALUE[bank][index][vt_mode][post] = 0uA;
            } 
            OTP_VT_VALUE[bank][vt_mode][pre] = 0.0V;
            OTP_VT_VALUE[bank][vt_mode][post] = 0.0V;
            OTP_BCC_VALUE[bank][vt_mode][pre] = 0uA;
            OTP_BCC_VALUE[bank][vt_mode][post] = 0uA;
         } 
//         BANK_PARA_VALUE[bank][25][ReadMode][2][post][VNME] = 13uV;
//         BANK_PARA_VALUE[bank][25][ReadMode][2][post][VNMO] = 13uV;
      } 

       /*init incoming flash active sites*/
      GL_FLASH_SAVESITES = true;

      GL_FLASH_RETEST = false;
//      GL_FLASH_RETEST_GEC = false;

      GL_DO_RESTORE_OTP_ON_FAIL = false;
      SITE_TO_RESTORE_OTP = false;

      GL_DO_CHARZ_OVRTEMPL_W89 = false;
      GL_CHARZ_ERSREFARR_SAVECOUNT = GL_CHARZ_ERSREFARR_COUNT;
      GL_CHARZ_BCC_COUNT = GL_CHARZ_ERSREFARR_COUNT;

      GL_SITE_TO_ESDA = false;
      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
         for (index = 0;index <= 15;index++)
            GL_BANK_TO_ESDA.SetValue(bank, index, false);

       /*added to log all drl data 0s/1s - then bin out prior write drl flowbyte*/
      GL_VT0DRL_RESULT = true;
      GL_VT1DRL_RESULT = true;
      GL_BCC0DRL_RESULT = true;
      GL_BCC1DRL_RESULT = true;

       /*added for fake repair*/
      GL_FAKEREP_ENA = false;   /*disable until reach sampling count*/

      VHV_PV_CT_TRIMSAVED = 0;

      GL_DO_BCCVT_RCODE_ENA = false;
      
      GL_CHARZ_ESTAIRSTEP_SAVECOUNT = GL_CHARZ_ESTAIRSTEP_COUNT;
      
      RunAllTests = "RunAllTests";
   
   }   /*if v_any_dev*/

// will handle DieID differently
//   if(TI_FlashESDAEna)  
//   {
//      if (IsProber)  
//      {
//          /*KChau - removed as already exist in testflow.p*/
//          /*TIParseConvertedWaferID(TWWaferID, prober.waferIDStr, 
//                                  prober.fabCodeStr,
//                                  prober.lotStr, 
//                                  prober.waferStr);
//          this_wfrid := prober.waferIDStr;
//          scribeid := mid(this_wfrid,1,12);
//          lotid := mid(this_wfrid,3,7);*/
//      }
//      else
//      {
//         scribeid = "C-1234567-03";
//         lotid = "1234567";
//         ESDASetProgramID(GL_ESDA_PROGID);
//         ESDASetScribeID(scribeid,3);
//         ESDASetLotID(lotid);
//      } 
//   } 

    /*null out shell loaded*/
   GL_PREVIOUS_SHELL = "";

   return (TM_PASS);
}   /* F021_InitFLGlobalvars_func */

void SetFlashESDAVars(TMResultM logsites, IntS bank, IntS sect) {

   IntS site;

//    GL_SITE_TO_ESDA[site] = true;
//    GL_BANK_TO_ESDA[bank][sect][site] = true;

}   // SetFlashESDAVars
         
//void ClearFlashESDAVars(IntS bank,
//                             IntS sect)
//{
//   IntS site;
//
//   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      if(v_dev_active[site])  
//      {
//         GL_SITE_TO_ESDA[site] = false;
//         GL_BANK_TO_ESDA[bank][sect][site] = false;
//      } 
//}   /* ClearFlashESDAVars */
//         
//void Update_FLASH_RETEST_Var()
//{
//   IntS site;
//
//   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      if(GL_FLASH_RETEST[site] and (not v_dev_active[site]))  
//         GL_FLASH_RETEST[site] = false;
//} 
//
//
//void Update_FLWBYTE_Var()
//{
//   const IntS IND_FLWBYTE = 52; 
//
//   IntS site,negatebit,bank;
//
//   switch(TITestType) {
//     case MP2       : negatebit = 0xFEFF;
//     case MP3       : negatebit = 0xFF7F;
//     case PreBurnIn : negatebit = 0xFBFF;
//     default:   negatebit = 0xFFFF;
//   }   /* case */
//   
//   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      if(v_dev_active[site])  
//      {
//         FRM_OTP_FLWBYTE_VALUE[site] = FRM_OTP_FLWBYTE_VALUE[site]&negatebit;
//         for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//            OTP_ID_INFO_VAL[bank][IND_FLWBYTE][site] = FRM_OTP_FLWBYTE_VALUE[site];
//      } 
//} 
//
//      
//void PrintHeaderBool(BoolS paral_format)
//{
//   IntS site;
//   IntS fdlen1,fdlen2,fdlen3;
//   StringS str1,str2,str3,str4;
//
//   if(tistdscreenprint)  
//   {
//      str1 = "------------------------------";  /*30*/
//      str2 = "------------";  /*12*/
//      str3 = " ";
//      fdlen1 = 30;
//      fdlen2 = 12;
//      fdlen3 = 12;
//
//      if(paral_format)  
//      {
//         cout << endl;
//         cout << "TestName ":-fdlen1 << str3 << "FL_TNUM":fdlen2 << str3 << 
//               "Min Limit":fdlen2 << str3 << "Max Limit":fdlen2 << str3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         {
//            writestring(str4,site:1);
//            str4 = "Site" + str4;
//            cout << str4:fdlen3 << " ";
//         } 
//         cout << endl;
//         
//         cout << str1 << str3 << str2 << str3 << str2 << str3 << str2 << str3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            cout << str2 << " ";
//         cout << endl;
//      }  /*if paral_format*/
//      else
//      {  /*serial_format*/
//         cout << endl;
//         cout << "TestName ":-fdlen1 << " " << "FL_TNUM":fdlen2 << " " << 
//                 "Site":fdlen3 << " " << "P/F":fdlen3 << endl;
//         cout << str1 << " " << str2 << " " << str2 << " " << str2 << endl;
//      } 
//   }   /*if tistdscreenprint*/
//}   /* PrintHeaderBool */
//
//
//void PrintResultBool(StringS tmpstr1,
//                          IntS tnum,
//                          BoolM test_results,
//                          BoolS paral_format)
//{
//   IntS site;
//   IntS fdlen1,fdlen2,fdlen3;
//   StringS str1,str2,str3,str4;
//
//   if(tistdscreenprint)  
//   {
//      str1 = "------------------------------";  /*30*/
//      str2 = "------------";  /*12*/
//      str3 = " ";
//      str4 = "          --";  /*12*/
//      fdlen1 = 30;
//      fdlen2 = 12;
//      fdlen3 = 12;
//
//      if(paral_format)  
//      {
//         cout << tmpstr1:-fdlen1 << str3 << tnum:s_hex:fdlen2 << str3 << str4 << str3 << str4 << str3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         {
//            if(v_dev_active[site])  
//            {
//               if(test_results[site])  
//                  cout << "PASS":fdlen3 << " ");
//               else
//                  cout << "FAIL**":fdlen3 << " ";
//            }
//            else
//               cout << "X":fdlen3 << " ";
//         } 
//         cout << endl;
//      }  /*if paral_format*/
//      else
//      {  /*serial_format*/
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               cout << tmpstr1:-fdlen1 << " " << tnum:s_hex:fdlen2 << 
//                     " " << site:fdlen3 << " ";
//               if(test_results[site])  
//                  cout << "PASS":fdlen3 << " ");
//               else
//                  cout << "FAIL**":fdlen3 << " ";
//               cout << endl;
//            } 
//      } 
//   }   /*if tistdscreenprint*/
//}   /* PrintResultBool */
//   
//
//void TrealToStr(    FloatS FloatSval,
//                         StringS ReturnStr)
//{
//   IntS unitloc,length,strlength,i;
//   StringS str1,str2,str3,unitstr;
//   FloatS tmpFloatS,retval;
//   IntS fdlen,decimpt,unitlen;
//
//   fdlen = 5;
//   unitloc = 0;
//   length  = 0;
//   writestring(str1,trealval:1);
//   strlength = len(str1);
//   
//   for (i = 1;i <= strlength;i++)
//      if((str1[i]>== chr(ord("A"))) and (str1[i]<== chr(ord("z"))))  
//      {
//         length = length+1;
//         if(unitloc==0)  
//            unitloc = i;
//      } 
//
//   unitstr = mid(str1,unitloc,length);
//   str2 = mid(str1,1,strlength-length);
//   i = instr(str2,".");
//   if(i!=0)  
//      str2[i] = "P";
//   strlength = len(str2);
//   if(strlength>4)  
//      str2 = mid(str2,1,fdlen);
//   str3 = str2 + unitstr;
//   ReturnStr = str3;
//} 
//      
//
//void GetTreal_Unit_Info(    FloatS FloatSval,
//                                 FloatS FloatSVal,
//                                 IntS UnitLen,
//                                 StringS UnitStr)
//{
//   IntS unitloc,length,strlength,i;
//   StringS str1,str2,str3;
//   FloatS tmpFloatS;
//
//   str2 = "";
//   unitloc = 0;
//   length  = 0;
//   writestring(str1,trealval);
//   strlength = len(str1);
//   
//   for (i = 1;i <= strlength;i++)
//      if((str1[i]>== chr(ord("A"))) and (str1[i]<== chr(ord("z"))))  
//      {
//         length = length+1;
//         if(unitloc==0)  
//            unitloc = i;
//      } 
//
//   str2 = mid(str1,unitloc,length);
//   UnitStr = str2;
//   UnitLen = length;
//   str3 = mid(str1,1,strlength-length);
//   readstring(str3,tmpreal);
//   RealVal = tmpreal;
//} 
//      
//
void PrintHeaderParam(BoolS paral_format)
{
   IntS site;
   IntS fdlen1,fdlen2,fdlen3;
   IntS fdlen4,decpt;
   StringS str1,str2,str3,str4,str5;
   FloatS FloatSval;
//   FloatS FloatSval;
   StringS unitstr;
   IntS unitlen;

   if(tistdscreenprint)  
   {
      str1 = "------------------------------";  /*30*/
      str2 = "------------";  /*12*/
      str5 = "-----";  /*5*/
      str3 = " "; 
      fdlen1 = 30;
      fdlen2 = 12;
      fdlen3 = 12;

      if(paral_format)  
      {
         cout << endl;
//original code
//         cout << "TestName ":-fdlen1 << str3 << "FL_TNUM":fdlen2 << str3 << 
//               "Min Limit":fdlen2 << str3 << "Max Limit":fdlen2 << str3;
         cout <<setw(fdlen1)<<"TestName "<<str3<<setw(fdlen2)<<"FL_TNUM"<<str3<<setw(fdlen2)<<
               "Min Limit"<<str3<<setw(fdlen2)<<"Max Limit"<< str3;
         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
         {
// Writestring is a VLCT procedure.  The intent of the code is to place the site number into str4.
//            writestring(str4,site:1);
            str4 = "Site" + str4;
// Original code
//            cout << str4:fdlen2 << str3;
            cout <<setw(fdlen2)<<str4<<str3;
         } 
         cout << endl;
         
         cout << str1 << str3 << str2 << str3 << str2 << str3 << str2 << str3;
         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
            cout << str2 << str3;
         cout << endl;
      }  /*if paral_format*/
      else
      {  /*serial_format*/
         cout << endl;
//original code
//         cout << "TestName ":-fdlen1 << str3 << "FL_TNUM":fdlen2 << str3 << "Site":fdlen2 << str3 << 
//               "Min Limit":fdlen2 << str3 << "Max Limit":fdlen2 << str3 << "Measured" << endl;
          cout <<setw(fdlen1)<<"TestName "<<str3<<setw(fdlen2)<<"FL_TNUM"<<str3<<setw(fdlen2)<<"Site"<<str3<< 
               setw(fdlen2)<<"Min Limit"<<str3<<setw(fdlen2)<<"Max Limit"<<str3<<"Measured"<<endl;
        cout << str1 << str3 << str2 << str3 << str2 << str3 << str2 << str3 << str2 << str3 << str2 << endl;
      } 
   }   /*if tistdscreenprint*/
}   /* PrintHeaderParam */
//
//
//void PrintResultParam(StringS tmpstr1,
//                           IntS tnum,
//                           BoolM test_results,
//                           FloatS llimit,
//                           FloatS ulimit,
//                           FloatM meas_values,
//                           BoolS paral_format)
//{
//   IntS site;
//   IntS fdlen1,fdlen2,fdlen3;
//   IntS fdlen4,decpt;
//   StringS str1,str2,str3,str4,str5;
//   FloatS FloatSval;
//   FloatS FloatSval;
//   StringS unitstr;
//   IntS unitlen;
//
//   if(tistdscreenprint)  
//   {
//      str1 = "------------------------------";  /*30*/
//      str2 = "------------";  /*12*/
//      str5 = "-----";  /*5*/
//      str3 = " "; 
//      fdlen1 = 30;
//      fdlen2 = 12;
//      fdlen3 = 12;
//      decpt  = 3;

//      if(paral_format)  
//      {
//         trealval = llimit;
// GetTreal_Unit_Info is a VLCT procedure that takes a tester real value & returns a
// generic real value, the length of the unit string portion of the tester real value,
// and the string defining the units.
//         GetTreal_Unit_Info(trealval,realval,unitlen,unitstr);
//original code         cout << tmpstr1:-fdlen1 << str3 << tnum:s_hex:fdlen2 << str3 << 
//               realval:(fdlen3-unitlen):decpt << unitstr << str3;
//         cout<<setw(fdlen1)<<tmpstr1<<str3<<hex<<setw(fdlen2)<<tnum<<str3<< 
//               dec<<setw(fdlen3-unitlen)<<setprecision(decpt)<<realval<<unitstr<<str3;

//         trealval = ulimit;
//         GetTreal_Unit_Info(trealval,realval,unitlen,unitstr);
//original code         cout << realval:(fdlen3-unitlen):decpt << unitstr << str3;
//         cout<<setw(fdlen3-unitlen)<<setprecision(decpt)<<realval<<unitstr<<str3;

//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         {
//Unison is sited
//            if(v_dev_active[site])  
//            {
//               trealval = meas_values[site];
//               GetTreal_Unit_Info(trealval,realval,unitlen,unitstr);
//               if(test_results[site])  
//original code                  cout << realval:(fdlen3-unitlen):decpt << unitstr << str3);
//                  cout<<setw(fdlen3-unitlen)<<setprecision(decpt)<<realval<<unitstr<<str3);
//               else
//original code                  cout << realval:(fdlen3-unitlen-2):decpt << unitstr << "**" << str3;
//                  cout<<setw(fdlen3-unitlen-2)<<setprecision(decpt)<<realval<<unitstr<<"**"<<str3;
//            }
//Unison is sited, so else clause is not required
//            else
//original code               cout << "X":fdlen3 << str3;
//               cout<<setw(fdlen3)<<"X"<<str3;
//         } 
//         cout << endl;
//      }  /*if paral_format*/
//      else
//      {  /*serial_format*/
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
 //original code              cout << tmpstr1:-fdlen1 << str3 << tnum:s_hex:fdlen2 << str3 << site:fdlen2 << str3;
//               cout<<setw(fdlen1)<<tmpstr1<<str3<<hex<<setw(fdlen2)<<tnum<<str3<<dec<<setw(fdlen2)<<site<<str3;
//               trealval = llimit;
//               GetTreal_Unit_Info(trealval,realval,unitlen,unitstr);
//original code               cout << realval:(fdlen3-unitlen):decpt << unitstr << str3;
//               cout<<setw(fdlen3-unitlen)<<setprecision(decpt)<<realval<<unitstr<<str3;
//               trealval = ulimit;
//               GetTreal_Unit_Info(trealval,realval,unitlen,unitstr);
//original code               cout << realval:(fdlen3-unitlen):decpt << unitstr << str3;
//               cout<<setw(fdlen3-unitlen)<<setprecision(decpt)<<realval<<unitstr<<str3;
//               trealval = meas_values[site];
//               GetTreal_Unit_Info(trealval,realval,unitlen,unitstr);
//original code               cout << realval:(fdlen3-unitlen):decpt << unitstr << str3;
 //              cout<<setw(fdlen3-unitlen)<<setprecision(decpt)<<realval<<unitstr<<str3;
//               if(test_results[site])  
//                  cout);
 //              else
//                  cout << "**" << endl;
//            } 
//      } 
//   }   /*if tistdscreenprint*/
//}   /* PrintResultParam */
//
//
//void PrintHeaderErsProg(  IntS preconllim, IntS preconulim,
//                               IntS ersllim, IntS ersulim,
//                               IntS cmptllim, IntS cmptulim,
//                             BoolS paral_format)
//{
//   IntS site;
//   IntS fdlen1,fdlen2,fdlen3,fdlen4;
//   StringS str1,str2,str3,str4,str5;
//   BoolS printprec,printers,printcmpt;
//
//   if(tistdscreenprint)  
//   {
//      str1 = "------------------------------";  /*30*/
//      str2 = "------------";  /*12*/
//      str3 = " "; 
//      fdlen1 = 30;
//      fdlen2 = 12;
//      fdlen3 = 18;
//      fdlen4 = 3;
//
//      if((preconllim==0) and (preconulim==0))  
//         printprec = false;
//      else
//         printprec = true;
//         
//      if((ersllim==0) and (ersulim==0))  
//         printers = false;
//      else
//         printers = true;
//         
//      if((cmptllim==0) and (cmptulim==0))  
//         printcmpt = false;
//      else
//         printcmpt = false;  /*true;*/
//
//      if(paral_format)  
//      {
//         cout << endl;
//         if(printprec)  
//            cout << str3:-fdlen1 << "PreCon Limit  Min==":fdlen3 << preconllim:fdlen4 << 
//                    "  Max==":fdlen2 << preconulim:fdlen4 << endl;
//         if(printers)  
//            cout << str3:-fdlen1 << "Erase Limit  Min==":fdlen3 << ersllim:fdlen4 << 
//                    "  Max==":fdlen2 << ersulim:fdlen4 << endl;
//         if(printcmpt)  
//            cout << str3:-fdlen1 << "Cmpct Limit  Min==":fdlen3 << cmptllim:fdlen4 << 
//                    "  Max==":fdlen2 << cmptulim:fdlen4 << endl;
//         
//         cout << "TestName ":-fdlen1 << str3 << "FL_TNUM":-fdlen2 << str3;
//
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         {
//            writestring(str5,site:1);
//            str5 = "Site" + str5;
//            if(printprec)  
//            {
//               str4 = str5 + "_Prec";
//               cout << str4:-fdlen2 << str3;
//            } 
//            if(printers)  
//            {
//               str4 = str5 + "_Ers";
//               cout << str4:-fdlen2 << str3;
//            } 
//            if(printcmpt)  
//            {
//               str4 = str5 + "_Cmpt";
//               cout << str4:-fdlen2 << str3;
//            } 
//         } 
//         cout << endl;
//         
//         cout << str1 << str3 << str2 << str3;
//            
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         {
//            if(printprec)  
//               cout << str2 << str3;
//            if(printers)  
//               cout << str2 << str3;
//            if(printcmpt)  
//               cout << str2 << str3;
//         } 
//         cout << endl;
//      }  /*if paral_format*/
//      else
//      {  /*serial_format*/
//         cout << endl;
//         cout << "TestName ":-fdlen1 << str3 << "FL_TNUM":fdlen2 << str3 << 
//               "Min Limit":fdlen2 << str3 << "Max Limit":fdlen2 << str3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         {
//            writestring(str5,site:1);
//            str5 = "Site" + str5;
//            cout << str5:fdlen2 << str3;
//         } 
//         cout << endl;
//         cout << str1 << str3 << str2 << str3 << str2 << str3 << str2 << str3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            cout << str2 << str3;
//         cout << endl;
//      } 
//   }   /*if tistdscreenprint*/
//}   /* PrintHeaderErsProg */
//
//
//void PrintResultErsProg(StringS tmpstr1,
//                             IntS tnum,
//                             IntM preconval,
//                             IntM ersval,
//                             IntM cmptval,
//                               IntS preconllim, IntS preconulim,
//                               IntS ersllim, IntS ersulim,
//                               IntS cmptllim, IntS cmptulim,
//                             BoolS paral_format)
//{
//   IntS site;
//   IntS fdlen1,fdlen2,fdlen3,fdlen4;
//   StringS str1,str2,str3,str4,str5;
//   BoolS printprec,printers,printcmpt;
//   StringS str6,str7;
//
//   if(tistdscreenprint)  
//   {
//      str1 = "------------------------------";  /*30*/
//      str2 = "------------";  /*12*/
//      str3 = " "; 
//      fdlen1 = 30;
//      fdlen2 = 12;
//      fdlen3 = 12;
//
//      if((preconllim==0) and (preconulim==0))  
//         printprec = false;
//      else
//         printprec = true;
//         
//      if((ersllim==0) and (ersulim==0))  
//         printers = false;
//      else
//         printers = true;
//         
//      if((cmptllim==0) and (cmptulim==0))  
//         printcmpt = false;
//      else
//         printcmpt = false;  /*true;*/
//
//      if(paral_format)  
//      {
//         cout << tmpstr1:-fdlen1 << str3 << tnum:s_hex:fdlen2 << str3;
//
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         {
//            if(v_dev_active[site])  
//            {
//               if(printprec)  
//               {
//                  if(preconval[site]>preconulim)  
//                     cout << preconval[site]:(fdlen3-2) << "**" << str3);
//                  else
//                     cout << preconval[site]:fdlen3 << str3;
//               } 
//               if(printers)  
//               {
//                  if((ersval[site]<ersllim) or (ersval[site]>ersulim))  
//                     cout << ersval[site]:(fdlen3-2) << "**" << str3);
//                  else
//                     cout << ersval[site]:fdlen3 << str3;
//               }                      
//               if(printcmpt)  
//               {
//                  if(cmptval[site]>cmptulim)  
//                     cout << cmptval[site]:(fdlen3-2) << "**" << str3);
//                  else
//                     cout << cmptval[site]:fdlen3 << str3;
//               } 
//            }
//            else
//            {
//               if(printprec)  
//                  cout << "X":fdlen3 << str3;
//               if(printers)  
//                  cout << "X":fdlen3 << str3;
//               if(printcmpt)  
//                  cout << "X":fdlen3 << str3;
//            } 
//         }   /*for site*/
//         cout << endl;
//      }  /*if paral_format*/
//      else
//      {  /*serial_format*/
//         if(printprec)  
//         {
//            str5 = tmpstr1 + "_PREC";
//            cout << str5:-fdlen1 << str3 << tnum:s_hex:fdlen2 << str3 << 
//                  preconllim:fdlen3 << str3 << preconulim:fdlen3 << str3;
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  if(preconval[site]>preconulim)  
//                     cout << preconval[site]:(fdlen3-2) << "**" << str3);
//                  else
//                     cout << preconval[site]:fdlen3 << str3;
//               }
//               else
//                  cout << "X":fdlen3 << str3;
//            cout << endl;
//         } 
//
//         if(printers)  
//         {
//            str5 = tmpstr1 + "_ERS";
//            cout << str5:-fdlen1 << str3 << tnum:s_hex:fdlen2 << str3 << 
//                  ersllim:fdlen3 << str3 << ersulim:fdlen3 << str3;
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  if((ersval[site]<ersllim) or (ersval[site]>ersulim))  
//                     cout << ersval[site]:(fdlen3-2) << "**" << str3);
//                  else
//                     cout << ersval[site]:fdlen3 << str3;
//               }
//               else
//                  cout << "X":fdlen3 << str3;
//            cout << endl;
//         } 
//
//         if(printcmpt)  
//         {
//            str5 = tmpstr1 + "_CMPT";
//            cout << str5:-fdlen1 << str3 << tnum:s_hex:fdlen2 << str3 << 
//                  cmptllim:fdlen3 << str3 << cmptulim:fdlen3 << str3;
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  if(cmptval[site]>cmptulim)  
//                     cout << cmptval[site]:(fdlen3-2) << "**" << str3);
//                  else
//                     cout << cmptval[site]:fdlen3 << str3;
//               }
//               else
//                  cout << "X":fdlen3 << str3;
//            cout << endl;
//         } 
//          /*writeln(tiwindow);*/
//      } 
//   }   /*if tistdscreenprint*/
//}   /* PrintResultErsProg */
//
//
//void PrintResultInt(StringS tmpstr1,
//                         IntS tnum,
//                         IntM cmptval,
//                           IntS cmptllim, IntS cmptulim,
//                         BoolS paral_format)
//{
//   IntS site;
//   IntS fdlen1,fdlen2,fdlen3,fdlen4;
//   StringS str1,str2,str3,str4,str5;
//   BoolS printprec,printers,printcmpt;
//   StringS str6,str7;
//
//   if(tistdscreenprint)  
//   {
//      str1 = "------------------------------";  /*30*/
//      str2 = "------------";  /*12*/
//      str3 = " "; 
//      str4 = "          --";  /*12*/
//      fdlen1 = 30;
//      fdlen2 = 12;
//      fdlen3 = 12;
//
//         
//      if((cmptllim==0) and (cmptulim==0))  
//         printcmpt = false;
//      else
//         printcmpt = true;
//
//      if(paral_format)  
//      {
//         if(printcmpt)  
//            cout << tmpstr1:-fdlen1 << str3 << tnum:s_hex:fdlen2 << str3 << cmptllim:fdlen3 << str3 << cmptulim:fdlen3 << str3);
//         else
//            cout << tmpstr1:-fdlen1 << str3 << tnum:s_hex:fdlen2 << str3 << str4 << str3 << str4 << str3;
//
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         {
//            if(v_dev_active[site])  
//            {
//               cout << cmptval[site]:fdlen3 << str3;
//            }
//            else
//            {
//               cout << "X":fdlen3 << str3;
//            } 
//         }   /*for site*/
//         cout << endl;
//      }  /*if paral_format*/
//      else
//      {  /*serial_format*/
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               cout << tmpstr1:-fdlen1 << " " << tnum:s_hex:fdlen2 << " " << site:fdlen3 << " " << 
//                       cmptval[site]:fdlen3 << endl;
//         cout << endl;
//      } 
//   }   /*if tistdscreenprint*/
//}   /* PrintResultInt */
//
//void PrintResultIntHex(StringS tmpstr1,
//                         IntS tnum,
//                         IntM cmptval,
//                           IntS cmptllim, IntS cmptulim,
//                         BoolS paral_format)
//{
//   IntS site;
//   IntS fdlen1,fdlen2,fdlen3,fdlen4;
//   StringS str1,str2,str3,str4,str5;
//   BoolS printprec,printers,printcmpt;
//   StringS str6,str7;
//
//   if(tistdscreenprint)  
//   {
//      str1 = "------------------------------";  /*30*/
//      str2 = "------------";  /*12*/
//      str3 = " "; 
//      str4 = "          --";  /*12*/
//      fdlen1 = 30;
//      fdlen2 = 12;
//      fdlen3 = 12;
//
//         
//      if((cmptllim==0) and (cmptulim==0))  
//         printcmpt = false;
//      else
//         printcmpt = true;
//
//      if(paral_format)  
//      {
//         if(printcmpt)  
//            cout << tmpstr1:-fdlen1 << str3 << tnum:s_hex:fdlen2 << str3 << cmptllim:fdlen3 << str3 << cmptulim:fdlen3 << str3);
//         else
//            cout << tmpstr1:-fdlen1 << str3 << tnum:s_hex:fdlen2 << str3 << str4 << str3 << str4 << str3;
//
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         {
//            if(v_dev_active[site])  
//            {
//               cout << cmptval[site]:s_hex:fdlen3 << str3;
//            }
//            else
//            {
//               cout << "X":fdlen3 << str3;
//            } 
//         }   /*for site*/
//         cout << endl;
//      }  /*if paral_format*/
//      else
//      {  /*serial_format*/
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               cout << tmpstr1:-fdlen1 << " " << tnum:s_hex:fdlen2 << " " << site:fdlen3 << " " << 
//                       cmptval[site]:s_hex:fdlen3 << endl;
//         cout << endl;
//      } 
//   }   /*if tistdscreenprint*/
//}   /* PrintResultIntHex */


//StringS FormatAddrString(IntS curraddr)
//{
//   IO.Print(addr_bcd, "%07x", curraddr);
//   writestring(addr_bcd,curraddr:s_hex:1);
//   length = addr_bcd.Length();
//   Writestring(addr_bcd,mid(addr_bcd,3,length-2));
//      switch((length-2)) {
//        case 1 : addr_bcd = "000000" + addr_bcd;
//        case 2 : addr_bcd = "00000" + addr_bcd;
//        case 3 : addr_bcd = "0000" + addr_bcd;
//        case 4 : addr_bcd = "000" + addr_bcd;
//        case 5 : addr_bcd = "00" + addr_bcd;
//        case 6 : addr_bcd = "0" + addr_bcd;
//      }   /* case */
//}          

 /*unified all platforms to use cpu byte address for startaddr/stopaddr*/
 // This function has been changed to be multi-site
void ReadRamAddress(IntS startaddr, IntS  stopaddr)
{
   StringS tpatt = "ramread_nburst_addr_v4p0_Thrd"; //"ramread_nburst_addr_Thrd";
   StringS datastr;
   StringS cap_name, label;
   StringS addr_str,s,str1,str2;
   IntS curraddr,offsetcyc;
   IntS maxcapcount;
   UnsignedM1D CaptureArr(33);
   UnsignedM1D sim_value(33,0);  // return all 0s to sim
   StringML captured_data;
   IntSL address_list;
   StringML SourceArr;
   UnsignedM msw_val,lsw_val;
   PinML data_pins,data_in;
   IntS evenodd, halfcapcount;
   int i;
   IntS physaddr;
   UnsignedS shiftbit;

//   Clockstopfreerun(s_clock1a);
// ????   
//   SetupGet(prevDCSU);
//   SetupSelect(prevDCSU,norm_fmsu);

   TIME.StartTimer();

#if $GL_USE_JTAG_RAMPMT or $GL_USE_DMLED_RAMPMT  
#if $GL_USE_JTAG_RAMPMT  
// :TODO: Fix this. Unneeded for Blizzard.
//    /*-------- use JTAG --------*/
//   data_pins = JTAG_DOUT;
//   data_in   = JTAG_DIN;
//   maxcapcount = 32;
//   istep = 1;
//   fails = 32;
//   dead_cyc = 0;
//   data_cycle[1] = PatternLabelGetCycle(tpatt,"LSW_DATA");
//   lsw_cycle = data_cycle[1];
//   for (counter = 2;counter <= fails;counter++)
//      data_cycle[counter] = data_cycle[1]+counter-1;
//
//   FailGetMax(save_fails, tpatt);
//   
//   curraddr = startaddr;
//   linebrk = 0;
//
//   if(TIStdScreenPrint)  
//   {
//      cout << "Site " << log_site:3 << "    Reading RAM contents (Msw << Lsw)." << 
//              "  Start Address = " << startaddr << "    Stop Address = " << stopaddr << endl;
//      cout << "RAM byte address" << endl;
//   } 
//   
//   while(curraddr <= stopaddr) do
//   {
//       /*abort if s key is pressed*/
//      if(Inkey(s))   break;
//      
//      failstr1 = "0000";
//      failstr2 = "0000";
//      failindex = 1;
//      offsetcyc = 0;
//      
//      IntToBinStr(curraddr,addr_str);
//      
//      for (offsetcyc = 0;offsetcyc <= 15;offsetcyc++)
//         Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,
//                                data_in,S_binary,
//                                Mid(addr_str,16-(1*offsetcyc),1));
//
//       /* formatting address for print out later*/
//      FormatAddrString;
//      
//      FailSetMax(fails, tpatt);
//      Enable(S_FAIL_MEMORY);
//      
//      result = (PatternExecute(tmpint,tpatt));
//      failcount = FailGetCount;
//      
//      if (failcount <> 0)  
//      {
//         while (failindex <= failcount) do
//         {
//            pinlistget(data_pins,pl_arr,pl_len);
//            failstr = "00000000000000000000000000000000";
//            
//            for (tmpint = 1;tmpint <= failcount;tmpint++)
//            {
//               log_opt = FailGetInfo(failindex, pm_addr, rpt_count, loop_count,
//                                      scan_block, cycles, src_line );
//               if((log_site>=1) and (log_site<=V_Sites))  
//               {
//                  if (V_Dev_Active[log_site] and (V_Fail_Count[log_site]>=failcount))  
//                  {
//                     if not V_PF_Status[log_site]  
//                     {
//                        FailGetSitePinList(log_site, failindex, pl_failarr,pl_faillen);
//                        fail_cycle = V_Cycle[log_site];
//                        for (counter = 1;counter <= maxcapcount;counter++)
//                           if((data_cycle[index] = fail_cycle) and (pl_failarr[1]=pl_arr[1]))  
//                              failstr[(maxcapcount+1)-counter] = "1";
//                     }   /*if not V_PF_Status*/
//                  }   /*if V_Fail_Count*/
//               }   /*if log_site*/
//               failindex = failindex + 1;
//            }   /*for tmpint*/
//            
//            Readstring("0b" + failstr) + temp_value;
//            Writestring(temp_bcd,temp_value:S_hex:1);
//            length = len(temp_bcd);
//            Writestring(temp_bcd,mid(temp_bcd,3,length-2));
//            
//            switch((length-2)) {
//              case 1 : temp_bcd = "0000000" + temp_bcd;
//              case 2 : temp_bcd = "000000" + temp_bcd;
//              case 3 : temp_bcd = "00000" + temp_bcd;
//              case 4 : temp_bcd = "0000" + temp_bcd;
//              case 5 : temp_bcd = "000" + temp_bcd;
//              case 6 : temp_bcd = "00" + temp_bcd;
//              case 7 : temp_bcd = "0" + temp_bcd;
//            }   /* case */
//                  
//            failstr2 = Mid(temp_bcd, 1, 4);
//            failstr1 = Mid(temp_bcd, 5, 4);
//         }   /*while failindex*/
//      }   /*if failcount*/
//
//      if(linebrk=0)  
//      {
//         if(TIStdScreenPrint)  
//         {
//            cout << endl;
//            cout << "0x" << addr_bcd << "  ";
//         } 
//      } 
//      
//      if(TIStdScreenPrint)  
//         cout << failstr2 << " " << failstr1 << " ";  /*msb/lsb*/
//      failresetmax;
//      Disable(S_FAIL_MEMORY);
//      curraddr = curraddr+ADDR_RAM_INC;
//      linebrk = linebrk+1;
//      if(linebrk=4)  
//         linebrk=0;
//      
//   }   /* while curraddr */
//   
//   Disable(S_FAIL_MEMORY);
//   FailSetMax(save_fails, tpatt);
//    /*-------- end of JTAG --------*/
#else
    /*-------- use DMLED --------*/
   data_in   = "DMLED_INBUS";
   data_pins = "DMLED_OUTBUS";
   cap_name = "CapRam32";
   maxcapcount = 8;
//   maxsrccount = 17;
   halfcapcount = maxcapcount / 2;
//   istep = 8;
   
   curraddr = startaddr;
   
   while(curraddr <= stopaddr)
   {         
      offsetcyc = 0;

      physaddr = curraddr>>3;
      addr_str = IntToVLSIDriveStr(physaddr, 16, true);
      evenodd = (curraddr>>2) & 0x1;

      SourceArr.Erase();
      for (offsetcyc = 0;offsetcyc <= 15;offsetcyc++)
      {
         str2 = "LLL" + addr_str.Substring(15-offsetcyc, 1);
         SourceArr += str2;
      } 
      
      label = PatternBurst(tpatt).GetPattern(0).GetName() + ".MOD_ADDR";
      DIGITAL.ModifyVectors(data_in, tpatt, label, SourceArr);

      SourceArr.Erase();
      str1 = IntToVLSIDriveStr(evenodd, 4, true);
      SourceArr += str1;

      DIGITAL.ModifyVectors(data_in, tpatt, label, 36, SourceArr, "L");

      PatternDigitalCapture(tpatt,data_pins,cap_name,maxcapcount,CaptureArr,sim_value);

      msw_val = 0;
      lsw_val = 0;
      
      for (i = 0;i < halfcapcount;++i)
      {
         shiftbit = 4*(i);
         lsw_val = lsw_val + (CaptureArr[i]<<shiftbit);
         msw_val = msw_val + (CaptureArr[i+4]<<shiftbit);
      } 

      IO.Print(datastr, "%04x %04x", msw_val, lsw_val);
      captured_data += datastr;
      address_list += curraddr;
      
      curraddr = curraddr+ADDR_RAM_INC;
      
   }   /* while curraddr */

    /*-------- end of DMLED --------*/
#endif
#else   
// :TODO: Fix this. Unneeded for Blizzard.
//   if(false)     /*GL_DO_ESDA_WITH_SCRAM*/
//   {
//      curraddr = startaddr;
//      linebrk = 0;
//
//      while(curraddr <= stopaddr) do
//      {
//         IntToBinStr(curraddr>>2,addr_str);
//
//         if(GL_USE_RAMPMT_X64)  
//         {
//            maxcapcount = 8;
//            istep = 8;
//            for (offsetcyc = 0;offsetcyc <= 3;offsetcyc++)   //:NOTE: THIS SHOULD BE offsetcyc = 0 downto 3?? how is it downto 3???
//               Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,
//                                      PMT_RAMBUS,S_binary,
//                                      Mid(addr_str,13-(4*offsetcyc),4));
//         }
//         else
//         {
//            maxcapcount = 2;
//            istep = 2;
//            Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,
//                                   PMT_RAMBUS,S_binary,addr_str);
//         } 
//         
//          /* formatting address for print out later*/
//         FormatAddrString;
//         
//         SaveMemsetBistData = V_MemSetBistData;
//         V_MemSetBistData = false;  /* Prevents SCRAM statements from giving error */
//         
//         data_pins = PMT_RAMBUS;
//         PatternDigitalCapture(tpatt, data_pins, maxcapcount, CaptureArr);
//
//         if(GL_USE_RAMPMT_X64)  
//         {
//            index = 1;
//            for count = 1 to maxcapcount by istep do
//            {
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site] and (site=log_site))  
//                  {
//                     tnib0 = CaptureArr[site][count];    /*ls nibble*/
//                     tnib1 = CaptureArr[site][count+1]<<4;
//                     tnib2 = CaptureArr[site][count+2]<<8;
//                     tnib3 = CaptureArr[site][count+3]<<12;  /*ms nibble*/
//                     lsw_val[site] = tnib3+tnib2+tnib1+tnib0;  /*lsw*/
//                     tnib0 = CaptureArr[site][count+4];    /*ls nibble*/
//                     tnib1 = CaptureArr[site][count+5]<<4;
//                     tnib2 = CaptureArr[site][count+6]<<8;
//                     tnib3 = CaptureArr[site][count+7]<<12;  /*ms nibble*/
//                     msw_val[site] = tnib3+tnib2+tnib1+tnib0;  /*lsw*/
//                  }   /*if v_dev_active*/
//               index = index+2;
//            }   /*for count*/
//         }
//         else
//         {
//            for count = 1 to maxcapcount by istep do
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site] and (site=log_site))  
//                  {
//                     lsw_val[site] = CaptureArr[site][count];
//                     msw_val[site] = CaptureArr[site][count+1];
//                  }   /*if v_dev_active*/
//         } 
//
//         for (count = 1;count <= 2;count++)
//         {
//            if(count=1)  
//               writestring(temp_bcd,msw_val[log_site]:s_hex:1);
//            else
//               writestring(temp_bcd,lsw_val[log_site]:s_hex:1);
//            
//            length = len(temp_bcd);
//            Writestring(temp_bcd,mid(temp_bcd,3,length-2));
//            switch((length-2)) {
//              case 1 : temp_bcd = "000" + temp_bcd;
//              case 2 : temp_bcd = "00" + temp_bcd;
//              case 3 : temp_bcd = "0" + temp_bcd;
//            }   /* case */
//
//            if(count=1)  
//               failstr2 = temp_bcd;
//            else
//               failstr1 = temp_bcd;
//         }   /*for count*/
//         
//         if(linebrk=0)  
//         {
//            if(TIStdScreenPrint)  
//            {
//               cout << endl;
//               cout << "0x" << addr_bcd << "  ";
//            } 
//         } 
//         
//         if(TIStdScreenPrint)  
//            cout << failstr2 << " " << failstr1 << " ";  /*msb/lsb*/
//
//         curraddr = curraddr+ADDR_RAM_INC;
//         linebrk = linebrk+1;
//         if(linebrk=4)  
//            linebrk=0;
//      }   /*while*/
//   }
//   else
//   {
//      if(GL_USE_RAMPMT_X64)  
//      {
//         fails = 8;
//         dead_cyc = 0;
//         data_cycle[1] = PatternLabelGetCycle(tpatt,"LSW_DATA");
//         lsw_cycle = data_cycle[1];
//         for (counter = 2;counter <= 8;counter++)
//            data_cycle[counter] = data_cycle[1]+counter-1;
//      }
//      else
//      {
//         fails = 2;
//         lsw_cycle = PatternLabelGetCycle(tpatt,"LSW_DATA");  /*lower 16-bit data*/
//         msw_cycle = lsw_cycle+1;  /*upper 16-bit data*/
//      } 
//      
//      if(lsw_cycle=0)  
//      {
//         if(tistdscreenprint)  
//         {
//            cout << "*** ERROR : Cannot find label LSW_DATA ***" << endl;
//            cout << "*** Contents will be invalid.          ***" << endl;
//         }
//         else
//         {
//            cout << "*** ERROR : Cannot find label LSW_DATA ***" << endl;
//            cout << "*** Contents will be invalid.          ***" << endl;
//         } 
//      } 
//      
//      
//      FailGetMax(save_fails, tpatt);
//      
//      curraddr = startaddr;
//      linebrk = 0;
//      
//      if(not TIStdScreenPrint)  
//         cout << "***PLEASE SET TIStdScreenPrint TO true for this ***" << endl;
//      
//      if(TIStdScreenPrint)  
//      {
//         cout << "Site " << log_site:3 << "    Reading RAM contents (Msw << Lsw)." << 
//                 "  Start Address = " << startaddr << "    Stop Address = " << stopaddr << endl;
//         cout << "RAM byte address" << endl;
//      } 
//      
//      while(curraddr <= stopaddr) do
//      {
//         
//          /*abort if s key is pressed*/
//         if(Inkey(s))   break;
//         
//         failstr1 = "0000";
//         failstr2 = "0000";
//         failindex = 1;
//         offsetcyc = 0;
//         
//         IntToBinStr(curraddr>>2,addr_str);
//         if(GL_USE_RAMPMT_X64)  
//         {
//            for (offsetcyc = 0;offsetcyc <= 3;offsetcyc++) //:NOTE: THIS SHOULD BE offsetcyc = 0 downto 3?? how is it downto 3???
//               Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,
//                                      PMT_RAMBUS,S_binary,
//                                      Mid(addr_str,13-(4*offsetcyc),4));
//         }
//         else
//            Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,
//                                   PMT_RAMBUS,S_binary,addr_str);
//         
//          /* formatting address for print out later*/
//         FormatAddrString;
//         
//         FailSetMax(fails, tpatt);
//         Enable(S_FAIL_MEMORY);
//         
//         result = (PatternExecute(tmpint,tpatt));
//         failcount = FailGetCount;
//         
//         
//         if (failcount <> 0)  
//         {
//            while (failindex <= failcount) do
//            {
//               pinlistget(pmt_rambus,pl_arr,pl_len);
//               
//               if(GL_USE_RAMPMT_X64)  
//               {
//                  failstr = "00000000000000000000000000000000";
//                  for (tmpint = 1;tmpint <= failcount;tmpint++)
//                  {
//                     log_opt = FailGetInfo(failindex, pm_addr, rpt_count, loop_count,
//                                            scan_block, cycles, src_line );
//                     if((log_site>=1) and (log_site<=V_Sites))  
//                     {
//                        if (V_Dev_Active[log_site] and
//                            (V_Fail_Count[log_site]>=failcount))  
//                        {
//                           if not V_PF_Status[log_site]  
//                           {
//                              FailGetSitePinList(log_site, failindex, pl_failarr,pl_faillen);
//                              fail_cycle = V_Cycle[log_site];
//                              for (counter = 1;counter <= 8;counter++)
//                                 if (data_cycle[counter] = fail_cycle)  
//                                    data_nib = counter;
//                              for (counter = 1;counter <= pl_faillen;counter++)
//                                 for (plindex = 1;plindex <= pl_len;plindex++)
//                                    if(pl_failarr[counter] = pl_arr[plindex])  
//                                       failstr[33-((data_nib-1)*4)-plindex] = "1";
//                           }   /*if not V_PF_Status*/
//                        }   /*if V_Fail_Count*/
//                     }   /*if log_site*/
//                     failindex = failindex + 1;
//                  }   /*for tmpint*/
//                  
//                   /*convert bin string to int number*/
//                  Readstring("0b" + failstr) + temp_value;
//                  
//                   /*convert int number to hex string w/ 0x prefix*/
//                  Writestring(temp_bcd,temp_value:S_hex:1);
//                  
//                   /*extract string w/o 0x prefix and prepend 0s as needed*/
//                  length = len(temp_bcd);
//                  Writestring(temp_bcd,mid(temp_bcd,3,length-2));
//                  
//                  switch((length-2)) {
//                    case 1 : temp_bcd = "0000000" + temp_bcd;
//                    case 2 : temp_bcd = "000000" + temp_bcd;
//                    case 3 : temp_bcd = "00000" + temp_bcd;
//                    case 4 : temp_bcd = "0000" + temp_bcd;
//                    case 5 : temp_bcd = "000" + temp_bcd;
//                    case 6 : temp_bcd = "00" + temp_bcd;
//                    case 7 : temp_bcd = "0" + temp_bcd;
//                  }   /* case */
//                  
//                  failstr2 = Mid(temp_bcd, 1, 4);
//                  failstr1 = Mid(temp_bcd, 5, 4);
//               }  /*X64*/
//               else
//               {
//                  log_opt = FailGetInfo(failindex, pm_addr, rpt_count, loop_count,
//                                         scan_block, cycles, src_line );
//                  failstr = "0000000000000000";
//                  
//                  if((log_site>=1) and (log_site<=v_sites))  
//                  {
//                     for (site = log_site;site <= log_site;site++)
//                     {
//                        if(v_dev_active[site] and
//                           (v_fail_count[site]>=failcount))  
//                        {
//                           if not v_pf_status[site]  
//                           {
//                              FailGetSitePinList(log_site, failindex,
//                                                 pl_failarr, pl_faillen);
//                              fail_cycle = V_cycle[log_site];
//                              for (counter = 1;counter <= pl_faillen;counter++)
//                              {
//                                 for (plindex = 1;plindex <= pl_len;plindex++)
//                                    if(pl_failarr[counter] = pl_arr[plindex])  
//                                       failstr[17-plindex] = "1";
//                              }   /*counter*/
//                           }   /*not pf_stat*/
//                        }   /*if v_dev_active*/
//                     }   /*for site*/
//                  }   /*if log_site*/
//                  
//                   /*convert bin string to int number*/
//                  Readstring("0b" + failstr) + temp_value;
//                  
//                   /*convert int number to hex string w/ 0x prefix*/
//                  Writestring(temp_bcd,temp_value:S_hex:1);
//                  
//                   /*extract string w/o 0x prefix and prepend 0s as needed*/
//                  length = len(temp_bcd);
//                  Writestring(temp_bcd,mid(temp_bcd,3,length-2));
//                  
//                  switch((length-2)) {
//                    case 1 : temp_bcd = "000" + temp_bcd;
//                    case 2 : temp_bcd = "00" + temp_bcd;
//                    case 3 : temp_bcd = "0" + temp_bcd;
//                  }   /* case */
//                  
//                  if(fail_cycle = lsw_cycle)  
//                     failstr1 = temp_bcd;
//                  else
//                     failstr2 = temp_bcd;
//                  
//                  failindex = failindex + 1;
//               }   /*not X64*/
//               
//            }   /* while failindex */
//         }   /* failcount<>0 */
//         
//         if(linebrk=0)  
//         {
//            if(TIStdScreenPrint)  
//            {
//               cout << endl;
//               cout << "0x" << addr_bcd << "  ";
//            } 
//         } 
//         
//         if(TIStdScreenPrint)  
//            cout << failstr2 << " " << failstr1 << " ";  /*msb/lsb*/
//         
//         failresetmax;
//         Disable(S_FAIL_MEMORY);
//         curraddr = curraddr+ADDR_RAM_INC;
//         linebrk = linebrk+1;
//         if(linebrk=4)  
//            linebrk=0;
//         
//      }   /* while curraddr */
//
//      Disable(S_FAIL_MEMORY);
//      FailSetMax(save_fails, tpatt);
//   } 
#endif

// ????
//   SetupSelect(prevDCSU,norm_fmsu);

   // set sticky cout settings for loop
   cout << hex << setfill('0');  
   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
   {
      cout << "Site " << *si << "   Reading RAM contents (Msw << Lsw)." << 
           "  Start Address = " << setw(4) << startaddr << 
           "    Stop Address = " << setw(4) << stopaddr << endl;
      cout << "RAM byte address" << endl;
      
      cout << endl;
      
      int linebrk = 0;
      for (i = 0 ; i < address_list.GetSize(); ++i)
      {
         if (linebrk == 0)
            cout << endl << "0x" << setw(7) << address_list[i];
            
         cout << " " << captured_data[*si][i];  /*msb/lsb*/
         if (++linebrk == 4) // VLCT added 1 to linebrk, then checked = 4
            linebrk = 0;
      }
      cout << endl << endl;
   }
   cout << dec << setfill(' '); // reset sticky settings to default


   cout << endl;
   cout << "Done.  TT = " << TIME.StopTimer() << endl;
   cout << endl;

}   /*ReadRamAddress*/


      
void DumpRamMailbox()
{
   IntS stopaddr,startaddr;
   IntS length,site;

   if(!ActiveSites.Begin().End())  
   {
      length    = 64*4;
      startaddr = ADDR_RAM_MAILBOX;
      stopaddr  = startaddr+length;
      ReadRamAddress(startaddr,stopaddr);
   } 
}   /* DumpRamMailbox */



void GetRamContentDec_16Bit(    StringS tpatt,
                                     IntS addr_loc,
                                     IntM &ret_val)
{
   IntS curraddr,offsetcyc,index;
   StringS addr_str,str1,str2, cap_name;
   IntM temp_value;
   BoolS debugprint;
   UnsignedM1D CaptureArr(18);
   UnsignedM1D sim_cap_arr(18, 0);
   UnsignedS shiftbit, count, maxcapcount;
   StringML SourceArr; 
   PinML data_pins,data_in;
   IntS maxsrccount;
   IntS evenodd,physaddr;

   debugprint = false;  /*TI_FlashDebug and tiignorefail;*/
   if(tistdscreenprint and debugprint)     
      TIME.StartTimer();
      
   offsetcyc = 0;

   temp_value = 0;


#if $GL_USE_JTAG_RAMPMT or $GL_USE_DMLED_RAMPMT  
#if $GL_USE_JTAG_RAMPMT  
//  :TODO: come back and do the JTAG section...unneeded for Blizzard
//    /*-------- use JTAG --------*/
//   data_pins = JTAG_DOUT;
//   data_in   = JTAG_DIN;
//   maxcapcount = 16;
//   istep = 1;
//   
//   //IntToBinStr(addr_loc,addr_str);
//   addr_str = IntToVLSIDriveStr(addr_loc, 16, true);
//   
//   if(GL_DO_SOURCE_WITH_SCRAM)  
//   {
//      for (offsetcyc = 0;offsetcyc <= 15;offsetcyc++)
//      {
//         SourceArr += addr_str[15-offsetcyc]; // makes SourceArr LSB first
//          /*if(tistdscreenprint and TI_FlashDebug) then
//              write(tiwindow,"SourceArr[ ",(offsetcyc+1):-2," ] = ",SourceArr[site,offsetcyc+1]:-2, "  ");
//          */
//      } 
//          /*if(tistdscreenprint and TI_FlashDebug) then
//             writeln(tiwindow);
//          */
//   }
//   else
//   {
//      StringML temp_arr;
//      for (offsetcyc = 0;offsetcyc <= 15;offsetcyc++)
//         temp_arr += addr_str[15-offsetcyc]; // LSB first
//      StringS pat_label = PatternBurst(tpatt).GetPattern(0).GetName() + ".MOD_ADDR";
//      DIGITAL.ModifyVectors(data_in, tpatt, pat_label, temp_arr);
//   } 
//
//   if(GL_DO_ESDA_WITH_SCRAM)  
//   {
//      if(GL_DO_SOURCE_WITH_SCRAM)  
//         PatternDigitalSourceCapture(tpatt,data_in,data_pins,maxcapcount,maxcapcount,
//                                     false, SourceArr,CaptureArr)
//      else
//         PatternDigitalCapture(tpatt,data_pins,maxcapcount, CaptureArr);
//
//      for (count = 1;count <= maxcapcount;count++)
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               temp_value[site] = temp_value[site]+(CaptureArr[site][count] << (count-1));
//       /*
//       if(tistdscreenprint and TI_FlashDebug) then
//       begin
//          for site := 1 to v_sites do
//             if(v_dev_active[site]) then
//                writeln(tiwindow,"Site",site:-5," addr = ",addr_loc:s_hex,"  data = ",temp_value[site]:s_hex);
//       end;
//       */
//   }
//   else
//   {
//      data_cycle[1] = PatternLabelGetCycle(tpatt,"LSW_DATA");
//      lsw_cycle = data_cycle[1];
//      for (counter = 2;counter <= maxcapcount;counter++)
//         data_cycle[counter] = data_cycle[1]+counter-1;
//
//      failsetmax(maxcapcount,tpatt);
//      Enable(S_Fail_Memory);
//      tmpbool = PatternExecute(tmpint, tpatt);
//
//      if(not tmpbool)  
//      {
//         failcount = failgetcount;
//         failindex = 1;
//         PinlistGet(data_pins,pl_arr,pl_len);
//
//         for (tmpint = 1;tmpint <= failcount;tmpint++)
//         {
//            FailGetInfo(failindex,pm_addr,rpt_count,loop_count,scan_block, cycles, src_line );
//
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site] and (not v_pf_status[site]) and (tmpint <= v_fail_count[site]))  
//               {
//                  fail_cycle = v_cycle[site];
//                  for (index = 1;index <= maxcapcount;index++)
//                     if((data_cycle[index] = fail_cycle) and (pl_failarr[1]=pl_arr[1]))  
//                        tmpArray[site][(maxcapcount+1)-index] = "1";
//               } 
//            failindex = failindex+1;
//         }   /*for tmpint*/
//
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               Readstring("0b" + tmpArray[site]) + temp_value[site];
//                /*
//                if(tistdscreenprint and TI_FlashDebug) then
//                   writeln(tiwindow,"Site",site:-5," value = ",temp_value[site],"  ",temp_value[site]:s_hex);
//                 */
//            } 
//      }   /*tmpbool*/
//
//      failresetmax;
//      Disable(S_Fail_Memory);
//   }    
//      
//   ret_val =  temp_value;
//    /*-------- end of JTAG --------*/
#else
    /*-------- use DMLED --------*/
   data_in   = "DMLED_INBUS";
   data_pins = "DMLED_OUTBUS";
   cap_name = "CapRam4";
   maxcapcount = 4;
   maxsrccount = 17;
//   istep = 4;

   physaddr = addr_loc>>3;
   evenodd = (addr_loc>>2) & 0x1;
   
//   if(GL_DO_SOURCE_WITH_SCRAM)  
//   {
   // :TODO: Fix. Is this needed at all? Alternate method but not sure we care
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      {
//         for (offsetcyc = 0;offsetcyc <= (maxsrccount-2);offsetcyc++)
//         {
//            SourceArr[site][offsetcyc+1] = ((physaddr & (0x1<<offsetcyc)) >> offsetcyc) & 0x1;
//             /*if(tistdscreenprint and TI_FlashDebug) then
//                 writeln(tiwindow,"SourceArr[ ",(offsetcyc+1):-2," ] = ",SourceArr[site,offsetcyc+1]:-2, "  ");
//             */
//         } 
//         SourceArr[site][maxsrccount] = evenodd;
//         break;
//      } 
//   }
//   else
//   {
      addr_str = IntToVLSIDriveStr(physaddr, 16, true);
      for (offsetcyc = 0;offsetcyc <= (maxsrccount-2);offsetcyc++)
      {
         SourceArr += "LLL" + addr_str.Substring(15-offsetcyc, 1); 
      } 
      StringS pat_label = PatternBurst(tpatt).GetPattern(0).GetName() + ".MOD_ADDR";
      DIGITAL.ModifyVectors(data_in, tpatt, pat_label, SourceArr);      
      
       /*control word*/
      str1 = IntToVLSIDriveStr(evenodd, 4, true);
//      Patternlabelsetpindata(tpatt,"MOD_ADDR",36,data_in,S_binary,str1);
      SourceArr.Erase();
      SourceArr += str1;
      DIGITAL.ModifyVectors(data_in, tpatt, pat_label, 36, SourceArr, "L");
//   } 

//   if(GL_DO_ESDA_WITH_SCRAM)  
//   {
//      if(GL_DO_SOURCE_WITH_SCRAM)  
   // :TODO: Fix. Is this needed at all? Alternate method but not sure we care
//         PatternDigitalSourceCapture(tpatt,data_in,data_pins,maxcapcount,maxcapcount,false,SourceArr,CaptureArr);
//      else
      PatternDigitalCapture(tpatt, data_pins, cap_name, maxcapcount, CaptureArr, sim_cap_arr);

      for (count = 0;count < maxcapcount;count++)
      {
         shiftbit = 4*(count);
         temp_value += (CaptureArr[count] << shiftbit);
// Remove below 2 lines if the above works
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            temp_value[*si] += (CaptureArr[*si][count]<<shiftbit);
      } 
//   }
//   else
//   {
   // :TODO: Fix. Is this needed at all? Alternate method but not sure we care
//      data_cycle[1] = PatternLabelGetCycle(tpatt,"LSW_DATA");
//      lsw_cycle = data_cycle[1];
//      for (counter = 2;counter <= maxcapcount;counter++)
//         data_cycle[counter] = data_cycle[1]+counter-1;
//
//      failsetmax(maxcapcount,tpatt);
//      Enable(S_Fail_Memory);
//      tmpbool = PatternExecute(tmpint, tpatt);
//
//      if(not tmpbool)  
//      {
//         failcount = failgetcount;
//         failindex = 1;
//         PinlistGet(data_pins,pl_arr,pl_len);
//
//         for (tmpint = 1;tmpint <= failcount;tmpint++)
//         {
//            FailGetInfo(failindex,pm_addr,rpt_count,loop_count,scan_block, cycles, src_line );
//
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site] and (not v_pf_status[site]) and (tmpint <= v_fail_count[site]))  
//               {
//                  FailGetSitePinList(site, failindex, pl_failarr,pl_faillen);
//                  fail_cycle = v_cycle[site];
//                  for (counter = 1;counter <= fails;counter++)
//                     if(data_cycle[counter]=fail_cycle)  
//                        data_nib = counter;
//                  for (counter = 1;counter <= pl_faillen;counter++)
//                  {
//                     for (plindex = 1;plindex <= pl_len;plindex++)
//                        if(pl_failarr[counter] = pl_arr[plindex])  
//                           tmpArray[site][17-((data_nib-1)*4)-plindex] = "1";
//                  } 
//               } 
//            failindex = failindex+1;
//         }   /*for tmpint*/
//
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               Readstring("0b" + tmpArray[site]) + temp_value[site];
//                /*
//                if(tistdscreenprint and TI_FlashDebug) then
//                   writeln(tiwindow,"Site",site:-5," value = ",temp_value[site],"  ",temp_value[site]:s_hex);
//                 */
//            } 
//      }   /*tmpbool*/
//
//      failresetmax;
//      Disable(S_Fail_Memory);
//   }    
      
   ret_val =  temp_value;
    /*-------- end of DMLED --------*/
#endif
#else
// :TODO: Fix this. Unneeded for Blizzard.
//   data_pins = PMT_RAMBUS;
//
//   IntToBinStr(addr_loc>>2,addr_str);
//   
//   if(GL_USE_RAMPMT_X64)  
//   {
//      maxcapcount = 4;
//      istep = 4;
//      fails = 4;
//      if(not GL_DO_ESDA_WITH_SCRAM)  
//      {
//         dead_cyc = 0;
//         data_cycle[1] = PatternLabelGetCycle(tpatt,"LSW_DATA");
//         lsw_cycle = data_cycle[1];
//         for (counter = 2;counter <= maxcapcount;counter++)
//            data_cycle[counter] = data_cycle[1]+counter;
//      } 
//      for (offsetcyc = 0;offsetcyc <= 3;offsetcyc++) //:NOTE: THIS SHOULD BE offsetcyc = 0 downto 3?? how is it downto 3???
//         Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,
//                                data_pins,S_binary,
//                                Mid(addr_str,13-(4*offsetcyc),4));
//   }
//   else
//   {
//      maxcapcount = 1;
//      istep = 1;
//      fails = 1;
//      Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,
//                             data_pins,S_binary,addr_str);
//   } 
//
//   if(tistdscreenprint and debugprint)  
//      IO.Print(IO.Stdout,"reading ram address ",addr_loc:s_hex);
//
//   if(false )   /*GL_DO_ESDA_WITH_SCRAM*/
//   {
//      SaveMemsetBistData = V_MemSetBistData;
//      V_MemSetBistData = false;  /* Prevents SCRAM statements from giving error */
//
//      PatternDigitalCapture(tpatt, data_pins, maxcapcount, CaptureArr);
//
//      if(GL_USE_RAMPMT_X64)  
//      {
//         index = 1;
//         for count = 1 to maxcapcount by istep do
//         {
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  tnib0 = CaptureArr[site][count];    /*ls nibble*/
//                  tnib1 = CaptureArr[site][count+1]<<4;
//                  tnib2 = CaptureArr[site][count+2]<<8;
//                  tnib3 = CaptureArr[site][count+3]<<12;  /*ms nibble*/
//                  FL_SCRAM_CAPT_ARR[index][site] = tnib3+tnib2+tnib1+tnib0;  /*lsw*/
//               }   /*if v_dev_active*/
//            index = index+2;
//         }   /*for count*/
//      }
//      else
//      {
//         for count = 1 to maxcapcount by istep do
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  FL_SCRAM_CAPT_ARR[count][site] = CaptureArr[site][count];
//               }   /*if v_dev_active*/
//      } 
//
//      ret_val = FL_SCRAM_CAPT_ARR[1];
//      V_MemSetBistData = SaveMemsetBistData;
//
//   }
//   else
//   {
//      failsetmax(fails,tpatt);
//      Enable(S_Fail_Memory);
//      tmpbool = PatternExecute(tmpint, tpatt);
//      failcount = failgetcount;
//      failindex = 1;
//      
//      if(not tmpbool)  
//      {
//         PinlistGet(data_pins,pl_arr,pl_len);
//         
//         if(GL_USE_RAMPMT_X64)  
//         {
//            for (tmpint = 1;tmpint <= fails;tmpint++)
//            {
//               if(failcount >= tmpint)  
//               {
//                  log_opt = FailGetInfo(failindex, pm_addr, rpt_count, loop_count,
//                                         scan_block, cycles, src_line );
//                  
//                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  {
//                     if(V_Fail_Count[site] >= tmpint)  
//                     {
//                        if (V_Dev_Active[site] and (not V_PF_Status[site]))  
//                        {
//                           FailGetSitePinList(site, failindex, pl_failarr,pl_faillen);
//                           fail_cycle = V_Cycle[site];
//                           for (counter = 1;counter <= fails;counter++)
//                              if((data_cycle[counter]=fail_cycle) or
//                                 (data_cycle[counter+fails]=fail_cycle))  
//                                 data_nib = counter;
//                           for (counter = 1;counter <= pl_faillen;counter++)
//                           {
//                              for (plindex = 1;plindex <= pl_len;plindex++)
//                                 if(pl_failarr[counter] = pl_arr[plindex])  
//                                    tmpArray[site][17-((data_nib-1)*4)-plindex] = "1";
//                              if(TIStdScreenPrint and debugprint)  
//                                 writeln(TIWindow,"site ",site:2," Fail Pin  ",
//                                         pl_failarr[counter], fail_cycle);
//                           } 
//                        }   /*if v_dev_active & not V_PF_Status*/
//                     }   /*if V_Fail_Count*/
//                  }   /*for site*/
//                  failindex = failindex + 1;
//               }   /*if failcount*/
//            }   /*for tmpint*/
//            
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            {
//                /*convert binary string to integer number*/
//               ReadString("0b" + tmpArray[site]) + temp_value[site];
//               
//               if(tistdscreenprint and debugprint)  
//                  IO.Print(IO.Stdout,"site ",site:2,"  value ",temp_value[site],
//                          "  ",temp_value[site]:s_hex);
//            }             
//         }  /*X64*/
//         else
//         {
//            log_opt = FailGetInfo(failindex, pm_addr, rpt_count, loop_count,
//                                   scan_block, cycles, src_line );
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            {
//               if (v_dev_active[site])  
//               {
//                  if not v_pf_status[site]  
//                  {
//                     FailGetSitepinList(site, 1, pl_failarr, pl_faillen);
//                     for (index = 1;index <= pl_faillen;index++)
//                     {
//                        for (plindex = 1;plindex <= pl_len;plindex++)
//                           if(pl_failarr[index] = pl_arr[plindex])  
//                              tmpArray[site][(17-plindex)] = "1";
//                        if(tistdscreenprint and debugprint)  
//                           IO.Print(IO.Stdout,"site ",site:3,"Fail Pin  ",
//                                   pl_failarr[index]);
//                     } 
//                     
//                      /*convert binary string to integer number*/
//                     ReadString("0b" + tmpArray[site]) + temp_value[site];
//                     
//                     if(tistdscreenprint and debugprint)  
//                        IO.Print(IO.Stdout,"site ",site:2,"  value ",temp_value[site],
//                                "  ",temp_value[site]:s_hex);
//                  }   /*if v_pf_status*/
//               }   /*if v_dev_active*/
//            }   /*for site*/
//         }   /*not X64*/
//      }   /*if not tmpbool*/
//      
//      failresetmax;
//      Disable(S_Fail_Memory);
//      ret_val =  temp_value;
//   } 
#endif

// ????
//   if(GL_DO_SOURCE_WITH_SCRAM)  
//      SetupSelect(prevDCSU,norm_fmsu);

   if(tistdscreenprint and debugprint)  
      IO.Print(IO.Stdout," GetRamContentDec_16bit TT : %e",TIME.StopTimer());
}    /*GetRamContentDec_16bit*/



//void IntToBCD_BinStr(    IntM intdata,
//                              StringM bcdStr,
//                              StringM binStr,
//                              BoolS hexvalue)
//{
//   StringS tmpstr1,tmpstr2;
//   IntS site;
//   IntS length;
//   IntS index;
//
//   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//   {
//      if(v_dev_active[site])  
//      {
//         if(hexvalue)  
//            writestring(tmpstr1,intdata[site]:s_hex:1);
//         else
//            writestring(tmpstr1,intdata[site]:-1);
//         length = len(tmpstr1);
//          /*extract string w/o 0x prefix and prepend 0s as needed*/
//         if(hexvalue)  
//            Writestring(tmpstr1,mid(tmpstr1,3,length-2));
//
//         length = len(tmpstr1);
//         if(length>4)  
//         {
//            tmpstr2 = mid(tmpstr1,length-3,4);
//            tmpstr1 = tmpstr2;
//            length  = len(tmpstr1);
//         } 
//         switch(length) {
//           case 1 : tmpstr1 = "000" + tmpstr1;
//           case 2 : tmpstr1 = "00" + tmpstr1;
//           case 3 : tmpstr1 = "0" + tmpstr1;
//         }   /* case */
//         bcdStr[site] = tmpstr1;
//
//         if(TI_FlashDebug and tistdscreenprint and tiprintpass)  
//            cout << "Site " << site:5 << "  indata decimal == " << 
//                    intdata[site]:7 << " hex == " <<  intdata[site]:s_hex << 
//                    "  bcd str == " << bcdstr[site] << endl;
//
//         length = len(tmpstr1);
//         tmpstr2 = "";
//         for (index = 1;index <= length;index++)
//            switch(tmpstr1[index]) {
//              case "0" : tmpstr2 = tmpstr2 + "0000";
//              case "1" : tmpstr2 = tmpstr2 + "0001";
//              case "2" : tmpstr2 = tmpstr2 + "0010";
//              case "3" : tmpstr2 = tmpstr2 + "0011";
//              case "4" : tmpstr2 = tmpstr2 + "0100";
//              case "5" : tmpstr2 = tmpstr2 + "0101";
//              case "6" : tmpstr2 = tmpstr2 + "0110";
//              case "7" : tmpstr2 = tmpstr2 + "0111";
//              case "8" : tmpstr2 = tmpstr2 + "1000";
//              case "9" : tmpstr2 = tmpstr2 + "1001";
//              case  "A": case "a" :  tmpstr2 = tmpstr2 + "1010";
//              case  "B": case "b" :  tmpstr2 = tmpstr2 + "1011";
//              case  "C": case "c" :  tmpstr2 = tmpstr2 + "1100";
//              case  "D": case "d" :  tmpstr2 = tmpstr2 + "1101";
//              case  "E": case "e" :  tmpstr2 = tmpstr2 + "1110";
//              case  "F": case "f" :  tmpstr2 = tmpstr2 + "1111";
//            }   /* case */
//         binStr[site] = tmpstr2;
//      }
//      else
//      {
//         bcdStr[site] = "XXXX";
//         binStr[site] = "XXXXXXXXXXXXXXXX";
//      } 
//   } 
//}   /*IntToBCD_BinStr*/


 /*unified all platforms to use cpu byte address for addr_loc*/
 /*src_data1 is lsword, src_data2 is msword*/
 /*bcd_format=true if want to write src_data1/data2 in bcd format*/
 /*bcd_format=false then write src_data1/data2 int value in binary string format*/
void WriteRamContentDec_32Bit(IntS addr_loc,
                                   IntM src_data1,
                                   BoolS data1_hexvalue,
                                   IntM src_data2,
                                   BoolS data2_hexvalue,
                                   BoolS bcd_format)
{
   IntS offsetcyc;
   StringS addr_str;
   StringS tpatt = "ramwrite_burst_addr_v4p0_Thrd"; //"ramwrite_burst_addr_Thrd";
   StringM bcd_vlsi_str1,bcd_vlsi_str2;
   StringM bin_vlsi_str1,bin_vlsi_str2;
   PinML data_pins;
   StringML SourceArr, SourceArrLo, SourceArrHi;
   IntS maxiter, length;
   IntS eindex, evenodd;
   IntS shiftbit,physaddr;
   StringS str1;
   StringM mstr;

   if(tistdscreenprint and TI_FlashDebug)  
      TIME.StartTimer();
   
   offsetcyc = 0;

#if $GL_USE_JTAG_RAMPMT or $GL_USE_DMLED_RAMPMT  
#if $GL_USE_JTAG_RAMPMT  
// :TODO: Fix this. Unneeded for Blizzard
//    /*-------- use JTAG --------*/
//    /*lsb 1st - msb last*/
//   data_pins = JTAG_DIN;
//   maxiter = 15;
//   maskbit = 0x1;
//   maxsrccount = 48;
//   eindex = 16;
//   mindex = 17;
//   hindex = 33;
//   length = 1;
//
//   IntToBinStr(addr_loc,addr_str);
//   
//   if(bcd_format)  
//   {
//      IntToBCD_BinStr(src_data1,bcdstr1,binstr1,data1_hexvalue);
//      IntToBCD_BinStr(src_data2,bcdstr2,binstr2,data2_hexvalue);
//
//      if(GL_DO_SOURCE_WITH_SCRAM)  
//      {
//         SaveMemsetBistData = V_MemSetBistData;
//         V_MemSetBistData = false;
//
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               for (offsetcyc = 0;offsetcyc <= maxiter;offsetcyc++)
//               {
//                  SourceArr[site][offsetcyc+1]      = (addr_loc & (maskbit << offsetcyc)) >> offsetcyc;
//                  SourceArr[site][offsetcyc+mindex] = (src_data1[site] & (maskbit << offsetcyc)) >> offsetcyc;
//                  SourceArr[site][offsetcyc+hindex] = (src_data2[site] & (maskbit << offsetcyc)) >> offsetcyc;
//               } 
//            } 
//         PatternDigitalSource(tpatt, data_pins, maxsrccount, true, SourceArr);
//         V_MemSetBistData = SaveMemsetBistData;
//      }
//      else
//      {
//         if(sameness)  
//         {
//            bcd_binstr1 = binstr1[active_site];
//            bcd_binstr2 = binstr2[active_site];
//
//            for (offsetcyc = 0;offsetcyc <= maxiter;offsetcyc++)
//            {
//               Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,data_pins,S_binary,
//                                      Mid(addr_str,eindex-offsetcyc,length));
//               Patternlabelsetpindata(tpatt,"MOD_DATA",offsetcyc,data_pins,S_binary,
//                                      Mid(bcd_binstr1,eindex-offsetcyc,length));
//               Patternlabelsetpindata(tpatt,"MOD_DATA",offsetcyc+maxiter+1,data_pins,S_binary,
//                                      Mid(bcd_binstr2,eindex-offsetcyc,length));
//            } 
//            PatternExecute(tmpint,tpatt);
//         }
//         else   /*not same data*/
//         {
//            devsetholdstates(alldisable);
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            {
//               if(savesites[site])  
//               {
//                  devsetholdstate(site,true);
//                  bcd_binstr1 = binstr1[site];
//                  bcd_binstr2 = binstr2[site];
//                  for (offsetcyc = 0;offsetcyc <= maxiter;offsetcyc++)
//                  {
//                     Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,data_pins,S_binary,
//                                            Mid(addr_str,eindex-offsetcyc,length));
//                     Patternlabelsetpindata(tpatt,"MOD_DATA",offsetcyc,data_pins,S_binary,
//                                            Mid(bcd_binstr1,eindex-offsetcyc,length));
//                     Patternlabelsetpindata(tpatt,"MOD_DATA",offsetcyc+maxiter+1,data_pins,S_binary,
//                                            Mid(bcd_binstr2,eindex-offsetcyc,length));
//                  } 
//                  PatternExecute(tmpint,tpatt);
//                  devsetholdstate(site,false);
//               } 
//            }   /*for site*/
//            devsetholdstates(savesites);
//         }   /*not same data*/
//      }   /*not go_do_source_with_scram*/
//   }   /*if bcd_format*/
//    /*-------- end of JTAG --------*/
#else
    /*-------- use DMLED --------*/
   data_pins = "DMLED_INBUS";
   maxiter = 3;
   eindex = 12;
   length = 4;

   if(bcd_format)  
   {
      IntMToBcdBinVlsiStrM(src_data1, bcd_vlsi_str1, bin_vlsi_str1, data1_hexvalue);
      IntMToBcdBinVlsiStrM(src_data2, bcd_vlsi_str2, bin_vlsi_str2, data2_hexvalue);

      physaddr = addr_loc>>3;
   
       /*control word*/
      evenodd = (addr_loc>>2) & 0x1;  /*0=even or ram1, 1=odd or ram2*/

      addr_str = IntToVLSIDriveStr(physaddr, 16, true);
       /*address*/
      for (offsetcyc = 0;offsetcyc <= 15;offsetcyc++)
      {
         str1 = "LLL" + addr_str.Substring(15-offsetcyc, 1);
         SourceArr += str1;
      } 
      StringS patname = PatternBurst(tpatt).GetPattern(0).GetName();
      StringS label = patname + ".MOD_ADDR";
      DIGITAL.ModifyVectors(data_pins, tpatt, label, SourceArr);
      
      str1 = IntToVLSIDriveStr(evenodd, 4, true);
      SourceArr.Erase();
      SourceArr += str1;
       /*control word*/
      DIGITAL.ModifyVectors(data_pins, tpatt, label, 36, SourceArr, "L");

       /*data*/
      for (offsetcyc = 0;offsetcyc <= maxiter;offsetcyc++)
      {
         shiftbit = length*offsetcyc;
         mstr = bin_vlsi_str1.Substring(eindex-shiftbit, length);
         SourceArrLo += mstr;
         mstr = bin_vlsi_str2.Substring(eindex-shiftbit, length);
         SourceArrHi += mstr;
      }
      SourceArr = SourceArrLo;
      SourceArr += SourceArrHi;
      
      label = patname + ".MOD_DATA";
      DIGITAL.ModifyVectors(data_pins, tpatt, label, SourceArr);
      
      DIGITAL.ExecutePattern(tpatt);
      
   }   /*if bcd_format*/
    /*-------- end of DMLED --------*/
#endif
#else   
// :TODO: Fix this. Unneeded for Blizzard.
//   IntToBinStr(addr_loc>>2,addr_str);
//   if(bcd_format)  
//   {
//      IntToBCD_BinStr(src_data1,bcdstr1,binstr1,data1_hexvalue);
//      IntToBCD_BinStr(src_data2,bcdstr2,binstr2,data2_hexvalue);
//
//      if(sameness)  
//      {
//         bcd_binstr1 = binstr1[active_site];
//         bcd_binstr2 = binstr2[active_site];
//            
//         if(GL_USE_RAMPMT_X64)  
//         {
//            for (offsetcyc = 0;offsetcyc <= 3;offsetcyc++)
//            {
//               Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,
//                                      PMT_RAMBUS,S_binary,
//                                      Mid(addr_str,13-(4*offsetcyc),4));                                         
//               Patternlabelsetpindata(tpatt,"MOD_DATA",offsetcyc,
//                                      PMT_RAMBUS,S_binary,
//                                      Mid(bcd_binstr1,13-(4*offsetcyc),4));
//               Patternlabelsetpindata(tpatt,"MOD_DATA",offsetcyc+4,
//                                      PMT_RAMBUS,S_binary,
//                                      Mid(bcd_binstr2,13-(4*offsetcyc),4));
//            } 
//         }
//         else
//         {
//            Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,
//                                   PMT_RAMBUS,S_binary,addr_str);
//            Patternlabelsetpindata(tpatt,"MOD_DATA",offsetcyc,
//                                   PMT_RAMBUS,S_binary,bcd_binstr1);
//            Patternlabelsetpindata(tpatt,"MOD_DATA",offsetcyc+1,
//                                   PMT_RAMBUS,S_binary,bcd_binstr2);
//         } 
//         
//         PatternExecute(tmpint,tpatt);
//      }
//      else   /*not same data*/
//      {
//         devsetholdstates(alldisable);
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         {
//            if(savesites[site])  
//            {
//               devsetholdstate(site,true);
//               bcd_binstr1 = binstr1[site];
//               bcd_binstr2 = binstr2[site];
//               
//               if(GL_USE_RAMPMT_X64)  
//               {
//                  for (offsetcyc = 0;offsetcyc <= 3;offsetcyc++)
//                  {
//                     Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,
//                                            PMT_RAMBUS,S_binary,
//                                            Mid(addr_str,13-(4*offsetcyc),4));                                         
//                     Patternlabelsetpindata(tpatt,"MOD_DATA",offsetcyc,
//                                            PMT_RAMBUS,S_binary,
//                                            Mid(bcd_binstr1,13-(4*offsetcyc),4));
//                     Patternlabelsetpindata(tpatt,"MOD_DATA",offsetcyc+4,
//                                            PMT_RAMBUS,S_binary,
//                                            Mid(bcd_binstr2,13-(4*offsetcyc),4));
//                  } 
//               }
//               else
//               {
//                  Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,
//                                         PMT_RAMBUS,S_binary,addr_str);
//                  Patternlabelsetpindata(tpatt,"MOD_DATA",offsetcyc,
//                                         PMT_RAMBUS,S_binary,bcd_binstr1);
//                  Patternlabelsetpindata(tpatt,"MOD_DATA",offsetcyc+1,
//                                         PMT_RAMBUS,S_binary,bcd_binstr2);
//               } 
//               
//               PatternExecute(tmpint,tpatt);
//               devsetholdstate(site,false);
//            } 
//         }   /*for site*/
//         devsetholdstates(savesites);
//      }   /*not same data*/
//   }
//   else
//   {
//      Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,
//                             PMT_RAMBUS,S_binary,addr_str);
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//            break;
//      IntToBinStr(src_data1[site],data_str1);
//      IntToBinStr(src_data2[site],data_str2);
//      Patternlabelsetpindata(tpatt,"MOD_DATA",offsetcyc,
//                             PMT_RAMBUS,S_binary,data_str1);
//      Patternlabelsetpindata(tpatt,"MOD_DATA",offsetcyc+1,
//                             PMT_RAMBUS,S_binary,data_str2);
//      PatternExecute(tmpint,tpatt);
//   } 
#endif

//   if(GL_DO_SOURCE_WITH_SCRAM)  
//      SetupSelect(prevDCSU,norm_fmsu);
   
   if(tistdscreenprint and TI_FlashDebug)  
      cout << "WriteRamContentDec_32bit TT " << TIME.StopTimer() << endl;
}    /*WriteRamContentDec_32bit*/



 /*unified all platforms to use cpu byte address for start_addr*/
 /*reading 136 or 4096 16bit words from pmt starting address using scram*/
 /*store contents into global array vars by store_option input param*/
 /*store_option :  0=FL_TEMPLOG_ARR, 1=FL_TESTLOG_ARR, 2=FL_MBOX_OTP_ARR, 3=FL_SCRAM_CAPT_ARR*/
 /*with msw,lsw -- eg: FL_TEMPLOG_ARR[1]=msw, FL_TEMPLOG_ARR[2]=lsw*/
 /*x64 pmt pattern output as: nibble0, nib1, nib2, nib3 (lsw), nib0,nib1,nib2,nib3 (msw)*/
void GetRamContent_SCRAM(IntS start_addr,
                              IntS store_option)
{
   const IntS X16MAXCNT = 136; 
   const IntS X64MAXCNT = 544; 
   const IntS X16MAXCNT_MBOX = 4096; 
   const IntS X64MAXCNT_MBOX = 16384; 
   const IntS TEMPLOG_OPT = 0; 
   const IntS TESTLOG_OPT = 1; 
   const IntS OTPLOG_OPT = 3; 
   const IntS MBOXLOG_OPT = 4; 
   const IntS JTAGMAXCNT_MBOX = 65536; 

   UnsignedS halfcapcount, maxcapcount;
   UnsignedS istep, count;
   IntS offsetcyc;
   UnsignedS index;
   UnsignedM tnib0,tnib1,tnib2,tnib3;
   UnsignedM tnib4,tnib5,tnib6,tnib7;
   StringS tpatt, addr_str, str2;
   PinML data_pins,data_in;

#if $GL_USE_JTAG_RAMPMT or $GL_USE_DMLED_RAMPMT
#if $GL_USE_JTAG_RAMPMT
// :TODO: Fix. Unneeded for Blizzard.
//   IntM1D SourceArr(16); 
//   IntM1D CaptureArr(JTAGMAXCNT_MBOX); 
#else
   StringML SourceArr; 
   UnsignedM1D EvenCaptureArr(X64MAXCNT_MBOX),OddCaptureArr(X64MAXCNT_MBOX); 
   UnsignedM1D sim_value(X64MAXCNT_MBOX, 0);
   IntS physaddr, curraddr;
   IntS1D evenodd(3);
#endif
#else
// :TODO: Fix. Unneeded for Blizzard.
//   IntM1D SourceArr(4); 
//   IntM1D CaptureArr(X64MAXCNT_MBOX); 
#endif

   if(tistdscreenprint and TI_FlashDebug and tiprintpass)
      TIME.StartTimer();


    /*if(store_option <= (ord(TESTLOG_ARR))) then
       tpatt := ramread_tlog_scram
    else if(store_option = (ord(MBOXOTP_ARR))) then
       tpatt := ramread_tlog_mbox_scram
    else}  {blizzard specific*/
      tpatt = "ramread_mbox_v4p0_Thrd"; //"ramread_mbox_Thrd";

#if $GL_USE_JTAG_RAMPMT or $GL_USE_DMLED_RAMPMT  
#if $GL_USE_JTAG_RAMPMT  
// :TODO: Fix. Unneeded for Blizzard.
// /*-------- use JTAG --------*/
//   data_pins = JTAG_DOUT;
//   data_in   = JTAG_DIN;
//   
//   if(store_option < (ord(MBOXLOG_ARR)))  
//      maxcapcount = X16MAXCNT*16;
//   else
//      maxcapcount = JTAGMAXCNT_MBOX;
//   istep = 32;   /*2 16bit word*/
//   maxsrccount = 16;
//
//   curraddr = start_addr;
//   IntToBinStr(curraddr,addr_str);
//   
//   if(GL_DO_SOURCE_WITH_SCRAM)  
//   {
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      {
//         for (offsetcyc = 0;offsetcyc <= 15;offsetcyc++)
//         {
//            SourceArr[site][offsetcyc+1] = ((curraddr & (0x1<<offsetcyc)) >> offsetcyc) & 0x1;
//             /*
//             if(TIStdScreenPrint and TI_FlashDebug) then
//                writeln(tiwindow,"SourceArr[ ",(offsetcyc+1):-2,"] = ",SourceArr[site,offsetcyc+1]:s_hex);
//             */
//         } 
//         break;
//      } 
//      PatternDigitalSourceCapture(tpatt,data_in,data_pins,maxsrccount,maxcapcount,
//                                  false, SourceArr,CaptureArr)
//   }
//   else
//   {
//      for (offsetcyc = 0;offsetcyc <= 15;offsetcyc++)
//         Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,
//                                data_in,S_binary,
//                                Mid(addr_str,16-(1*offsetcyc),1));
//      PatternDigitalCapture(tpatt,data_pins,maxcapcount, CaptureArr);
//   } 
//   
//   index = 1;
//   for count = 1 to maxcapcount by istep do
//   {
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            tnib0 = 0;
//            tnib1 = 0;
//            for (i = 0;i <= 15;i++)
//            {
//               tnib0 = tnib0 +  (CaptureArr[site][count+i] << i);
//               tnib1 = tnib1 +  (CaptureArr[site][count+16+i] << i);
//            } 
//            FL_SCRAM_CAPT_ARR[index+1][site] = tnib0;  /*lsw*/
//            FL_SCRAM_CAPT_ARR[index][site]   = tnib1;  /*msw*/
//         }   /*if v_dev_active*/
//      index = index+2;
//   }   /*for count*/
// /*-------- end of JTAG --------*/
#else
 /*-------- use DMLED --------*/
   data_pins = "DMLED_OUTBUS";
   data_in   = "DMLED_INBUS";
   istep = 8;   /*8 nibbles or 2 16bit word*/
   
   if(store_option < (int(MBOXLOG_ARR)))  
      maxcapcount = X64MAXCNT;
   else
      maxcapcount = X64MAXCNT_MBOX;

   halfcapcount = maxcapcount / 2;

   curraddr = start_addr>>2;
   
   if((curraddr&0x1)==0)  
   {
      evenodd[1] = 0;  /*even*/
      evenodd[2] = 1;  /*odd*/
   }
   else
   {
      evenodd[1] = 1;
      evenodd[2] = 0;
   } 

    /*dmled physical addr*/
   physaddr = curraddr>>1;


   StringS label = PatternBurst(tpatt).GetPattern(0).GetName() + ".MOD_ADDR";
    /*read even/odd*/
   for (int i = 1;i <= 2;++i)
   {
      addr_str = IntToVLSIDriveStr(physaddr, 16, true);
      StringML SourceArr;
      for (offsetcyc = 0;offsetcyc <= 15;offsetcyc++)
      {
         str2 = "LLL" + addr_str.Substring(15-offsetcyc, 1);
         SourceArr += str2;
      } 
      DIGITAL.ModifyVectors(data_in, tpatt, label, SourceArr);
      
      str2 = IntToVLSIDriveStr(evenodd[i], 4, true);
      SourceArr.Erase();
      SourceArr += str2;
      DIGITAL.ModifyVectors(data_in, tpatt, label, 36, SourceArr, "L");
      
      if(i==1)  
         PatternDigitalCapture(tpatt,data_pins,"CapRam32",halfcapcount,EvenCaptureArr,sim_value);
      else
         PatternDigitalCapture(tpatt,data_pins,"CapRam32",halfcapcount,OddCaptureArr,sim_value);
   }   /*for i*/
   
    /*captureArr has index as [0]=lsw,[1]=msw so need to reverse to [0]=msw,[1]=lsw*/
   index = 0;
   for (count = 0; count < halfcapcount; count+=istep)
   {
      tnib0 = EvenCaptureArr[count];    /*ls nibble*/
      tnib1 = EvenCaptureArr[count+1]<<4;
      tnib2 = EvenCaptureArr[count+2]<<8;
      tnib3 = EvenCaptureArr[count+3]<<12;  /*ms nibble*/
      tnib4 = EvenCaptureArr[count+4];    /*ls nibble*/
      tnib5 = EvenCaptureArr[count+5]<<4;
      tnib6 = EvenCaptureArr[count+6]<<8;
      tnib7 = EvenCaptureArr[count+7]<<12;  /*ms nibble*/
      FL_SCRAM_CAPT_ARR.SetValue(index+1, tnib3+tnib2+tnib1+tnib0); /*lsw*/
      FL_SCRAM_CAPT_ARR.SetValue(index, tnib7+tnib6+tnib5+tnib4);  /*msw*/
      tnib0 = OddCaptureArr[count];    /*ls nibble*/
      tnib1 = OddCaptureArr[count+1]<<4;
      tnib2 = OddCaptureArr[count+2]<<8;
      tnib3 = OddCaptureArr[count+3]<<12;  /*ms nibble*/
      tnib4 = OddCaptureArr[count+4];    /*ls nibble*/
      tnib5 = OddCaptureArr[count+5]<<4;
      tnib6 = OddCaptureArr[count+6]<<8;
      tnib7 = OddCaptureArr[count+7]<<12;  /*ms nibble*/
      FL_SCRAM_CAPT_ARR.SetValue(index+3, tnib3+tnib2+tnib1+tnib0);  /*lsw*/
      FL_SCRAM_CAPT_ARR.SetValue(index+2, tnib7+tnib6+tnib5+tnib4);  /*msw*/
      index += 4;
   }   /*for count*/
 /*-------- end of DMLED --------*/
#endif      
#else
// :TODO: Fix this. Unneeded for Blizzard.
//   if(GL_USE_RAMPMT_X64)  
//   {
//      if(store_option < (int(MBOXLOG_ARR)))  
//         maxcapcount = X64MAXCNT;
//      else
//         maxcapcount = X64MAXCNT_MBOX;
//      istep = 8;   /*8 nibbles or 2 16bit word*/
//      maxsrccount = 4;
//   }
//   else
//   {
//      if(store_option < (int(MBOXLOG_ARR)))  
//         maxcapcount = X16MAXCNT;
//      else
//         maxcapcount = X16MAXCNT_MBOX;
//      istep = 2;
//      maxsrccount = 1;
//   } 
//
//   data_pins = PMT_RAMBUS;
//   data_in = PMT_RAMBUS;
//   curraddr = start_addr>>2;
//   IntToBinStr(curraddr,addr_str);
//
//   if(GL_USE_RAMPMT_X64)  
//   {
//      if(GL_DO_SOURCE_WITH_SCRAM)  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               for (offsetcyc = 0;offsetcyc <= 3;offsetcyc++)
//               {
//                  SourceArr[site][offsetcyc+1] = (curraddr & ((0xf)<<(4*offsetcyc))) >> (4*offsetcyc);
//                   /*
//                    if(TIStdScreenPrint and TI_FlashDebug) then
//                    writeln(tiwindow,"SourceArr[ ",(offsetcyc+1):-2,"] = ",SourceArr[site,offsetcyc+1]:s_hex);
//                    */
//               } 
//            } 
//      }
//      else
//      {
//         for (offsetcyc = 0;offsetcyc <= 3;offsetcyc++) //:NOTE: THIS SHOULD BE offsetcyc = 0 downto 3?? how is it downto 3???
//            Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,
//                                   data_pins,S_binary,
//                                   Mid(addr_str,13-(4*offsetcyc),4));
//      } 
//   }
//   else
//   {
//      offsetcyc = 0;
//      if(GL_DO_SOURCE_WITH_SCRAM)  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               SourceArr[site][offsetcyc+1] = curraddr;
//                /*
//                 if(TIStdScreenPrint and TI_FlashDebug) then
//                 writeln(tiwindow,"SourceArr[ ",(offsetcyc+1):-2,"] = ",SourceArr[site,offsetcyc+1]:s_hex);
//                 */
//            } 
//      }
//      else
//      {
//          /*Patternlabelsetpindata(tpatt,"MOD_ADDR",offsetcyc,
//                                 data_pins,S_binary,addr_str);} {KChau - using hardcoded address in pattern for now*/
//      } 
//   } 
//   
//   if(GL_DO_SOURCE_WITH_SCRAM)  
//      PatternDigitalSourceCapture(tpatt, data_pins, data_pins, maxsrccount, maxcapcount, false, SourceArr,CaptureArr);
//   else
//      PatternDigitalCapture(tpatt, data_pins, maxcapcount,CaptureArr);
//      
//
//    /*captureArr has index as [0]=lsw,[1]=msw so need to reverse to [0]=msw,[1]=lsw*/
//   if(GL_USE_RAMPMT_X64)  
//   {
//      index = 1;
//      for count = 1 to maxcapcount by istep do
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               tnib0 = CaptureArr[site][count];    /*ls nibble*/
//               tnib1 = CaptureArr[site][count+1]<<4;
//               tnib2 = CaptureArr[site][count+2]<<8;
//               tnib3 = CaptureArr[site][count+3]<<12;  /*ms nibble*/
//               tnib4 = CaptureArr[site][count+4];    /*ls nibble*/
//               tnib5 = CaptureArr[site][count+5]<<4;
//               tnib6 = CaptureArr[site][count+6]<<8;
//               tnib7 = CaptureArr[site][count+7]<<12;  /*ms nibble*/
//               FL_SCRAM_CAPT_ARR[index+1][site] = tnib3+tnib2+tnib1+tnib0;  /*lsw*/
//               FL_SCRAM_CAPT_ARR[index][site]   = tnib7+tnib6+tnib5+tnib4;  /*msw*/
//            }   /*if v_dev_active*/
//         index = index+2;
//      }   /*for count*/
//   }
//   else
//   {
//      for count = 1 to maxcapcount by istep do
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               FL_SCRAM_CAPT_ARR[count][site] = CaptureArr[site][count+1];   /*msw*/
//               FL_SCRAM_CAPT_ARR[count+1][site] = CaptureArr[site][count];   /*lsw*/
//            }   /*if v_dev_active*/
//   } 
//   
#endif

    /*store in global var arr*/
   if(store_option == (int(TESTLOG_ARR)))  
   {
      index = X16MAXCNT;
      for (count = 0; count < index ;count++)
         FL_TESTLOG_ARR.SetValue(count, FL_SCRAM_CAPT_ARR[count]);
   } 
   
   if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
   {
      IntS addr = start_addr;
      cout << "Contents from starting cpu address " << hex << addr << endl;
//      PrintHeaderBool(GL_PLELL_FORMAT);
      
      if(store_option< (int(MBOXLOG_ARR)))  
         index = X16MAXCNT;
      else
         index = X16MAXCNT_MBOX;
      
      UnsignedM tdata;
      for (count = 0; count < index; count+=2)
      {
         tdata = FL_SCRAM_CAPT_ARR[count] * 0x10000 + FL_SCRAM_CAPT_ARR[count+1];
         // PrintResultIntHex(str1,0,tdata,0,0,GL_PLELL_FORMAT);
         // for now, just print it like this...make it like function above later, if needed
         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
            cout << "Address 0x" << addr << " Site " << *si << " Data 0x" << tdata[*si] << endl;
         addr = addr+ADDR_RAM_INC;
      }   /*for count*/
      cout << dec; 
   } 
   
   if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
      cout << " GetRamContent_SCRAM TT : " << TIME.StopTimer() << endl;
   
}   /* GetRamContent_SCRAM */
   

 /*from cpu addr 0x00 to 0xff -- 128 16bit words*/
void Get_Flash_TestLogSpace_SCRAM()
{
   IntS addr,store_option;

   if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
      cout << "*** Get_Flash_TestLogSpace_SCRAM ***" << endl;
   addr = 0x0;
   store_option = int(TESTLOG_ARR);   /*store contents in FL_TESTLOG_ARR*/
   GetRamContent_SCRAM(addr,store_option);
}   /* Get_Flash_TestLogSpace_SCRAM */


//void Get_TLogSpace_STAT1(    IntM msw_data,
//                              IntM lsw_data)
//{
//   const IntS X16_IND_STAT1_MSW = 57; 
//   const IntS X16_IND_STAT1_LSW = 58; 
//
//   IntS addr_loc,site;
//   IntM msw_val,lsw_val;
//   StringS str1;
//
//   if(v_any_dev_active)  
//   {
//      if(GL_DO_ESDA_WITH_SCRAM)  
//      {
//         msw_val = FL_TESTLOG_ARR[X16_IND_STAT1_MSW];
//         lsw_val = FL_TESTLOG_ARR[X16_IND_STAT1_LSW];
//      }
//      else
//      {
//         addr_loc = ADDR_API_STAT1;
//         GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_val);
//         GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_val);
//      } 
//
//      msw_data = msw_val;
//      lsw_data = lsw_val;
//
//      if(tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT)  
//      {
//         str1 = "FL_STAT1_MSW";
//          /*PrintHeaderBool(GL_PLELL_FORMAT);*/
//         PrintResultIntHex(str1,0,msw_val,0,0,GL_PLELL_FORMAT);
//         str1 = "FL_STAT1_LSW";
//         PrintResultIntHex(str1,0,lsw_val,0,0,GL_PLELL_FORMAT);
//      } 
//   } 
//}   /* Get_TLogSpace_STAT1 */
//
//void Get_TLogSpace_STAT2(    IntM msw_data,
//                              IntM lsw_data)
//{
//   const IntS X16_IND_STAT2_MSW = 59; 
//   const IntS X16_IND_STAT2_LSW = 60; 
//
//   IntS addr_loc,site;
//   IntM msw_val,lsw_val;
//   StringS str1;
//
//   if(v_any_dev_active)  
//   {
//      if(GL_DO_ESDA_WITH_SCRAM)  
//      {
//         msw_val = FL_TESTLOG_ARR[X16_IND_STAT2_MSW];
//         lsw_val = FL_TESTLOG_ARR[X16_IND_STAT2_LSW];
//      }
//      else
//      {
//         addr_loc = ADDR_API_STAT2;
//         GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_val);
//         GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_val);
//      } 
//
//      msw_data = msw_val;
//      lsw_data = lsw_val;
//
//      if(tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT)  
//      {
//         str1 = "FL_STAT2_MSW";
//          /*PrintHeaderBool(GL_PLELL_FORMAT);*/
//         PrintResultIntHex(str1,0,msw_val,0,0,GL_PLELL_FORMAT);
//         str1 = "FL_STAT2_LSW";
//         PrintResultIntHex(str1,0,lsw_val,0,0,GL_PLELL_FORMAT);
//      } 
//   } 
//}   /* Get_TLogSpace_STAT2 */
//
//void Get_TLogSpace_STAT3(    IntM msw_data,
//                              IntM lsw_data)
//{
//   const IntS X16_IND_STAT3_MSW = 61; 
//   const IntS X16_IND_STAT3_LSW = 62; 
//
//   IntS addr_loc,site;
//   IntM msw_val,lsw_val;
//   StringS str1;
//
//   if(v_any_dev_active)  
//   {
//      if(GL_DO_ESDA_WITH_SCRAM)  
//      {
//         msw_val = FL_TESTLOG_ARR[X16_IND_STAT3_MSW];
//         lsw_val = FL_TESTLOG_ARR[X16_IND_STAT3_LSW];
//      }
//      else
//      {
//         addr_loc = ADDR_API_STAT3;
//         GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_val);
//         GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_val);
//      } 
//
//      msw_data = msw_val;
//      lsw_data = lsw_val;
//
//      if(tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT)  
//      {
//         str1 = "FL_STAT3_MSW";
//          /*PrintHeaderBool(GL_PLELL_FORMAT);*/
//         PrintResultIntHex(str1,0,msw_val,0,0,GL_PLELL_FORMAT);
//         str1 = "FL_STAT3_LSW";
//         PrintResultIntHex(str1,0,lsw_val,0,0,GL_PLELL_FORMAT);
//      } 
//   } 
//}   /* Get_TLogSpace_STAT3 */
//
//void Get_TLogSpace_STAT4(    IntM msw_data,
//                              IntM lsw_data)
//{
//   const IntS X16_IND_STAT4_MSW = 63; 
//   const IntS X16_IND_STAT4_LSW = 64; 
//
//   IntS addr_loc,site;
//   IntM msw_val,lsw_val;
//   StringS str1;
//
//   if(v_any_dev_active)  
//   {
//      if(GL_DO_ESDA_WITH_SCRAM)  
//      {
//         msw_val = FL_TESTLOG_ARR[X16_IND_STAT4_MSW];
//         lsw_val = FL_TESTLOG_ARR[X16_IND_STAT4_LSW];
//      }
//      else
//      {
//         addr_loc = ADDR_API_STAT4;
//         GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_val);
//         GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_val);
//      } 
//
//      msw_data = msw_val;
//      lsw_data = lsw_val;
//
//      if(tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT)  
//      {
//         str1 = "FL_STAT4_MSW";
//          /*PrintHeaderBool(GL_PLELL_FORMAT);*/
//         PrintResultIntHex(str1,0,msw_val,0,0,GL_PLELL_FORMAT);
//         str1 = "FL_STAT4_LSW";
//         PrintResultIntHex(str1,0,lsw_val,0,0,GL_PLELL_FORMAT);
//      } 
//   } 
//}   /* Get_TLogSpace_STAT4 */
//
//void Get_TLogSpace_TESTFREQ(    IntM ret_val)
//{
//   const IntS X16_IND_TESTFREQ = 65; 
//
//   IntS site,addr;
//   IntM tdata;
//   StringS str1;
//
//   if(v_any_dev_active)  
//   {
//      tdata = 0;
//
//      if(GL_DO_ESDA_WITH_SCRAM)  
//      {
//         tdata = FL_TESTLOG_ARR[X16_IND_TESTFREQ];
//      }
//      else
//      {
//         addr = ADDR_TESTFREQ;
//         GetRamContentDec_16bit(ramread_nburst_lsw,addr,tdata);
//      } 
//
//      ret_val = tdata;
//
//      if(tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT)  
//      {
//         str1 = "FL_TESTFREQ";
//          /*PrintHeaderBool(GL_PLELL_FORMAT);*/
//         PrintResultIntHex(str1,0,tdata,0,0,GL_PLELL_FORMAT);
//      } 
//   } 
//}   /* Get_TLogSpace_TESTFREQ */

void Get_TLogSpace_PFBin(IntM &ret_val) {
   const IntS X16_IND_PF_BIN = 66; 

   IntS site,addr;
   IntM tdata;
   StringS str1;

   tdata = 0;

   tdata = FL_TESTLOG_ARR[X16_IND_PF_BIN];

   ret_val = tdata;

   if(tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT)  
   {
      cout << "FL_PFBIN 0x" << hex << tdata << dec << endl;
   } 
}   /* Get_TLogSpace_PFBin */

void Get_TLogSpace_FailAddr(IntM msw_data, IntM lsw_data) {
   const IntS X16_IND_FADDR_MSW = 67; 
   const IntS X16_IND_FADDR_LSW = 68; 

   IntS addr_loc,site;
   IntM msw_val,lsw_val;
   StringS str1;

//   if(GL_DO_ESDA_WITH_SCRAM) {
   if (0) {
      msw_val = FL_TESTLOG_ARR[X16_IND_FADDR_MSW];
      lsw_val = FL_TESTLOG_ARR[X16_IND_FADDR_LSW];
   }
   else {
      addr_loc = ADDR_FAIL_ADDR;
      GetRamContentDec_16Bit("ramread_nburst_lsw",addr_loc,lsw_val);
      GetRamContentDec_16Bit("ramread_nburst_msw",addr_loc,msw_val);
   } 

   msw_data = msw_val;
   lsw_data = lsw_val;

   if (tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT) {
      str1 = "FL_FAILADDR_MSW 0x";
       /*PrintHeaderBool(GL_PLELL_FORMAT);*/
      cout << str1 << hex << msw_data << endl;
//      PrintResultIntHex(str1,0,msw_val,0,0,GL_PLELL_FORMAT);
      str1 = "FL_FAILADDR_LSW 0x";
      cout << str1 << hex << lsw_data << endl; IO.Flush(IO.Stdout);
//      PrintResultIntHex(str1,0,lsw_val,0,0,GL_PLELL_FORMAT);
   } 
}   // Get_TLogSpace_FailAddr
   
void Get_TLogSpace_FailData(IntM msw_data, IntM lsw_data) {
   const IntS X16_IND_FDATA_MSW = 69; 
   const IntS X16_IND_FDATA_LSW = 70; 

   IntS addr_loc,site;
   IntM msw_val,lsw_val;
   StringS str1;

//   if(GL_DO_ESDA_WITH_SCRAM)
   if (0) {
      msw_val = FL_TESTLOG_ARR[X16_IND_FDATA_MSW];
      lsw_val = FL_TESTLOG_ARR[X16_IND_FDATA_LSW];
   }
   else {
      addr_loc = ADDR_FAIL_DATA;
      GetRamContentDec_16Bit("ramread_nburst_lsw",addr_loc,lsw_val);
      GetRamContentDec_16Bit("ramread_nburst_msw",addr_loc,msw_val);
   } 

   msw_data = msw_val;
   lsw_data = lsw_val;

   if (tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT) {
      str1 = "FL_FAILDATA_MSW 0x";
      cout << str1 << hex << lsw_data << endl;
       /*PrintHeaderBool(GL_PLELL_FORMAT);*/
//      PrintResultIntHex(str1,0,msw_val,0,0,GL_PLELL_FORMAT);
      str1 = "FL_FAILDATA_LSW 0x";
      cout << str1 << hex << lsw_data << endl; IO.Flush(IO.Stdout);
//      PrintResultIntHex(str1,0,lsw_val,0,0,GL_PLELL_FORMAT);
   } 
}   // Get_TLogSpace_FailData */
   
void Get_TLogSpace_TNUM(IntM &msw_data, IntM &lsw_data) {

   const IntS X16_IND_TNUM_MSW = 70;   // was 71
   const IntS X16_IND_TNUM_LSW = 71;   // was 72
   StringS str1;

   msw_data = FL_TESTLOG_ARR[X16_IND_TNUM_MSW];
   lsw_data = FL_TESTLOG_ARR[X16_IND_TNUM_LSW];

   if(tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT) {
      str1 = "FL_TNUM_MSW 0x";
      cout << str1 << hex << msw_data << endl;
      str1 = "FL_TNUM_LSW 0x";
      cout << str1 << hex << lsw_data << endl; IO.Flush(IO.Stdout);
   } 
}   // Get_TLogSpace_TNUM

//void Get_TLogSpace_MSTAT(      IntM msw_data, IntM lsw_data)
//{
//   const IntS X16_IND_MSTAT_MSW = 73; 
//   const IntS X16_IND_MSTAT_LSW = 74; 
//
//   IntS site,addr;
//   IntM msw_val,lsw_val;
//   StringS str1;
//
//   if(v_any_dev_active)  
//   {
//      if(GL_DO_ESDA_WITH_SCRAM)  
//      {
//         msw_val = FL_TESTLOG_ARR[X16_IND_MSTAT_MSW];
//         lsw_val = FL_TESTLOG_ARR[X16_IND_MSTAT_LSW];
//      }
//      else
//      {
//         addr = ADDR_MSTAT;
//         GetRamContentDec_16bit(ramread_nburst_msw,addr,msw_val);
//         GetRamContentDec_16bit(ramread_nburst_lsw,addr,lsw_val);
//      } 
//
//      msw_data = msw_val;
//      lsw_data = lsw_val;
//
//      if(tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT)  
//      {
//         str1 = "FL_MSTAT_MSW";
//         PrintResultIntHex(str1,0,msw_val,0,0,GL_PLELL_FORMAT);
//         str1 = "FL_MSTAT_LSW";
//         PrintResultIntHex(str1,0,lsw_val,0,0,GL_PLELL_FORMAT);
//      } 
//   } 
//}   /* Get_TLogSpace_MSTAT */
//   
//void Get_TLogSpace_ErsPulse(    IntM ret_val)
//{
//   const IntS X16_IND_ERS_PULSE = 75; 
//
//   IntS site,addr;
//   IntM tdata;
//   StringS str1;
//
//   if(v_any_dev_active)  
//   {
//      tdata = 0;
//
//      if(GL_DO_ESDA_WITH_SCRAM)  
//      {
//         tdata = FL_TESTLOG_ARR[X16_IND_ERS_PULSE];
//      }
//      else
//      {
//         addr = ADDR_ERS_PULSE;
//         GetRamContentDec_16bit(ramread_nburst_msw,addr,tdata);
//      } 
//
//      ret_val = tdata;
//
//      if(tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT)  
//      {
//         str1 = "FL_ERSPULSE";
//          /*PrintHeaderBool(GL_PLELL_FORMAT);*/
//         PrintResultIntHex(str1,0,tdata,0,0,GL_PLELL_FORMAT);
//      } 
//   } 
//}   /* Get_TLogSpace_MSTAT */
   
void Get_TLogSpace_ErsPulse(IntM ret_val) {
   
   const IntS X16_IND_ERS_PULSE = 75; 

   IntS site,addr;
   IntM tdata;
   StringS str1;

   tdata = 0;

 
   addr = ADDR_ERS_PULSE;
//   GetRamContentDec_16Bit("ramread_nburst_msw_Thrd",addr,tdata);
   GetRamContentDec_16Bit("ramread_nburst_msw_v4p0_Thrd",addr,tdata);

   ret_val = tdata;

   if (tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT) {
      str1 = "FL_ERSPULSE 0x";
      // PrintHeaderBool(GL_PLELL_FORMAT);
      // PrintResultIntHex(str1,0,tdata,0,0,GL_PLELL_FORMAT);
      cout << str1 << hex << ret_val << endl; IO.Flush(IO.Stdout);
   }  
}   // Get_TLogSpace_ErsPulse

//void Get_TLogSpace_TRIMSOL(    IntM ret_val)
//{
//   const IntS X16_IND_TRIMSOL = 83; 
//
//   IntS site,addr;
//   IntM tdata;
//   StringS str1;
//
//   if(v_any_dev_active)  
//   {
//      tdata = 0;
//
//      if(GL_DO_ESDA_WITH_SCRAM)  
//      {
//         tdata = FL_TESTLOG_ARR[X16_IND_TRIMSOL];
//      }
//      else
//      {
//         addr = ADDR_TRIMSOL;
//         GetRamContentDec_16bit(ramread_nburst_msw,addr,tdata);
//      } 
//
//      ret_val = tdata;
//
//      if(tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT)  
//      {
//         str1 = "FL_TRIMSOL";
//          /*PrintHeaderBool(GL_PLELL_FORMAT);*/
//         PrintResultIntHex(str1,0,tdata,0,0,GL_PLELL_FORMAT);
//      } 
//   } 
//}   /* Get_TLogSpace_TRIMSOL */
//   
void Get_TLogSpace_MaxPPulse(IntM ret_val) {
   const IntS X16_IND_MAXPP = 76; 

   IntS addr;
   IntM tdata;
   StringS str1;

   tdata = 0;

   addr = ADDR_PROG_MAX_PULSE;
//   GetRamContentDec_16Bit("ramread_nburst_lsw_Thrd",addr,tdata);
   GetRamContentDec_16Bit("ramread_nburst_lsw_v4p0_Thrd",addr,tdata);

   ret_val = tdata;

   if(tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT) {
      str1 = "FL_MAXPPULSE 0x";
      // PrintHeaderBool(GL_PLELL_FORMAT);
      // PrintResultIntHex(str1,0,tdata,0,0,GL_PLELL_FORMAT);
      cout << str1 << hex << ret_val << endl; IO.Flush(IO.Stdout);
   } 
}   // Get_TLogSpace_MaxPPulse

//void Get_TLogSpace_TotPPulse(    IntM msw_data,
//                                  IntM lsw_data)
//{
//   const IntS X16_IND_TOTPP_MSW = 77; 
//   const IntS X16_IND_TOTPP_LSW = 78; 
//
//   IntS addr_loc,site;
//   IntM msw_val,lsw_val;
//   StringS str1;
//
//   if(v_any_dev_active)  
//   {
//      if(GL_DO_ESDA_WITH_SCRAM)  
//      {
//         msw_val = FL_TESTLOG_ARR[X16_IND_TOTPP_MSW];
//         lsw_val = FL_TESTLOG_ARR[X16_IND_TOTPP_LSW];
//      }
//      else
//      {
//         addr_loc = ADDR_PROG_TOT_PULSE;
//         GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_val);
//         GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_val);
//      } 
//
//      msw_data = msw_val;
//      lsw_data = lsw_val;
//
//      if(tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT)  
//      {
//         str1 = "FL_TOTPPULSE_MSW";
//          /*PrintHeaderBool(GL_PLELL_FORMAT);*/
//         PrintResultIntHex(str1,0,msw_val,0,0,GL_PLELL_FORMAT);
//         str1 = "FL_TOTPPULSE_LSW";
//         PrintResultIntHex(str1,0,lsw_val,0,0,GL_PLELL_FORMAT);
//      } 
//   } 
//}   /* Get_TLogSpace_TotPPulse */
   
void Get_TLogSpace_MeasFreq(IntM msw_data, IntM lsw_data) {

   const IntS X16_IND_MEASFREQ_MSW = 79; 
   const IntS X16_IND_MEASFREQ_LSW = 80; 

   IntS addr_loc,site;
   IntM msw_val,lsw_val;
   StringS str1;

//   if(GL_DO_ESDA_WITH_SCRAM)
   if (0) {
      msw_val = FL_TESTLOG_ARR[X16_IND_MEASFREQ_MSW];
      lsw_val = FL_TESTLOG_ARR[X16_IND_MEASFREQ_LSW];
   }
   else {
      addr_loc = ADDR_MEASFREQ;
      GetRamContentDec_16Bit("ramread_nburst_lsw",addr_loc,lsw_val);
      GetRamContentDec_16Bit("ramread_nburst_msw",addr_loc,msw_val);
   } 

   msw_data = msw_val;
   lsw_data = lsw_val;

   if (tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT) {
      str1 = "FL_MEASFREQ_MSW 0x";
       /*PrintHeaderBool(GL_PLELL_FORMAT);*/
//      PrintResultIntHex(str1,0,msw_val,0,0,GL_PLELL_FORMAT);
      cout << str1 << hex << msw_data << endl; IO.Flush(IO.Stdout);
      str1 = "FL_MEASFREQ_LSW 0x";
//      PrintResultIntHex(str1,0,lsw_val,0,0,GL_PLELL_FORMAT);
      cout << str1 << hex << lsw_data << endl; IO.Flush(IO.Stdout);
   } 
}   // Get_TLogSpace_MeasFreq
   
void Get_TLogSpace_RTIValue(IntM ret_val)
{
   const IntS X16_IND_RTITIMER_MSW = 81; 
   const IntS X16_IND_RTITIMER_LSW = 82; 

   IntS site,addr;
   IntM tdata;
   IntM tdata1,tdata0;
   StringS str1;

   tdata = 0;
//   {
//      tdata1 = FL_TESTLOG_ARR[X16_IND_RTITIMER_MSW];
//      arrayandintegervalue(tdata1,tdata1,0x7fff,v_sites);
//      arraymultintegervalue(tdata,tdata1,0x10000,v_sites);
//      tdata0 = FL_TESTLOG_ARR[X16_IND_RTITIMER_LSW];
//      arrayaddinteger(tdata,tdata,tdata0,v_sites);
//   }
//   else
//   {
      addr = ADDR_RTITIMER;
      //GetRamContentDec_16bit(ramread_nburst_msw,addr,tdata1);
      GetRamContentDec_16Bit("ramread_nburst_msw_v4p0_Thrd",addr,tdata1);
      //GetRamContentDec_16bit(ramread_nburst_lsw,addr,tdata0);
      GetRamContentDec_16Bit("ramread_nburst_lsw_v4p0_Thrd",addr,tdata0);
//      arrayandintegervalue(tdata1,tdata1,0x7fff,v_sites);
      tdata1 = tdata1 & IntS(0x0000ffff); //mask the upper two bites
                                      //This code generates an erro
//      tdata1 = tdata1 << 16;
//      tdata1 = tdata >> 16;
//      arraymultintegervalue(tdata,tdata1,0x10000,v_sites);
      tdata = tdata1 * IntS(0xffff0000); //mask the lower two bites
                                   //This code generates an error
//      tdata = tdata << 16;
//      arrayaddinteger(tdata,tdata,tdata0,v_sites);
      tdata = tdata | tdata0;
//   } 
      
   ret_val = tdata;

   if(tistdscreenprint and TI_FlashDebug and TI_FLASHDEBUG_PRINT)  
   {
      str1 = "FL_RTIVALUE";
      /*PrintHeaderBool(GL_PLELL_FORMAT);*/
      //This function is not yet implemented
      //PrintResultIntHex(str1,0,tdata,0,0,GL_PLELL_FORMAT);
   } 
}   /* Get_TLogSpace_RTIValue */
//
void GetRTIValue(    IntM ret_val)
{
   IntS site;
   IntM rti_val,lsb_val,msb_val;
   IntS addr_loc;
   IntM value1,value2;


   rti_val = 0;
   Get_TLogSpace_RTIValue(rti_val);
   ret_val =  rti_val;
}    /*GetRTIValue*/
//
//void Get_Flash_ESDASpace_SCRAM()
//{
//   IntS addr,store_option;
//   FloatS ttimer1;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint)  
//         cout << "*** Get_Flash_ESDASpace_SCRAM ***" << endl;
//      timernstart(ttimer1);
//      addr = ADDR_RAM_ESDA;
//      store_option = ord(MBOXLOG_ARR);
//      GetRamContent_SCRAM(addr,store_option);
//      if(tistdscreenprint)  
//         cout << "Get_Flash_ESDASpace_SCRAM TT : " << timernread(ttimer1) << endl;
//   }    
//}   /* Get_Flash_ESDASpace_SCRAM */
//
// /*log fail test to TW. Also negate GL_F021_COF_PASS and store 1st fail testname*/
// /*for later use to make sure not overwrite 1st failing result/testname if same*/
// /*testname is used*/
//void F021_Log_FailPat_To_TW(StringS tmpstr,
//                                 BoolM results,
//                                 StringS tname)
//{
//   IntS site;
//   BoolM savesites,logsites,allfalsesites;
//   StringM failstr1,failstr2,failstr3,failstr4;
//   StringM failstr5,failstr6,failstr7,failstr8;
//   StringM failstr9,failstr10,failstr11,failstr12;
//   StringM failstr13,failstr14,failstr15,failstr16;
//   StringM stat1_msb,stat1_lsb;
//   StringM stat2_msb,stat2_lsb;
//   StringM stat3_msb,stat3_lsb;
//   StringM stat4_msb,stat4_lsb;
//   StringM avnv_msb,internbin_lsb;
//   StringM failaddr_msb,failaddr_lsb;
//   StringM faildata_msb,faildata_lsb;
//   StringM pfbin_msb,tnum_lsb,tnum_msb;
//   StringM mstat_msb,mstat_lsb,erspls_lsb;
//   StringM maxcmpt_msb,maxprog_lsb;
//   StringM totprog_msb,totprog_lsb;
//   StringM totcmpt_msb,totcmpt_lsb;
//   IntM val_msb,val_lsb;
//   StringM tmpbinstr;
//   BoolS logenable;
//
//    /*KChau 12/21/07 - log parallel but turn-off & on sites*/
//   savesites = v_dev_active;
//   allfalsesites = false;
//   
//    /*logsites member is true if it is failing site*/
//   ArrayXORBoolean(logsites,savesites,results,v_sites);
//    /*determine if any fail site is not 1st fail then negate logsites member*/
//   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      if(v_dev_active[site] and logsites[site] and GL_F021_LOG_FAIL_PATT[site])  
//         logsites[site] = false;
//
//   if(not arraycompareboolean(allfalsesites,logsites,v_sites))  
//   {
//      DevSetHoldStates(logsites);  /*activate 1st failing sites only to log*/
//
//      switch(tname) {
//        FlashEfuseRd_Test,
//        FTrimProg_st, FTrimProg2_st, FTrimProg3_st,
//        FTrimPstRd_st, FTrimPstRdMg_st,
//        FTrimPstRd2_st, FTrimPstRdMg2_st,
//        case  FTrimPstRd3_st: case  FTrimPstRdMg3_st : 
//         
//            /*do nothing*/
//           logenable = false;
//         break; 
//
//        default:  
//           disable(s_pmexit);
//           logenable = true;
//           sparebool1 = TI_FlashDebug;
//           TI_FlashDebug = false;
//
//            /*get status, global, test log*/
//           Get_TLogSpace_STAT1(val_msb,val_lsb);
//           IntToBCD_BinStr(val_msb,stat1_msb,tmpbinstr,true);
//           IntToBCD_BinStr(val_lsb,stat1_lsb,tmpbinstr,true);
//           
//           Get_TLogSpace_STAT2(val_msb,val_lsb);
//           IntToBCD_BinStr(val_msb,stat2_msb,tmpbinstr,true);
//           IntToBCD_BinStr(val_lsb,stat2_lsb,tmpbinstr,true);
//           
//           Get_TLogSpace_STAT3(val_msb,val_lsb);
//           IntToBCD_BinStr(val_msb,stat3_msb,tmpbinstr,true);
//           IntToBCD_BinStr(val_lsb,stat3_lsb,tmpbinstr,true);
//           
//           Get_TLogSpace_STAT4(val_msb,val_lsb);
//           IntToBCD_BinStr(val_msb,stat4_msb,tmpbinstr,true);
//           IntToBCD_BinStr(val_lsb,stat4_lsb,tmpbinstr,true);
//
//           Get_TLogSpace_TESTFREQ(val_msb);
//           IntToBCD_BinStr(val_msb,avnv_msb,tmpbinstr,true);
//
//           Get_TLogSpace_PFBIN(val_lsb);
//            /*IntToBCD_BinStr(val_lsb,internbin_lsb,tmpbinstr,true);*/
//           IntToBCD_BinStr(val_lsb,pfbin_msb,tmpbinstr,true);
//
//           Get_TLogSpace_FailAddr(val_msb,val_lsb);
//           IntToBCD_BinStr(val_msb,failaddr_msb,tmpbinstr,true);
//           IntToBCD_BinStr(val_lsb,failaddr_lsb,tmpbinstr,true);
//
//           Get_TLogSpace_FailData(val_msb,val_lsb);
//           IntToBCD_BinStr(val_msb,faildata_msb,tmpbinstr,true);
//           IntToBCD_BinStr(val_lsb,faildata_lsb,tmpbinstr,true);
//
//           Get_TLogSpace_TNUM(val_msb,val_lsb);
//           IntToBCD_BinStr(val_msb,tnum_msb,tmpbinstr,true);
//           IntToBCD_BinStr(val_lsb,tnum_lsb,tmpbinstr,true);
//           
//           Get_TLogSpace_MSTAT(val_msb,val_lsb);
//           IntToBCD_BinStr(val_msb,mstat_msb,tmpbinstr,true);
//           IntToBCD_BinStr(val_lsb,mstat_lsb,tmpbinstr,true);
//           
//           Get_TLogSpace_ErsPulse(val_lsb);
//           IntToBCD_BinStr(val_lsb,erspls_lsb,tmpbinstr,true);
//           
//           Get_TLogSpace_TrimSol(val_msb);
//           IntToBCD_BinStr(val_msb,maxcmpt_msb,tmpbinstr,true);
//           
//           Get_TLogSpace_MaxPPulse(val_lsb);
//           IntToBCD_BinStr(val_lsb,maxprog_lsb,tmpbinstr,true);
//           
//           Get_TLogSpace_TotPPulse(val_msb,val_lsb);
//           IntToBCD_BinStr(val_msb,totprog_msb,tmpbinstr,true);
//           IntToBCD_BinStr(val_lsb,totprog_lsb,tmpbinstr,true);
//           
//           Get_TLogSpace_MeasFreq(val_msb,val_lsb);
//           IntToBCD_BinStr(val_msb,totcmpt_msb,tmpbinstr,true);
//           IntToBCD_BinStr(val_lsb,totcmpt_lsb,tmpbinstr,true);
//           TI_FlashDebug = sparebool1;
//        } 
//      }   /* case */
//      
//      
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      {
//         if(v_dev_active[site])  
//         {
//             /*log on 1st fail*/
//            GL_F021_LOG_FAIL_PATT[site] = true;
//            GL_F021_FAIL_PATT[site] = tmpstr;
//            
//             /*flag failing site for COF*/
//            if(GL_F021_COF_PASS[site] and TI_FlashCOFEna)  
//            {
//               GL_F021_COF_PASS[site] = false;
//               GL_F021_COF_1STFAILTEST[site] = tname;
//               
//               if(tistdscreenprint)  
//               {
//                  cout << "Site " << site:5 << " logging to TW " << tmpstr << endl;
//                  if(TI_FlashCOFEna)  
//                     cout << "      Negate GL_F021_COF_PASS to false" << endl;
//               } 
//            } 
//
//            if(logenable)  
//            {
//               failstr1[site] = stat1_msb[site] + stat1_lsb[site];
//               failstr1[site] = "0x" + failstr1[site];
//               failstr2[site] = stat2_msb[site] + stat2_lsb[site];
//               failstr2[site] = "0x" + failstr2[site];
//               failstr3[site] = stat3_msb[site] + stat3_lsb[site];
//               failstr3[site] = "0x" + failstr3[site];
//               failstr4[site] = stat4_msb[site] + stat4_lsb[site];
//               failstr4[site] = "0x" + failstr4[site];
//               failstr5[site] = "0x" + avnv_msb[site];
//               failstr6[site] = "0x" + pfbin_msb[site];
//               failstr7[site] = failaddr_msb[site] + failaddr_lsb[site];
//               failstr7[site] = "0x" + failstr7[site];
//               failstr8[site] = faildata_msb[site] + faildata_lsb[site];
//               failstr8[site] = "0x" + failstr8[site];
//                /*failstr9[site] := concat("0x",pfbin_msb[site]);*/
//               failstr10[site] = tnum_msb[site] + tnum_lsb[site];
//               failstr10[site] = "0x" + failstr10[site];
//               failstr11[site] = "0x" + mstat_msb[site];
//               failstr11[site] = failstr11[site] + mstat_lsb[site];
//               failstr12[site] = "0x" + erspls_lsb[site];
//               failstr13[site] = "0x" + maxcmpt_msb[site];
//               failstr14[site] = "0x" + maxprog_lsb[site];
//               failstr15[site] = totprog_msb[site] + totprog_lsb[site];
//               failstr15[site] = "0x" + failstr15[site];
//               failstr16[site] = totcmpt_msb[site] + totcmpt_lsb[site];
//               failstr16[site] = "0x" + failstr16[site];
//            }   /*logenable*/
//         }   /*if v_dev_active*/
//      }   /*site*/
//
//       /*KChau 01/08/08 - changed FAIL_PAT to FL_FAIL_PAT*/
//      TWPDLDataLogText("FL_FAIL_PAT",GL_F021_FAIL_PATT,TWMinimumData);
//
//      if(logenable)  
//      {
//         TWPDLDataLogText("FL_FAIL_PAT_STAT1",failstr1,TWMinimumData);
//         TWPDLDataLogText("FL_FAIL_PAT_STAT2",failstr2,TWMinimumData);
//         TWPDLDataLogText("FL_FAIL_PAT_STAT3",failstr3,TWMinimumData);
//         TWPDLDataLogText("FL_FAIL_PAT_STAT4",failstr4,TWMinimumData);
//         TWPDLDataLogText("FL_FAIL_PAT_TESTFREQ",failstr5,TWMinimumData);   /*was FL_FAIL_PAT_AVNV*/
//         TWPDLDataLogText("FL_FAIL_PAT_PFBIN",failstr6,TWMinimumData);
//         TWPDLDataLogText("FL_FAIL_PAT_FADDR",failstr7,TWMinimumData);
//         TWPDLDataLogText("FL_FAIL_PAT_FDATA",failstr8,TWMinimumData);
//          /*TWPDLDatalogTextMS("FL_FAIL_PAT_PFBIN",failstr9,twminimumdata);*/
//         TWPDLDataLogText("FL_FAIL_PAT_TNUM",failstr10,TWMinimumData);
//         TWPDLDataLogText("FL_FAIL_PAT_MSTAT",failstr11,TWMinimumData);
//         TWPDLDataLogText("FL_FAIL_PAT_ERSPLS",failstr12,TWMinimumData);
//         TWPDLDataLogText("FL_FAIL_PAT_TRIMSOL",failstr13,TWMinimumData);   /*was FL_FAIL_PAT_MXCMPT*/
//         TWPDLDataLogText("FL_FAIL_PAT_MXPROG",failstr14,TWMinimumData);
//         TWPDLDataLogText("FL_FAIL_PAT_TOTPROG",failstr15,TWMinimumData);
//         TWPDLDataLogText("FL_FAIL_PAT_MEASFREQ",failstr16,TWMinimumData);   /*was FL_FAIL_PAT_TOTCMPT*/
//      } 
//
//      if(TITestType==MP3)  
//         if(GL_DO_RESTORE_OTP_ON_FAIL and (not TI_FlashCOFEna) and (not TIIgnoreFail))  
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//                  SITE_TO_RESTORE_OTP[site] = true;
//      
//      DevSetHoldStates(savesites);  /*re-activate all active in-coming sites*/
//   }   /*if not arraycompare*/
//
//}   /* F021_Log_FailPat_To_TW */
//
// /*init sites cof instance string to null*/
//void F021_Init_COF_Inst_Str(    StringM site_cof_inst_str)
//{
//   IntS site;
//
//   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      if(v_dev_active[site])  
 //        site_cof_inst_str[site] = "";
//}   /* F021_Init_COF_Inst_Str */
//
//
//   
// /*update sites cof instance string, i.e. store bank/sector/blk failed*/
//void F021_Update_COF_Inst_Str(    StringS failstr,
//                                       StringM site_cof_inst_str,
//                                       BoolM results)
//{
//   IntS site;
//   StringS tmpstr;
//
//   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      if(v_dev_active[site] and (not results[site]))  //if site is active and site results are false
//      {
//         if((len(site_cof_inst_str[site]) + len(failstr)) < 255)  
//            site_cof_inst_str[site] = site_cof_inst_str[site] + failstr;
//         else
//         {
//            tmpstr = site_cof_inst_str[site] + failstr;
//            tmpstr = mid(tmpstr,1,255);
//            site_cof_inst_str[site] = tmpstr;
//            if(tistdscreenprint)  
//               cout << "Warning: fail string >255 so truncate !!!" << endl;
//         } 
//      } 
//            
//}   /* F021_Update_COF_Inst_Str */
//
//
//   
// /*save fail info into 1 of 10 strings when continue-on-fail (ti_flashcofena=true)*/
//void F021_Save_COF_Info(StringS tnamestr,
//                             StringM failstr,
//                             BoolM results)
//{
//   IntS site;
//   BoolM savesites,logsites;
//   BoolS debugprint;
//   IntS length,index;
//   IntS maxstrnum;
//
//
//   if(not arraycompareboolean(results,v_dev_active,v_sites))  
//   {
//      debugprint = false;
//       /*note: max defined is 40 strings, see GL_F021_COF_INFOS in f021_flashvar.p*/
//      maxstrnum = 20 ; /*10*/
//   
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      {
//         if(v_dev_active[site] and (not results[site]))  
//         {
//            for (index = 1;index <= maxstrnum;index++)
//            {
//               if((not GL_F021_COF_INFOS_FULL[index][site]) and
//                  ((len(GL_F021_COF_INFOS[index][site])+len(tnamestr)+len(failstr[site])) < 250))  
//               {
//                  GL_F021_COF_INFOS[index][site] =
//                  GL_F021_COF_INFOS[index][site] + tnamestr;
//
//                  GL_F021_COF_INFOS[index][site] =
//                  GL_F021_COF_INFOS[index][site] + failstr[site];
//                  
//                  GL_F021_COF_INFOS[index][site] =
//                  GL_F021_COF_INFOS[index][site] + " + ";
//                  
//                  if(tistdscreenprint and TI_FlashDebug)  
//                     cout << "Site " << site:3 << "  GL_F021_COF_INFOS[" << index:2 << 
//                             " ] : " << GL_F021_COF_INFOS[index][site] << endl;
//                  break;
//               }
//               else
//               {
//                   /*set FULL so to use next string*/
//                  GL_F021_COF_INFOS_FULL[index][site] = true;
//                  if(tistdscreenprint and debugprint)  
//                     cout << "Site " << site:3 << "  GL_F021_COF_INFOS[" << index:2 << 
//                             " ] is FULL." << endl;
//                  if(index==maxstrnum)  
//                     if(tistdscreenprint)  
//                        cout << "WARNING: GL_F021_COF_INFOS STRINGS ARE ALL FULL." << 
//                                "  FAIL INFOS WOULD BE LOST !!!" << endl;
//               } 
//            }   /*for*/
//         }   /*if active*/
//      }   /*for site*/
//   }   /*if not arraycompare*/
//                  
//}   /* F021_Save_COF_Info */
//            
//
// /*send saved fail info to tw*/
//void F021_Send_COF_Info_To_TW()
//{
//   IntS site;
//   BoolM savesites,logsites;
//   IntS length,index;
//   IntS maxstrnum;
//   StringS tmpstr1,tmpstr2;
//   StringS1D strlabel(41);
//   BoolS logena;
//
//   logena = false;
//
//    /*check to see at least one site needs tw log*/
//   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      if(v_dev_active[site] and (not GL_F021_COF_PASS[site]))  
//      {
//         logena = true;
//         break;
//      } 
//
//   if(logena)  
//   {
//       /*note: max defined is 40 strings, see GL_F021_COF_INFOS in f021_flashvar.p*/
//      maxstrnum = 10;
//      tmpstr1 = "FL_COF_INFOS_";
//
//      for (index = 1;index <= maxstrnum;index++)
//      {
//         writestring(tmpstr2,index:1);
//         strlabel[index] = tmpstr1 + tmpstr2;
//      } 
//   
//      savesites = v_dev_active;
//      logsites = false;
//      devsetholdstates(logsites);
//      
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(savesites[site] and (not GL_F021_COF_PASS[site]))  
//         {
//            devsetholdstate(site,true);
//            for (index = 1;index <= maxstrnum;index++)
//            {
//               if((len(GL_F021_COF_INFOS[index][site])) > 0)  
//               {
//                  tmpstr1 = strlabel[index];
//                  tmpstr2 = GL_F021_COF_INFOS[index][site];
//                  TWPDLDatalogTextSite(tmpstr1,tmpstr2,site,TWMinimumData);
//                  if(tistdscreenprint)  
//                  {
//                     cout << "Sending COF info to TW on site " << site:3 << endl;
//                     cout << tmpstr1 << " == " << tmpstr2 << endl;
//                  } 
//               }
//               else
//               {
//                  break;  /*out of for index loop*/
//               } 
//            }   /*for index*/
//            devsetholdstate(site,false);
//         }   /*if savesites*/
//
//      devsetholdstates(savesites);
//   }                     /*if logena*/
//}   /* F021_Send_COF_Info_To_TW */
//
//
//void F021_Log_OTP_To_TW()
//{
//   IntS site,count;
//   StringM tmpstr,tmpstr2;
//   StringM tmpstr3,tmpstr4;
//   StringM librev;
//   StringS labelstr;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint)  
//         cout << "Logging OTP WD8/9 and Die-ID to TW..." << endl;
//
//      for (count = 0;count <= 7;count++)
//      {
//         writestring(labelstr,count:1);
//         labelstr = "OTP_WD8_" + labelstr;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               writestring(tmpstr[site],FRM_OTP_WD8[count][site]);
//         TWPDLDataLogText(labelstr,tmpstr,TWMinimumData);
//      } 
//         
//      for (count = 0;count <= 7;count++)
//      {
//         writestring(labelstr,count:1);
//         labelstr = "OTP_WD9_" + labelstr;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               writestring(tmpstr[site],FRM_OTP_WD9[count][site]);
//         TWPDLDataLogText(labelstr,tmpstr,TWMinimumData);
//      } 
//         
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            writestring(tmpstr[site],FRM_OTP_ASICHI_BCD[site]);
//            tmpstr[site] = tmpstr[site] + FRM_OTP_ASICLO_BCD[site];
//            writestring(tmpstr2[site],FRM_OTP_LOTHI_BCD[site]);
//            tmpstr2[site] = tmpstr2[site] + FRM_OTP_LOTLO_BCD[site];
//            librev[site] = GL_VLC_LIBREV;
//            tmpstr3[site] = FRM_OTP_BANK_EFSUM_HI_BCD[0][site];
//            tmpstr4[site] = FRM_OTP_BANK_EFSUM_LO_BCD[0][site];
//         } 
//      
//      TWPDLDataLogText("OTP_ASICNUM",tmpstr,TWMinimumData);
//
//      TWPDLDataLogText("OTP_LOT",tmpstr2,TWMinimumData);
//
//      TWPDLDataLogText("OTP_WAFER",FRM_OTP_WAFER_BCD,TWMinimumData);
//
//      TWPDLDataLogText("OTP_X",FRM_OTP_XPOS_BCD,TWMinimumData);
//
//      TWPDLDataLogText("OTP_Y",FRM_OTP_YPOS_BCD,TWMinimumData);
//
//      TWPDLDataLogText("OTP_FLWBYTE",FRM_OTP_FLWBYTE_BCD,TWMinimumData);
//
//      TWPDLDataLogText("OTP_EFCHKSUM_MSW",tmpstr3,TWMinimumData);
//      TWPDLDataLogText("OTP_EFCHKSUM_LSW",tmpstr4,TWMinimumData);
//
//      if((titesttype==PreBurnIn) or (titesttype==PostBurnIn1) or (titesttype==FT2))  
//      {
//         TWPDLDataLogText("OTP_PKGID",FRM_OTP_PKGID_BCD,TWMinimumData);
//         TWPDLDataLogText("OTP_MEMSZ",FRM_OTP_MEMSZ_BCD,TWMinimumData);
//      } 
//
//   } 
//
//}   /* F021_Log_OTP_To_TW */
//   
//
//
// /*log OTP Word9, asicnum, lot, wafer, x, y, and flowbyte to TW*/
//void F021_Log_OTP_To_TW_Final()
//{
//   IntS site,count;
//   StringM tmpstr,tmpstr2;
//   StringM tmpstr3,tmpstr4;
//   StringM librev;
//   StringS labelstr;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint)  
//         cout << "Logging Final OTP WD8/9 and Die-ID to TW..." << endl;
//      
//      for (count = 0;count <= 7;count++)
//      {
//         writestring(labelstr,count:1);
//         labelstr = "OTP_WD8_" + labelstr;
//         labelstr = labelstr + "_FN";
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               writestring(tmpstr[site],FRM_OTP_WD8[count][site]);
//         TWPDLDataLogText(labelstr,tmpstr,TWMinimumData);
//      } 
//         
//      for (count = 0;count <= 7;count++)
//      {
//         writestring(labelstr,count:1);
//         labelstr = "OTP_WD9_" + labelstr;
//         labelstr = labelstr + "_FN";
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               writestring(tmpstr[site],FRM_OTP_WD9[count][site]);
//         TWPDLDataLogText(labelstr,tmpstr,TWMinimumData);
//      } 
//
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            writestring(tmpstr[site],FRM_OTP_ASICHI_BCD[site]);
//            tmpstr[site] = tmpstr[site] + FRM_OTP_ASICLO_BCD[site];
//            writestring(tmpstr2[site],FRM_OTP_LOTHI_BCD[site]);
//            tmpstr2[site] = tmpstr2[site] + FRM_OTP_LOTLO_BCD[site];
//            librev[site] = GL_VLC_LIBREV;
//            tmpstr3[site] = FRM_OTP_BANK_EFSUM_HI_BCD[0][site];
//            tmpstr4[site] = FRM_OTP_BANK_EFSUM_LO_BCD[0][site];
//         } 
//      
//      TWPDLDataLogText("OTP_ASICNUM_FN",tmpstr,TWMinimumData);
//
//      TWPDLDataLogText("OTP_LOT_FN",tmpstr2,TWMinimumData);
//
//      TWPDLDataLogText("OTP_WAFER_FN",FRM_OTP_WAFER_BCD,TWMinimumData);
//
//      TWPDLDataLogText("OTP_X_FN",FRM_OTP_XPOS_BCD,TWMinimumData);
//
//      TWPDLDataLogText("OTP_Y_FN",FRM_OTP_YPOS_BCD,TWMinimumData);
//
//      TWPDLDataLogText("OTP_FLWBYTE_FN",FRM_OTP_FLWBYTE_BCD,TWMinimumData);
//
//      TWPDLDataLogText("OTP_EFCHKSUM_MSW_FN",tmpstr3,TWMinimumData);
//      TWPDLDataLogText("OTP_EFCHKSUM_LSW_FN",tmpstr4,TWMinimumData);
//
//      if((titesttype==PreBurnIn) or (titesttype==PostBurnIn1) or (titesttype==FT2))  
//      {
//         TWPDLDataLogText("OTP_PKGID_FN",FRM_OTP_PKGID_BCD,TWMinimumData);
//         TWPDLDataLogText("OTP_MEMSZ_FN",FRM_OTP_MEMSZ_BCD,TWMinimumData);
//      } 
//
//       /*log std vlct lib revision*/
//      TWPDLDataLogText("F021_VLC_LIBREV_FN",librev,TWMinimumData);
//
//       /*log shell revision*/
//      TWPDLDataLogVariable("F021_SHELL_LIBREV_FN",GL_SHELL_LIBREV,TWMinimumData);
//      TWPDLDataLogVariable("F021_SHELL_TAPIREV_FN",GL_SHELL_TAPIREV,TWMinimumData);
//      TWPDLDataLogVariable("F021_SHELL_FAPIREV_FN",GL_SHELL_FAPIREV,TWMinimumData);
//      TWPDLDataLogVariable("F021_SHELL_CONFIGREV_FN",GL_SHELL_CONFIGREV,TWMinimumData);
//      TWPDLDataLogVariable("F021_SHELL_SUPPORTREV_FN",GL_SHELL_SUPPORTREV,TWMinimumData);
//   } 
//
//}   /* F021_Log_OTP_To_TW_Final */
//
// /*write enable key for FMW dump*/
//void TL_FMW_EnableKey(BoolS enakey)
//{
//   IntS ovrkey,addr,site;
//   IntM lsw_data,msw_data;
//
//   if(v_any_dev_active)  
//   {
//      addr = ADDR_RAM_FMW;
//      if(enakey)  
//         ovrkey = 0xAA55  ; /*set*/
//      else
//         ovrkey = 0x0000;  /*clear*/
//       /*get 0xBE content*/
//      GetRamContentDec_16bit(ramread_nburst_lsw,addr,lsw_data);
//      msw_data = ovrkey;
//      WriteRamContentDec_32Bit(addr,lsw_data,true,msw_data,true,true);
//      if(tistdscreenprint and TI_FlashDebug)  
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               readramaddress(site,addr,addr+ADDR_RAM_INC);
//   } 
//}   /* TL_FMW_EnableKey */
//   
// /*dump FMW contents after a certain test is executed*/
//void TL_GetFMWInfo()
//{
//   IntS testnum,site;
//   IntM mdata,rserv_data;
//   IntM msw_data,lsw_data;
//   IntM tnumhi,tnumlo;
//   FloatS maxtime;
//   FloatM tt_timer;
//   BoolM final_results;
//   IntS fdlen1,fdlen2,fdlen3;
//   StringS str1,str2,str3,str4;
//   StringS1D labelarr(27);
//   IntS addr_loc,length;
//   IntS loop,index;
//   IntS ovrkey;
//
//   if(v_any_dev_active)  
//   {
//      addr_loc = ADDR_TEST_INFO;
//      GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,tnumhi);
//      GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,tnumlo);
//
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            testnum = (tnumhi[site]<<16)+tnumlo[site];
//            break;
//         } 
//
//      if(tistdscreenprint)  
//      {
//         cout << "Dumping FMW contents of TNUM" << testnum:s_hex:12 << 
//                 " Contents address follow" << endl;
//         cout << "PLLCTL1==0x204 <<  PLLCTL2==0x208 <<  Reserved==0x20C" << endl;
//         cout << "Config  Registers 0x210 - 0x28C" << endl;
//         cout << "Voltage Registers 0x290 - 0x2A8" << endl;
//         cout << "Command Registers 0x2B0 - 0x2F4" << endl;
//         cout << "StateMc Registers 0x300 - 0x394" << endl;
//         cout << "EEP CTL Registers 0x398 - 0x3B0" << endl;
//         cout << "Bus2    Registers 0x3C8 - 0x3E0" << endl;
//         
//         PrintHeaderBool(GL_PLELL_FORMAT);
//         addr_loc = ADDR_RAM_MAILBOX+ADDR_RAM_INC;
//
//         for (loop = 1;loop <= 2;loop++)
//         {
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//            ArrayAddIntegerValue(msw_data,msw_data,0xffff,v_sites);
//            ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//            if(loop==1)  
//               str1 = "PLLCTL1";
//            else
//               str1 = "PLLCTL2";
//            PrintResultInt(str1,0,msw_data,0,0,GL_PLELL_FORMAT);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//         } 
//
//         addr_loc = addr_loc+ADDR_RAM_INC;   /*skip reserved word*/
//          /*-- Config Regs --*/
//         for (loop = 1;loop <= 9;loop++)
//         {
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//            ArrayAddIntegerValue(msw_data,msw_data,0xffff,v_sites);
//            ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//            switch(loop) {
//              case 1 : str1 = "FRDCNTL";
//              case 2 : str1 = "FSPRD";
//              case 3 : str1 = "FEDACCTRL1";
//              case 4 : str1 = "FEDACCTRL2";
//              case 5 : str1 = "FCOR_ERR_CNT";
//              case 6 : str1 = "FCOR_ERR_ADD";
//              case 7 : str1 = "FCOR_ERR_POS";
//              case 8 : str1 = "FEDACSTATUS";
//              case 9 : str1 = "FUNC_ERR_ADD";
//            }   /* case */
//            PrintResultInt(str1,0,msw_data,0,0,GL_PLELL_FORMAT);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//         } 
//
//         addr_loc = addr_loc+(3*ADDR_RAM_INC);  /*skip FEDACSDIS 3 32bit words*/
//         for (loop = 1;loop <= 20;loop++)
//         {
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//            ArrayAddIntegerValue(msw_data,msw_data,0xffff,v_sites);
//            ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//            switch(loop) {
//              case 1  : str1 = "FBPROT";
//              case 2  : str1 = "FBSE";
//              case 3  : str1 = "FBBUSY";
//              case 4  : str1 = "FBAC";
//              case 5  : str1 = "FBFALLBACK";
//              case 6  : str1 = "FBPRDY";
//              case 7  : str1 = "FPAC1";
//              case 8  : str1 = "FPAC2";
//              case 9  : str1 = "FMAC";
//              case 10 : str1 = "FMSTAT";
//              case 11 : str1 = "FEMU_DMSW";
//              case 12 : str1 = "FEMU_DLSW";
//              case 13 : str1 = "FEMU_ECC";
//              case 14 : str1 = "FLOCK";
//              case 15 : str1 = "FEMU_ADDR";
//              case 16 : str1 = "FDIAGCTRL";
//              case 17 : str1 = "FRAWDATAH";
//              case 18 : str1 = "FRAWDATAL";
//              case 19 : str1 = "FRAWECC";
//              case 20 : str1 = "FPAR_OVR";
//            }   /* case */
//            PrintResultInt(str1,0,msw_data,0,0,GL_PLELL_FORMAT);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//         } 
//
//          /*-- Voltage Regs --*/
//         for (loop = 1;loop <= 12;loop++)
//         {
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//            ArrayAddIntegerValue(msw_data,msw_data,0xffff,v_sites);
//            ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//            switch(loop) {
//              case 1  : str1 = "FVREADCT";
//              case 2  : str1 = "FVHVCT1";
//              case 3  : str1 = "FVHVCT2";
//              case 4  : str1 = "FVHVCT3";
//              case 5  : str1 = "FVINCT";
//              case 6  : str1 = "FVSLCT";
//              case 7  : str1 = "FVWLCT";
//              case 8  : str1 = "FEFUSECTRL";
//              case 9  : str1 = "FEFUSESTAT";
//              case 10 : str1 = "FEFUSEDATA";
//              case 11 : str1 = "FSEQPMP";
//              case 12 : str1 = "FCLKTRIM";
//            }   /* case */
//            PrintResultInt(str1,0,msw_data,0,0,GL_PLELL_FORMAT);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//         } 
//
//          /*-- Command Regs --*/
//         for (loop = 1;loop <= 17;loop++)
//         {
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//            ArrayAddIntegerValue(msw_data,msw_data,0xffff,v_sites);
//            ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//            switch(loop) {
//              case 1  : str1 = "FBSTROBES   ";
//              case 2  : str1 = "FPSTROBES   ";
//              case 3  : str1 = "FBMODE      ";
//              case 4  : str1 = "FTCR        ";
//              case 5  : str1 = "FADDR       ";
//              case 6  : str1 = "FPMT_CTRL   ";
//              case 7  : str1 = "FPBIST_CTRL ";
//              case 8  : str1 = "FTCTRL      ";
//              case 9  : str1 = "FWPWRITE0   ";
//              case 10 : str1 = "FWPWRITE1   ";
//              case 11 : str1 = "FWPWRITE2   ";
//              case 12 : str1 = "FWPWRITE3   ";
//              case 13 : str1 = "FWPWRITE4   ";
//              case 14 : str1 = "FWPWRITE5   ";
//              case 15 : str1 = "FWPWRITE6   ";
//              case 16 : str1 = "FWPWRITE7   ";
//              case 17 : str1 = "FWPWRITE_ECC";
//            }   /* case */
//            PrintResultInt(str1,0,msw_data,0,0,GL_PLELL_FORMAT);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//         } 
//         
//         for (loop = 1;loop <= 3;loop++)
//         {
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//            ArrayAddIntegerValue(msw_data,msw_data,0xffff,v_sites);
//            ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//            switch(loop) {
//              case 1  : str1 = "FSWSTAT_1";
//              case 2  : str1 = "FSWSTAT_2";
//              case 3  : str1 = "FSWSTAT_3";
//            }   /* case */
//            PrintResultInt(str1,0,msw_data,0,0,GL_PLELL_FORMAT);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//         } 
//            
//          /*-- SM Regs --*/
//         for (loop = 1;loop <= 13;loop++)
//         {
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//            ArrayAddIntegerValue(msw_data,msw_data,0xffff,v_sites);
//            ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//            switch(loop) {
//              case 1  : str1 = "FSM_GLBCTRL";
//              case 2  : str1 = "FSM_STATE";
//              case 3  : str1 = "FSM_STATUS";
//              case 4  : str1 = "FSM_COMMAND";
//              case 5  : str1 = "FSM_PE_OSU";
//              case 6  : str1 = "FSM_VSTAT";
//              case 7  : str1 = "FSM_PE_VSU";
//              case 8  : str1 = "FSM_CMP_VSU";
//              case 9  : str1 = "FSM_EX_VAL";
//              case 10 : str1 = "FSM_RD_H";
//              case 11 : str1 = "FSM_P_OH";
//              case 12 : str1 = "FSM_ERA_OH";
//              case 13 : str1 = "FSM_SAV_PPUL";
//            }   /* case */
//            PrintResultInt(str1,0,msw_data,0,0,GL_PLELL_FORMAT);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//         } 
//         
//         for (loop = 1;loop <= 3;loop++)
//         {
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//            ArrayAddIntegerValue(msw_data,msw_data,0xffff,v_sites);
//            ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//            switch(loop) {
//              case 1  : str1 = "FSM_P_VH_1";
//              case 2  : str1 = "FSM_P_VH_2";
//              case 3  : str1 = "FSM_P_VH_3";
//            }   /* case */
//            PrintResultInt(str1,0,msw_data,0,0,GL_PLELL_FORMAT);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//         } 
//            
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//            ArrayAddIntegerValue(msw_data,msw_data,0xffff,v_sites);
//            ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//            PrintResultInt("FSM_PRG_PW",0,msw_data,0,0,GL_PLELL_FORMAT);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//            
//         for (loop = 1;loop <= 4;loop++)
//         {
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//            ArrayAddIntegerValue(msw_data,msw_data,0xffff,v_sites);
//            ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//            switch(loop) {
//              case 1  : str1 = "FSM_ERS_PW_1";
//              case 2  : str1 = "FSM_ERS_PW_2";
//              case 3  : str1 = "FSM_ERS_PW_3";
//              case 4  : str1 = "FSM_ERS_PW_4";
//            }   /* case */
//            PrintResultInt(str1,0,msw_data,0,0,GL_PLELL_FORMAT);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//         } 
//            
//         for (loop = 1;loop <= 8;loop++)
//         {
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//            ArrayAddIntegerValue(msw_data,msw_data,0xffff,v_sites);
//            ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//            switch(loop) {
//              case 1  : str1 = "FSM_SAV_ERS_PUL";
//              case 2  : str1 = "FSMTIMER";
//              case 3  : str1 = "FSM_MODE";
//              case 4  : str1 = "FSM_PGM";
//              case 5  : str1 = "FSM_ERA";
//              case 6  : str1 = "FSM_PRG_PUL";
//              case 7  : str1 = "FSM_ERA_PUL";
//              case 8  : str1 = "FSM_STEP_SIZE";
//            }   /* case */
//            PrintResultInt(str1,0,msw_data,0,0,GL_PLELL_FORMAT);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//         } 
//            
//         for (loop = 1;loop <= 2;loop++)
//         {
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//            ArrayAddIntegerValue(msw_data,msw_data,0xffff,v_sites);
//            ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//            switch(loop) {
//              case 1  : str1 = "FSM_PUL_CNTR_1";
//              case 2  : str1 = "FSM_PUL_CNTR_2";
//            }   /* case */
//            PrintResultInt(str1,0,msw_data,0,0,GL_PLELL_FORMAT);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//         } 
//         
//         for (loop = 1;loop <= 3;loop++)
//         {
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//            ArrayAddIntegerValue(msw_data,msw_data,0xffff,v_sites);
//            ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//            switch(loop) {
//              case 1  : str1 = "FSM_ST_MACHINE_1";
//              case 2  : str1 = "FSM_ST_MACHINE_2";
//              case 3  : str1 = "FSM_ST_MACHINE_3";
//            }   /* case */
//            PrintResultInt(str1,0,msw_data,0,0,GL_PLELL_FORMAT);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//         } 
//         
//         for (loop = 1;loop <= 2;loop++)
//         {
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//            ArrayAddIntegerValue(msw_data,msw_data,0xffff,v_sites);
//            ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//            switch(loop) {
//              case 1  : str1 = "FSM_WR_ENA";
//              case 2  : str1 = "FSM_ACC_PP";
//            }   /* case */
//            PrintResultInt(str1,0,msw_data,0,0,GL_PLELL_FORMAT);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//         } 
//         
//         for (loop = 1;loop <= 4;loop++)
//         {
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//            ArrayAddIntegerValue(msw_data,msw_data,0xffff,v_sites);
//            ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//            switch(loop) {
//              case 1  : str1 = "FSM_ACC_EP_1";
//              case 2  : str1 = "FSM_ACC_EP_2";
//              case 3  : str1 = "FSM_ACC_EP_3";
//              case 4  : str1 = "FSM_ACC_EP_4";
//            }   /* case */
//            PrintResultInt(str1,0,msw_data,0,0,GL_PLELL_FORMAT);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//         } 
//         
//         for (loop = 1;loop <= 7;loop++)
//         {
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//            ArrayAddIntegerValue(msw_data,msw_data,0xffff,v_sites);
//            ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//            switch(loop) {
//              case 1  : str1 = "FSM_ADDR";
//              case 2  : str1 = "FSM_SECTOR";
//              case 3  : str1 = "FWM_REV_ID";
//              case 4  : str1 = "FSM_ERR_ADDR";
//              case 5  : str1 = "FSM_PGM_MAXPUL";
//              case 6  : str1 = "FSM_EXECUTE";
//              case 7  : str1 = "EEPROM_CONFIG";
//            }   /* case */
//            PrintResultInt(str1,0,msw_data,0,0,GL_PLELL_FORMAT);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//         } 
//
//         cout << endl;
//      }   /*if tistdscreenprint*/
//   }   /*if v_any_dev_active*/
//}   /* TL_GetFMWInfo */
//
// /*arb freq: infreq in mghz w/ no unit*/
//void TL_SetARBFREQ(FloatS infreq,
//                        BoolS pllena)
//{
//   IntS intfreq,bit15_12;
//   IntS addr_loc,site;
//   IntM lsw_data,msw_data;
//   BoolS debugprint;
//
//   if(v_any_dev_active)  
//   {
//      intfreq = trunc(infreq);
//      if(intfreq > 0x0fff)  
//      {
//         intfreq = 0x0fff;
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid freq entered <<  truncated to 0x0fff !!!" << endl;
//      } 
//      
//      if(pllena)  
//         bit15_12 = 0x0000;
//      else
//         bit15_12 = 0x1000;
//
//      addr_loc = ADDR_RAM_ARB_FREQ;
//      
//      GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//      msw_data = intfreq+bit15_12;
//      
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,true,msw_data,true,true);
//      
//      debugprint = TIPrintPass and TI_FlashDebug;
//      if(debugprint and tistdscreenprint)  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               ReadRamAddress(site,addr_loc,addr_loc+ADDR_RAM_INC);
//      } 
//   } 
//}   /* TL_SetARBFREQ */
//
//void TL_GetARBFREQ()
//{
//   IntS site,addr_loc;
//   IntS bit15_12,infreq;
//   IntM lsw_data,msw_data;
//
//   if(v_any_dev_active)  
//   {
//      addr_loc = ADDR_RAM_ARB_FREQ;
//      GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//
//      if(tistdscreenprint)  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               bit15_12 = ((msw_data[site] & 0xf000)>>12) & 0x000f;
//               infreq = msw_data[site] & 0x0fff;
//               if(bit15_12==0)  
//                  cout << "Site " << site:-4 << " PLLENA <<  ARB FREQ == " << infreq);
//               else
//                  cout << "Site " << site:-4 << " PLLDIS <<  ARB FREQ == " << infreq)
//            } 
//      } 
//   } 
//}   /* TL_GetARBFREQ */
//
// /*wstate_autocalc=true  : internal calculate wstate based on selected freq*/
// /*wstate_autocalc=false : use value specify "wstate" param*/
// /*wstate_addr_ena=true  : enable addr wait state*/
// /*wstate_pipe_ena=true  : enable pipeline mode, false=normal mode*/
//void TL_SetARBWAIT(BoolS wstate_autocalc,
//                        IntS wstate,
//                        BoolS wstate_addr_ena,
//                        BoolS wstate_pipe_ena)
//{
//   IntS bit15_12,bit11_8,bit7_4,bit3_0;
//   IntS addr_loc,mdata,site;
//   IntM lsw_data,msw_data;
//   BoolS debugprint;
//
//   if(v_any_dev_active)  
//   {
//      if(wstate_autocalc)  
//         bit15_12 = 0x1000;
//      else
//         bit15_12 = 0x0000;
//
//      if(wstate > 0xf)  
//      {
//         bit11_8 = 0xf;
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid waitstate entered <<  truncated to 0xf !!!" << endl;
//      }
//      else
//      {
//         bit11_8 = wstate;
//      } 
//
//      if(wstate_addr_ena)  
//         bit7_4 = 0x0010;
//      else
//         bit7_4 = 0x0000;
//
//      if(wstate_pipe_ena)  
//         bit3_0 = 0x0001;
//      else
//         bit3_0 = 0x0000;
//
//      addr_loc = ADDR_RAM_ARB_FREQ;
//      GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_data);
//      mdata = bit15_12+(bit11_8<<8)+bit7_4+bit3_0;
//      lsw_data = mdata;
//      
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,true,msw_data,true,true);
//
//      if(tistdscreenprint and TI_FlashDebug)  
//      {
//         if(not wstate_autocalc)  
//            cout << "Set ARB WAITSTATE == " << bit11_8:s_hex:6 << 
//                    "  Addr WState Enable == " << wstate_addr_ena:-6 << 
//                    "  Pipeline Enable == " << wstate_pipe_ena:-6)
//         else
//            cout << "Internal Calc WSTATE " << 
//                    "  Addr WState Enable == " << wstate_addr_ena:-6 << 
//                    "  Pipeline Enable == " << wstate_pipe_ena:-6 << endl;
//      } 
//
//      debugprint = TIPrintPass and TI_FlashDebug;
//      if(debugprint and tistdscreenprint)  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               ReadRamAddress(site,addr_loc,addr_loc+ADDR_RAM_INC);
//      } 
//   } 
//}   /* TL_SetARBWAIT */
//
//void TL_GetARBWAIT()
//{
//   IntS bit15_12,bit11_8,bit7_4,bit3_0;
//   IntS addr_loc,mdata,site;
//   IntM lsw_data,msw_data;
//   BoolS intcalc,ws_addr_ena,ws_pipe_ena;
//   BoolS debugprint;
//
//   if(v_any_dev_active)  
//   {
//      addr_loc = ADDR_RAM_ARB_WAIT;
//      GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_data);
//
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            bit15_12 = ((lsw_data[site]&0xf000)>>12) & 0x0001;
//            bit11_8  = ((lsw_data[site]&0x0f00)>>8) & 0x000f;
//            bit7_4   = ((lsw_data[site]&0x00f0)>>4) & 0x0001;
//            bit3_0   = lsw_data[site]&0x0001;
//
//            if(bit15_12==0)  
//               intcalc = false;
//            else
//               intcalc = true;
//
//            if(bit7_4==0)  
//               ws_addr_ena = false;
//            else
//               ws_addr_ena = true;
//
//            if(bit3_0==0)  
//               ws_pipe_ena = false;
//            else
//               ws_pipe_ena = true;
//
//            if(tistdscreenprint)  
//               cout << "Site " << site:-5 << " Internal Calc WState == " << intcalc:-6 << 
//                       "  WaitState == " << bit11_8:s_hex:6 << 
//                       "  Addr WState Enable == " << ws_addr_ena:-6 << 
//                       "  Pipeline Enable == " << ws_pipe_ena << endl;
//         } 
//      
//      debugprint = false;
//      if(debugprint and tistdscreenprint)  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               ReadRamAddress(site,addr_loc,addr_loc);
//      } 
//   } 
//}   /* TL_GetARBWAIT */

void TL_SetArbAddr(IntS msw_addr,IntS lsw_addr) {
   IntM msw_data,lsw_data;
   BoolS hexvalue,bcd_format;
   IntS addr_loc;

   msw_data = msw_addr;
   lsw_data = lsw_addr;
   bcd_format = true;
   hexvalue = true;
   addr_loc = ADDR_RAM_ARB_TGADDR;
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

}   // TL_SetArbAddr
   
void TL_SetArbLength(IntS msw_length, IntS lsw_length) {
   IntM msw_data,lsw_data;
   BoolS hexvalue,bcd_format;
   IntS addr_loc;

   msw_data = msw_length;
   lsw_data = lsw_length;
   bcd_format = true;
   hexvalue = true;
   addr_loc = ADDR_RAM_ARB_TGLEN;
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
      
}   // TL_SetArbLength
   
// /*override prog set up time - default 0x14*/
//void TL_EngOvride_PSU(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x14; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_PSU;
//      if((ovr_data>==0) and (ovr_data<==0xff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_PSU */
//   
// /*override ers set up time - default 0x14*/
//void TL_EngOvride_ESU(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x14; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_ESU;
//      if((ovr_data>==0) and (ovr_data<==0xff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_ESU */
//   
//void TL_EngOvride_PVSU(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x19; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_PVSU;
//      if((ovr_data>==0) and (ovr_data<==0xff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_PVSU */
//
//void TL_EngOvride_EVSU(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x19; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_EVSU;
//      if((ovr_data>==0) and (ovr_data<==0xff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_EVSU */
//   
//void TL_EngOvride_RPTVSU(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x3; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_RPTVSU;
//      if((ovr_data>==0) and (ovr_data<==0xff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_RPTVSU */
//   
//void TL_EngOvride_CVSU(IntS ovr_data)
//{
//   const  DEFAULT_VAL = 0xff;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_CVSU;
//      if((ovr_data>==0) and (ovr_data<==0xff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}      /* TL_EngOvride_CVSU */
//   
//void TL_EngOvride_AEXEZSU(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x20; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_AEXEZSU;
//      if((ovr_data>==0) and (ovr_data<==0xff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_AEXEZSU */
//   
//void TL_EngOvride_PVACC(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x2; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_PVACC;
//      if((ovr_data>==0) and (ovr_data<==0xff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_PVACC */
//   
//void TL_EngOvride_PH(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x2; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_PH;
//      if((ovr_data>==0) and (ovr_data<==0xff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_PH */
//   
//void TL_EngOvride_EH(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x2; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_EH;
//      if((ovr_data>==0) and (ovr_data<==0xff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_EH */
//   
//void TL_EngOvride_RH(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x32; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_RH;
//      if((ovr_data>==0) and (ovr_data<==0xff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_RH */
//   
//void TL_EngOvride_PVH(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x2; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_PVH;
//      if((ovr_data>==0) and (ovr_data<==0xff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_PVH */
//   
//void TL_EngOvride_PVH2(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x2; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_PVH2;
//      if((ovr_data>==0) and (ovr_data<==0xff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_PVH2 */
//   
//void TL_EngOvride_PPW(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x8; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_PPW;
//      if((ovr_data>==0) and (ovr_data<==0xffff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_PPW */
//   
//void TL_EngOvride_EPW(IntS ovr_data)
//{
//   const IntS DEFAULT_VALHI = 0x0; 
//   const  DEFAULT_VAL = 0xFA0;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS OVRNUMWORD = 0x0200; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_EPWHI;
//      if((ovr_data>==0) and (ovr_data<==0xfffffff))  
//      {
//         spareint1 = (ovr_data&0x0fff0000) >> 16;
//         lsw_data = spareint1;
//      }
//      else
//         lsw_data = DEFAULT_VALHI;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_EPW;
//      if((ovr_data>==0) and (ovr_data<==0xfffffff))  
//      {
//         spareint1 = ovr_data&0x0000ffff;
//         lsw_data = spareint1;
//      }
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_EPW */
//   
//void TL_EngOvride_MAXPP(IntS ovr_data)
//{
//   const  DEFAULT_VAL = 0xC8;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_MAXPP;
//      if((ovr_data>==0) and (ovr_data<==0xffff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_MAXPP */
//   
//void TL_EngOvride_PPW_MAXPP(  IntS ovr_pw, IntS ovr_pp)
//{
//   const IntS DEFAULT_VAL = 0x8; 
//   const  DEFAULT_VAL_MAXPP = 0xC8;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS OVRNUMWORD = 0x0200; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_PPW;
//      if((ovr_pw>==0) and (ovr_pw<==0xffff))  
//         lsw_data = ovr_pw;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_MAXPP;
//      if((ovr_pp>==0) and (ovr_pp<==0xffff))  
//         lsw_data = ovr_pp;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_PPW_MAXPP */
//   
//void TL_EngOvride_MAXEP(IntS ovr_data)
//{
//   const  DEFAULT_VAL = 0x3E8;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_MAXEP;
//      if((ovr_data>==0) and (ovr_data<==0xffff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_MAXEP */
   
void TL_EngOvride_VHV_PG_CT(IntS ovr_data)
{
   const IntS DEFAULT_VAL = 0xDB;
   const IntS OVRNUMWORD = 0x0100; 
   const IntS MB_WRFLAG = 0x1234; 

   IntM msw_data,lsw_data;
   BoolS hexvalue,bcd_format;
   IntS addr_loc;

   bcd_format = true;
   hexvalue = true;
   addr_loc = ADDR_RAM_MAILBOX;
   msw_data = MB_WRFLAG;
   lsw_data = OVRNUMWORD;
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

   msw_data = OVRIND_VHV_PG_CT;
   if((ovr_data>=0) and (ovr_data<=0x1ff))  
      lsw_data = ovr_data;
   else
      lsw_data = DEFAULT_VAL;
   addr_loc = addr_loc+ADDR_RAM_INC;
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
}   /* TL_EngOvride_VHV_PG_CT */
   
//void TL_EngOvride_VHV_ER_CT(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x194; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc,j;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_VHV_ER_CT;
//#if $TV2_VHV_CT_SWIZZLE  
//      if((ovr_data>==0) and (ovr_data<==0x1ff))  
//     j = ((ovr_data&0x01f)<<4) + ((ovr_data&0x1e0)>>5) ; /*swizzle ct*/
//      else
//     j = ((DEFAULT_VAL&0x01f)<<4) + ((DEFAULT_VAL&0x1e0)>>5);  /*swizzle ct*/
//      lsw_data = j;
//#else
//      if((ovr_data>==0) and (ovr_data<==0x1ff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//#endif
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_VHV_ER_CT */
//   
//void TL_EngOvride_VHV_PV_CT(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x55; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_VHV_PV_CT;
//      if((ovr_data>==0) and (ovr_data<==0x1ff))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_VHV_PV_CT */
//   
//void TL_EngOvride_VCG2P5_CT(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x7; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_VCG2P5_CT;
//      if((ovr_data>==0) and (ovr_data<==0x1f))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_VCG2P5_CT */
//   
//void TL_EngOvride_VINH_CT(IntS ovr_data)
//{
//   const  DEFAULT_VAL = 0x1B;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_VINH_CT;
//      if((ovr_data>==0) and (ovr_data<==0x1f))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_VINH_CT */
//   
//void TL_EngOvride_VSL_CT(IntS ovr_data)
//{
//   const  DEFAULT_VAL = 0xA;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_VSL_CT;
//      if((ovr_data>==0) and (ovr_data<==0xf))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_VSL_CT */
//   
//void TL_EngOvride_VWL_CT(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x4; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_VWL_CT;
//      if((ovr_data>==0) and (ovr_data<==0x1f))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_VWL_CT */
   
void TL_EngOvride_VRD_CT(IntS ovr_data) {

   const IntS DEFAULT_VAL = 0xB;
   const IntS OVRNUMWORD = 0x0100; 
   const IntS MB_WRFLAG = 0x1234; 

   IntM msw_data,lsw_data;
   BoolS hexvalue,bcd_format;
   IntS addr_loc;

   bcd_format = true;
   hexvalue = true;
   addr_loc = ADDR_RAM_MAILBOX;
   msw_data = MB_WRFLAG;
   lsw_data = OVRNUMWORD;
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

   msw_data = OVRIND_VRD_CT;
   if ((ovr_data >= 0) and (ovr_data <= 0xf))  
      lsw_data = ovr_data;
   else
      lsw_data = DEFAULT_VAL;
   addr_loc = addr_loc+ADDR_RAM_INC;
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format); 
}   // TL_EngOvride_VRD_CT
   
//void TL_EngOvride_VSA5_CT(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x7; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_VSA5_CT;
//      if((ovr_data>==0) and (ovr_data<==0xf))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_VSA5_CT */
//
//void TL_EngOvride_RDM0_NMOS(IntS ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x7; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_RDM0_NMOS_RAT;
//      if((ovr_data>==0) and (ovr_data<==0x1f))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_RDM0_NMOS */
//
//void TL_EngOvride_VHV_ER_CT_MS(IntM ovr_data)
//{
//   const IntS DEFAULT_VAL = 0x194; 
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc,j,site;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_VHV_ER_CT;
//#if $TV2_VHV_CT_SWIZZLE  
//      if(TITestType==MP1)  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               lsw_data[site] = ((ovr_data[site]&0x01f)<<4) + ((ovr_data[site]&0x1e0)>>5);  /*swizzle ct*/
//      }
//      else
//      {
//         lsw_data = ovr_data;
//      } 
//#else
//      lsw_data = ovr_data;
//#endif
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_VHV_ER_CT_MS */
//   
// /*override ers max pulse limit, start ct, pulse per ct step, ers ct - multisites*/
//void TL_EngOvride_VHV_MAXEP_ESTART_ESTEP_CT(  IntM ovr_maxep, IntM ovr_startct, IntM ovr_estep, IntM ovr_ersct)
//{
//   const IntS DEFAULT_VAL = 0x194; 
//   const IntS OVRNUMWORD = 0x0400; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc,j,site;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_MAXEP;
//      lsw_data = ovr_maxep;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//      
//      msw_data = OVRIND_VHV_ESTART_CT;
//#if $TV2_VHV_CT_SWIZZLE  
//      if(TITestType==MP1)  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               lsw_data[site] = ((ovr_startct[site]&0x01f)<<4) + ((ovr_startct[site]&0x1e0)>>5);  /*swizzle ct*/
//      }
//      else
//      {
//         lsw_data = ovr_startct;
//      } 
//#else
//      lsw_data = ovr_startct;
//#endif
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_VHV_ESTEP;
//      lsw_data = ovr_estep;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//      
//      msw_data = OVRIND_VHV_ER_CT;
//#if $TV2_VHV_CT_SWIZZLE  
//      if(TITestType==MP1)  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               lsw_data[site] = ((ovr_ersct[site]&0x01f)<<4) + ((ovr_ersct[site]&0x1e0)>>5);  /*swizzle ct*/
//      }
//      else
//      {
//         lsw_data = ovr_ersct;
//      }          
//#else
//      lsw_data = ovr_ersct;
//#endif
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//      
//   } 
//}   /* TL_EngOvride_VHV_MAXEP_ESTART_ESTEP_CT */
//
// /*override read precharge and bank efuse bits*/
// /*ovr_rpcval=0-7*/
// /*ovr_efindex=32bits w/ each bit represent EF bit (but applicable to EF13-EF23 only)*/
// /*ovr_efindex bit order: MSB EF31=SADLY[2], EF30=SADLY[1], ..., EF1=NMOS[1], EF0=NMOS[0] LSB*/
// /*applicable bits are EF23 to EF13:  EF23=refbit HV protection, EF22=Increase PV SA timing, EF21=VRDBUF Disable,..., EF17=1.5xSA Timing, ... see bank docs*/
// /*ovr_efindex: 1=apply override, 0=no override*/
// /*ovr_efval: value to override either 1=soft blow efuse, 0=not blow efuse*/
// /*example:  ovr_rpcval =1 means override rd pc with setting of 1*/
// /*          ovr_efindex=0x0062_0000 means override bit EF22,EF21,EF17*/
// /*          ovr_efval  =0x0042_0000 means override with value of 1 for EF22,EF17, and value of 0 for EF21*/
//void TL_EngOvride_RPC_EF(IntS ovr_rpcval,
//                              IntS ovr_efindex,
//                              IntS ovr_efval)
//{
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//   const  EFMASK = 0x00FFE000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS EFSTART = 13; 
//   const IntS EFSTOP = 23; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS ovr_rpc,efindex,efval;
//   IntS addr_loc,numword,i,j,site;
//   IntS1D index(16),value(16);
//
//   if(v_any_dev_active)  
//   {
//      ovr_rpc = ovr_rpcval;
//      efindex = ovr_efindex & EFMASK;
//      efval   = ovr_efval & EFMASK;
//      numword = 0;
//      
//      for (i = EFSTART;i <= EFSTOP;i++)
//      {
//         if((efindex&(1<<i)) > 0)  
//         {
//            numword = numword+1;
//            switch(i) {
//              case 23 : index[numword] = OVRIND_OTP_HV_PROTECTION;
//              case 22 : index[numword] = OVRIND_INC_PV_SA_TIMING;
//              case 21 : index[numword] = OVRIND_DISABLE_VRDBUF;
//              case 20 : index[numword] = OVRIND_MASTER_REDUND_DISABLE;
//              case 19 : index[numword] = OVRIND_IGNORE_BU_RD_RATIO;  /*use efuse ratio for read*/
//              case 18 : index[numword] = OVRIND_COL_CHANGEABLE_IN_PGM;
//              case 17 : index[numword] = OVRIND_USE_1P5X_SA_TIMING;  /*increase all sa timings*/
//              case 16 : index[numword] = OVRIND_LPWMODE_NO_TB_SPLIT;
//              case 15 : index[numword] = OVRIND_OVRIDE_OTP_RATIO;  /*use efuse ratio for all modes*/
//              case 14 : index[numword] = OVRIND_ALL_RLBL_OFF;
//              case 13 : index[numword] = OVRIND_REFBIT_HV_PROTECTION;
//            }   /* case */
//            if(efval&(1<<i) > 0)  
//               value[numword] = 1;
//            else
//               value[numword] = 0;
//            if(tistdscreenprint and TI_FlashDebug)  
//               cout << "Override Efuse bit " << i:-4 << " value == " << value[numword]:-4 << endl;
//         }   /*if efindex*/
//      }   /*for i*/
//
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//
//      if(numword>0)  
//      {
//         j = (numword+1)<<8;
//         msw_data = MB_WRFLAG;
//         lsw_data = j;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         msw_data = OVRIND_RD_PRECHARGE;
//         lsw_data = ovr_rpc;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//         for (i = 1;i <= numword;i++)
//         {
//            addr_loc = addr_loc+ADDR_RAM_INC;
//            msw_data = index[i];
//            lsw_data = value[i];
//            WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         } 
//      }
//      else
//      {
//         msw_data = MB_WRFLAG;
//         lsw_data = OVRNUMWORD;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         msw_data = OVRIND_RD_PRECHARGE;
//         lsw_data = ovr_rpc;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//      } 
//      
//      if(tistdscreenprint and TI_FlashDebug)  
//      {
//         cout << "+++++ TL_EngOvride_RPC_EF +++++" << endl;
//         i = ADDR_RAM_MAILBOX;
//         j = i+((numword+2)*ADDR_RAM_INC);
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               readramaddress(site,i,j);
//      } 
//   } 
//}   /* TL_EngOvride_RPC_EF */
//
//void TL_EngOvride_BANK_EF(IntS ovr_efindex,
//                               IntS ovr_efval)
//{
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//   const  EFMASK = 0x00FFE000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS EFSTART = 13; 
//   const IntS EFSTOP = 23; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS ovr_rpc,efindex,efval;
//   IntS addr_loc,numword,i,j,site;
//   IntS1D index(16),value(16);
//
//   if(v_any_dev_active)  
//   {
//      efindex = ovr_efindex & EFMASK;
//      efval   = ovr_efval & EFMASK;
//      numword = 0;
//      
//      for (i = EFSTART;i <= EFSTOP;i++)
//      {
//         if((efindex&(1<<i)) > 0)  
//         {
//            numword = numword+1;
//            switch(i) {
//              case 23 : index[numword] = OVRIND_OTP_HV_PROTECTION;
//              case 22 : index[numword] = OVRIND_INC_PV_SA_TIMING;
//              case 21 : index[numword] = OVRIND_DISABLE_VRDBUF;
//              case 20 : index[numword] = OVRIND_MASTER_REDUND_DISABLE;
//              case 19 : index[numword] = OVRIND_IGNORE_BU_RD_RATIO;  /*use efuse ratio for read*/
//              case 18 : index[numword] = OVRIND_COL_CHANGEABLE_IN_PGM;
//              case 17 : index[numword] = OVRIND_USE_1P5X_SA_TIMING;  /*increase all sa timings*/
//              case 16 : index[numword] = OVRIND_LPWMODE_NO_TB_SPLIT;
//              case 15 : index[numword] = OVRIND_OVRIDE_OTP_RATIO;  /*use efuse ratio for all modes*/
//              case 14 : index[numword] = OVRIND_ALL_RLBL_OFF;
//              case 13 : index[numword] = OVRIND_REFBIT_HV_PROTECTION;
//            }   /* case */
//            if(efval&(1<<i) > 0)  
//               value[numword] = 1;
//            else
//               value[numword] = 0;
//            if(tistdscreenprint and TI_FlashDebug)  
//               cout << "Override Efuse bit " << i:-4 << " value == " << value[numword]:-4 << endl;
//         }   /*if efindex*/
//      }   /*for i*/
//
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//
//      if(numword>0)  
//      {
//         j = numword<<8;
//         msw_data = MB_WRFLAG;
//         lsw_data = j;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//         for (i = 1;i <= numword;i++)
//         {
//            addr_loc = addr_loc+ADDR_RAM_INC;
//            msw_data = index[i];
//            lsw_data = value[i];
//            WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         } 
//      }
//      else 
//      {
//         if(tistdscreenprint)  
//            cout << "None of Bank Efuse bit is selected for eng override" << endl;
//      } 
//      
//      if(tistdscreenprint and TI_FlashDebug)  
//      {
//         cout << "+++++ TL_EngOvride_BANK_EF +++++" << endl;
//         i = ADDR_RAM_MAILBOX;
//         j = i+((numword+2)*ADDR_RAM_INC);
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               readramaddress(site,i,j);
//      } 
//   } 
//}   /* TL_EngOvride_BANK_EF */
//
//void TL_EngOvride_BANK_EF22(IntS ovr_data)
//{
//   IntS ovr_efindex,ovr_efval;
//
//   if(v_any_dev_active)  
//   {
//      ovr_efindex = 0x00400000;
//      ovr_efval   = ovr_data<<22;
//      TL_EngOvride_BANK_EF(ovr_efindex,ovr_efval);
//   } 
//}   /* TL_EngOvride_BANK_EF22 */
//   
//void TL_EngOvride_BANK_EF17(IntS ovr_data)
//{
//   IntS ovr_efindex,ovr_efval;
//
//   if(v_any_dev_active)  
//   {
//      ovr_efindex = 0x00020000;
//      ovr_efval   = ovr_data<<17;
//      TL_EngOvride_BANK_EF(ovr_efindex,ovr_efval);
//   } 
//}   /* TL_EngOvride_BANK_EF17 */
//   
//void TL_EngOvride_BANK_EF22_17(  IntS ef22_val, IntS ef17_val)
//{
//   IntS ovr_efindex,ovr_efval;
//
//   if(v_any_dev_active)  
//   {
//      ovr_efindex = 0x00420000;
//      ovr_efval   = (ef22_val<<22) + (ef17_val<<17);
//      TL_EngOvride_BANK_EF(ovr_efindex,ovr_efval);
//   } 
//}   /* TL_EngOvride_BANK_EF22_17 */
//
//void TL_EngOvride_RDM0_NMOS_EF(IntS ovr_nmosval,
//                                    IntS ovr_efindex,
//                                    IntS ovr_efval)
//{
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//   const  EFMASK = 0x00FFE000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS EFSTART = 13; 
//   const IntS EFSTOP = 23; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS ovr_nmos,efindex,efval;
//   IntS addr_loc,numword,i,j,site;
//   IntS1D index(16),value(16);
//
//   if(v_any_dev_active)  
//   {
//      ovr_nmos = ovr_nmosval;
//      efindex = ovr_efindex & EFMASK;
//      efval   = ovr_efval & EFMASK;
//      numword = 0;
//      
//      for (i = EFSTART;i <= EFSTOP;i++)
//      {
//         if((efindex&(1<<i)) > 0)  
//         {
//            numword = numword+1;
//            switch(i) {
//              case 23 : index[numword] = OVRIND_OTP_HV_PROTECTION;
//              case 22 : index[numword] = OVRIND_INC_PV_SA_TIMING;
//              case 21 : index[numword] = OVRIND_DISABLE_VRDBUF;
//              case 20 : index[numword] = OVRIND_MASTER_REDUND_DISABLE;
//              case 19 : index[numword] = OVRIND_IGNORE_BU_RD_RATIO;  /*use efuse ratio for read*/
//              case 18 : index[numword] = OVRIND_COL_CHANGEABLE_IN_PGM;
//              case 17 : index[numword] = OVRIND_USE_1P5X_SA_TIMING;  /*increase all sa timings*/
//              case 16 : index[numword] = OVRIND_LPWMODE_NO_TB_SPLIT;
//              case 15 : index[numword] = OVRIND_OVRIDE_OTP_RATIO;  /*use efuse ratio for all modes*/
//              case 14 : index[numword] = OVRIND_ALL_RLBL_OFF;
//              case 13 : index[numword] = OVRIND_REFBIT_HV_PROTECTION;
//            }   /* case */
//            if(efval&(1<<i) > 0)  
//               value[numword] = 1;
//            else
//               value[numword] = 0;
//            if(tistdscreenprint and TI_FlashDebug)  
//               cout << "Override Efuse bit " << i:-4 << " value == " << value[numword]:-4 << endl;
//         }   /*if efindex*/
//      }   /*for i*/
//
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//
//      if(numword>0)  
//      {
//         j = (numword+1)<<8;
//         msw_data = MB_WRFLAG;
//         lsw_data = j;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         msw_data = OVRIND_RDM0_NMOS_RAT;
//         lsw_data = ovr_nmos;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//         for (i = 1;i <= numword;i++)
//         {
//            addr_loc = addr_loc+ADDR_RAM_INC;
//            msw_data = index[i];
//            lsw_data = value[i];
//            WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         } 
//      }
//      else
//      {
//         msw_data = MB_WRFLAG;
//         lsw_data = OVRNUMWORD;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         msw_data = OVRIND_RDM0_NMOS_RAT;
//         lsw_data = ovr_nmos;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//      } 
//      
//      if(tistdscreenprint and TI_FlashDebug)  
//      {
//         cout << "+++++ TL_EngOvride_RDM0_NMOS_EF +++++" << endl;
//         i = ADDR_RAM_MAILBOX;
//         j = i+((numword+2)*ADDR_RAM_INC);
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               readramaddress(site,i,j);
//      } 
//   } 
//} 
//
//void TL_EngOvride_RDM0_NMOS_EF_PVCT(IntS ovr_nmosval,
//                                         IntS ovr_efindex,
//                                         IntS ovr_efval,
//                                         IntS ovr_pvct)
//{
//   const IntS OVRNUMWORD = 0x0100; 
//   const IntS MB_WRFLAG = 0x1234; 
//   const  EFMASK = 0x00FFE000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS EFSTART = 13; 
//   const IntS EFSTOP = 23; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS ovr_nmos,efindex,efval,pvval;
//   IntS addr_loc,numword,i,j,site;
//   IntS1D index(16),value(16);
//
//   if(v_any_dev_active)  
//   {
//      ovr_nmos = ovr_nmosval;
//      efindex = ovr_efindex & EFMASK;
//      efval   = ovr_efval & EFMASK;
//      numword = 0;
//      pvval   = ovr_pvct;
//      
//      for (i = EFSTART;i <= EFSTOP;i++)
//      {
//         if((efindex&(1<<i)) > 0)  
//         {
//            numword = numword+1;
//            switch(i) {
//              case 23 : index[numword] = OVRIND_OTP_HV_PROTECTION;
//              case 22 : index[numword] = OVRIND_INC_PV_SA_TIMING;
//              case 21 : index[numword] = OVRIND_DISABLE_VRDBUF;
//              case 20 : index[numword] = OVRIND_MASTER_REDUND_DISABLE;
//              case 19 : index[numword] = OVRIND_IGNORE_BU_RD_RATIO;  /*use efuse ratio for read*/
//              case 18 : index[numword] = OVRIND_COL_CHANGEABLE_IN_PGM;
//              case 17 : index[numword] = OVRIND_USE_1P5X_SA_TIMING;  /*increase all sa timings*/
//              case 16 : index[numword] = OVRIND_LPWMODE_NO_TB_SPLIT;
//              case 15 : index[numword] = OVRIND_OVRIDE_OTP_RATIO;  /*use efuse ratio for all modes*/
//              case 14 : index[numword] = OVRIND_ALL_RLBL_OFF;
//              case 13 : index[numword] = OVRIND_REFBIT_HV_PROTECTION;
//            }   /* case */
//            if(efval&(1<<i) > 0)  
//               value[numword] = 1;
//            else
//               value[numword] = 0;
//            if(tistdscreenprint and TI_FlashDebug)  
//               cout << "Override Efuse bit " << i:-4 << " value == " << value[numword]:-4 << endl;
//         }   /*if efindex*/
//      }   /*for i*/
//
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//
//      if(numword>0)  
//      {
//         j = (numword+1)<<8;
//         msw_data = MB_WRFLAG;
//         lsw_data = j;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         msw_data = OVRIND_VHV_PV_CT;
//         lsw_data = pvval;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         msw_data = OVRIND_RDM0_NMOS_RAT;
//         lsw_data = ovr_nmos;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//         for (i = 1;i <= numword;i++)
//         {
//            addr_loc = addr_loc+ADDR_RAM_INC;
//            msw_data = index[i];
//            lsw_data = value[i];
//            WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         } 
//      }
//      else
//      {
//         msw_data = MB_WRFLAG;
//         lsw_data = OVRNUMWORD;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         msw_data = OVRIND_VHV_PV_CT;
//         lsw_data = pvval;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         msw_data = OVRIND_RDM0_NMOS_RAT;
//         lsw_data = ovr_nmos;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//      } 
//      
//      if(tistdscreenprint and TI_FlashDebug)  
//      {
//         cout << "+++++ TL_EngOvride_RDM0_NMOS_EF_PVCT +++++" << endl;
//         i = ADDR_RAM_MAILBOX;
//         j = i+((numword+2)*ADDR_RAM_INC);
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               readramaddress(site,i,j);
//      } 
//   } 
//} 
//
//void TL_EngOvride_RDM0_NMOS_PVCT(IntS ovr_data,
//                                      IntS ovr_pvct)
//{
//   const IntS DEFAULT_VAL = 0x7; 
//   const IntS OVRNUMWORD = 0x0200; 
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc;
//
//   if(v_any_dev_active)  
//   {
//      bcd_format = true;
//      hexvalue = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = OVRNUMWORD;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      msw_data = OVRIND_VHV_PV_CT;
//      lsw_data = ovr_pvct;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      msw_data = OVRIND_RDM0_NMOS_RAT;
//      if((ovr_data>==0) and (ovr_data<==0x1f))  
//         lsw_data = ovr_data;
//      else
//         lsw_data = DEFAULT_VAL;
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//   } 
//}   /* TL_EngOvride_RDM0_NMOS_PVCT */

void MBox_Upload_RCODE_PSA(IntS banknum,FlashCodeType code_type) {
   IntS site,length;
   IntS wr_flag_num;
   IntS numword,numword_max;
   IntM msw_data,lsw_data;
   IntS addr_loc,msw_val,lsw_val;
   BoolS bcd_format,hexvalue;

   if (tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ MBox_Upload_RCODE_PSA : " << code_type << " +++++" << endl;

   msw_val = F021_RunCode.BANK_START_ADDR_MSW[code_type][banknum];
   lsw_val = F021_RunCode.BANK_START_ADDR_LSW[code_type][banknum];
   TL_SetArbAddr(msw_val,lsw_val);
   
   msw_val = F021_RunCode.BANK_LEN_MSW[code_type][banknum];
   lsw_val = F021_RunCode.BANK_LEN_LSW[code_type][banknum];
   TL_SetArbLength(msw_val,lsw_val);

   bcd_format  = true;
   hexvalue    = true;
   wr_flag_num = 0x1234;
   numword_max = 2;
   addr_loc = ADDR_RAM_MAILBOX;
   
   // upload write flag (msw) and data length (lsw)
   msw_data = wr_flag_num;  // msword
   lsw_data = numword_max;  // lsword
   // upload to ram 32-bit write flag and data length
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
                            msw_data,hexvalue,bcd_format);
      
   addr_loc = addr_loc+ADDR_RAM_INC;
   msw_val = F021_RunCode.BANK_PSA_MSW[code_type][banknum];
   lsw_val = F021_RunCode.BANK_PSA_LSW[code_type][banknum];
   msw_data = msw_val;
   lsw_data = lsw_val;
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
   
}   // MBox_Upload_RCODE_PSA

void MBox_Upload_RCODE_PSA_VRD_CT(IntS banknum, FlashCodeType code_type, IntS ovr_data) {

   IntS site,length;
   IntS wr_flag_num;
   IntS numword,numword_max;
   IntM msw_data,lsw_data;
   IntS addr_loc,msw_val,lsw_val;
   BoolS bcd_format,hexvalue;

   if (tistdscreenprint and TI_FlashDebug) {
      cout << "+++++ MBox_Upload_RCODE_PSA : " << code_type;
      cout << " VRD CT == " << setw(5) << hex << ovr_data << " +++++" << endl;
   }   

   msw_val = F021_RunCode.BANK_START_ADDR_MSW[code_type][banknum];
   lsw_val = F021_RunCode.BANK_START_ADDR_LSW[code_type][banknum];
   TL_SetArbAddr(msw_val,lsw_val);
   
   msw_val = F021_RunCode.BANK_LEN_MSW[code_type][banknum];
   lsw_val = F021_RunCode.BANK_LEN_LSW[code_type][banknum];
   TL_SetArbLength(msw_val,lsw_val);

   bcd_format  = true;
   hexvalue    = true;
   wr_flag_num = 0x1234;
   numword_max = 0x0102;
   addr_loc = ADDR_RAM_MAILBOX;
   
   // upload write flag (msw) and data length (lsw)
   msw_data = wr_flag_num;  // msword
   lsw_data = numword_max;  // lsword
   // upload to ram 32-bit write flag and data length
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
                            msw_data,hexvalue,bcd_format);
      
   addr_loc = addr_loc+ADDR_RAM_INC;
   msw_val = F021_RunCode.BANK_PSA_MSW[code_type][banknum];
   lsw_val = F021_RunCode.BANK_PSA_LSW[code_type][banknum];
   msw_data = msw_val;
   lsw_data = lsw_val;
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
      
   addr_loc = addr_loc+ADDR_RAM_INC;
   msw_val = F021_RunCode.BANK_PSA_MSW[code_type][banknum];
   lsw_val = F021_RunCode.BANK_PSA_LSW[code_type][banknum];
   msw_data = OVRIND_VRD_CT;
   lsw_data = ovr_data;
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
}   // MBox_Upload_RCODE_PSA_VRD_CT

//void TL_CpuToBankWordAddr(IntS msw_cpuaddr,
//                               IntS lsw_cpuaddr)
//{
//   const  B2_ECC_START = 0xF0100000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B2_ECC_STOP = 0xF01FFFFF;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B0_ECC_START = 0xF0400000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B1_ECC_START = 0xF0410000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS B0_START = 0x08000000; 
//   const IntS B1_START = 0x08080000; 
//   const  B2_START = 0xF0200000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B2_ECC_START_MSW = 0xF010;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B2_ECC_STOP_MSW = 0xF01F;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B0_ECC_START_MSW = 0xF040;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B1_ECC_START_MSW = 0xF041;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  BITMASKECC = 0x000FFFFF;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  BITMASKMAIN = 0xFFFFFFF0;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  BITMASKBYTE = 0x0000000F;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS MULTFACTOR = 8; 
//
//   IntS addr,bank_addr,byte_addr;
//   BoolS eccbank;
//
//   addr = ((msw_cpuaddr<<16)&0xffff0000) + lsw_cpuaddr;
//
//   if((msw_cpuaddr>==B2_ECC_START_MSW) and (msw_cpuaddr<==B2_ECC_STOP_MSW))  
//   {
//       /*bank2 ecc*/
//      bank_addr = B2_START + ((addr&BITMASKECC)*MULTFACTOR);
//      eccbank = true;
//   }
//   else if(msw_cpuaddr>==B0_ECC_START_MSW)  
//   {
//       /*b0/b1 ecc*/
//      bank_addr = B0_START + ((addr&BITMASKECC)*MULTFACTOR);
//      eccbank = true;
//   }
//   else
//   {
//       /*main*/
//      bank_addr = addr&BITMASKMAIN;
//      byte_addr = addr&BITMASKBYTE;
//      eccbank = false;
//   } 
//
//   if(tistdscreenprint)  
//   {
//      cout << "MSW_CPUADDR  == " << msw_cpuaddr:s_hex:-8 << " LSW_CPUADDR == " << lsw_cpuaddr:s_hex:-8 << endl;
//      if(eccbank)  
//         cout << "ECC BankWordADDR == " << bank_addr:s_hex:-16);
//      else
//         cout << "Main BankWordADDR == " << bank_addr:s_hex:-16 << " ByteADDR == " << byte_addr:s_hex:-5 << endl;
//   } 
//}   /* TL_CpuToBankWordAddr */
//
//void TL_Get_SenAmp_From_CpuAddrData(  IntS msw_cpuaddr, IntS lsw_cpuaddr,
//                                           IntS msw_fdata, IntS lsw_fdata,
//                                             IntS SenAmpNum)
//{
//   const  B2_ECC_START = 0xF0100000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B2_ECC_STOP = 0xF01FFFFF;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B0_ECC_START = 0xF0400000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B1_ECC_START = 0xF0410000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS B0_START = 0x08000000; 
//   const IntS B1_START = 0x08080000; 
//   const  B2_START = 0xF0200000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B2_ECC_START_MSW = 0xF010;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B2_ECC_STOP_MSW = 0xF01F;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B0_ECC_START_MSW = 0xF040;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B1_ECC_START_MSW = 0xF041;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  BITMASKECC = 0x000FFFFF;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  BITMASKMAIN = 0xFFFFFFF0;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  BITMASKBYTE = 0x0000000F;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS MULTFACTOR = 8; 
//
//   IntS addr,bank_addr,byte_addr;
//   IntS bitpos,senamp,fdata;
//   IntS cpuwordoff;
//   FloatS bitposFloatS,fdataFloatS;
//   BoolS eccbank;
//
//   addr = ((msw_cpuaddr<<16)&0xffff0000) + lsw_cpuaddr;
//   if(tistdscreenprint and TI_FlashDebug)  
//      cout << "cpu addr == " << addr:s_hex << endl;
//   
//   if((msw_cpuaddr>==B2_ECC_START_MSW) and (msw_cpuaddr<==B2_ECC_STOP_MSW))  
//   {
//       /*bank2 ecc*/
//      bank_addr = B2_START + ((addr&BITMASKECC)*MULTFACTOR);
//      eccbank = true;
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "Bank2 ECC <<  bank_addr == " << bank_addr:s_hex << endl;
//   }
//   else if(msw_cpuaddr>==B0_ECC_START_MSW)  
//   {
//       /*b0/b1 ecc*/
//      bank_addr = B0_START + ((addr&BITMASKECC)*MULTFACTOR);
//      eccbank = true;
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "Bank0/1 ECC <<  bank_addr == " << bank_addr:s_hex << endl;
//   }
//   else
//   {
//       /*main*/
//      bank_addr = addr&BITMASKMAIN;
//      byte_addr = addr&BITMASKBYTE;
//      eccbank = false;
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "Bank0/1/2 Main <<  bank_addr == " << bank_addr:s_hex:-12 << " byte_addr == " << byte_addr:s_hex << endl;
//   } 
//
//    /*bit position = log2(fdata)*/
//   fdata = ((msw_fdata<<16)&0xffff0000) + lsw_fdata;
//   if(msw_fdata != 0)  
//   {
//      fdatareal = msw_fdata;
//      bitposreal = (ln(fdatareal) / ln(2))+16;
//   }
//   else
//   {
//      if(lsw_fdata==0)  
//         if(tistdscreenprint)  
//            cout << "*** Warning: fail data is all 0s <<  invalid result ***" << endl;
//      fdatareal = lsw_fdata;
//      bitposreal = ln(fdatareal) / ln(2);
//   } 
//   bitpos = trunc(bitposreal);
//
//   if(tistdscreenprint and TI_FlashDebug)  
//      cout << "FData == " << fdata:s_hex:-12 << " bitposreal == " << bitposreal << "  bitpos == " << bitpos << endl;
//
//   if(eccbank)  
//   {
//      if(bitpos>==8)  
//         senamp = bitpos-8;
//      else
//         senamp = bitpos+136;
//   }
//   else
//   {
//      cpuwordoff = byte_addr>>2;  /*offset from start bank word*/
//      senamp = 8 + (cpuwordoff*32) + bitpos;   /*sense amp data starts at 8 for main array*/
//   } 
//
//   SenAmpNum = senamp;  /*return 1st encountered sense amp from failing data*/
//
//   if(tistdscreenprint)  
//   {
//      cout << "MSW_CPUADDR  == " << msw_cpuaddr:s_hex:-8 << " LSW_CPUADDR == " << lsw_cpuaddr:s_hex:-8 << 
//                       "MSW_FDATA == " << msw_fdata:s_hex:-8 << " LSW_FDATA == " << lsw_fdata:s_hex:-8 << endl;
//      if(eccbank)  
//         cout << "ECC BankWordADDR == " << bank_addr:s_hex:-16);
//      else
//         cout << "Main BankWordADDR == " << bank_addr:s_hex:-16 << " ByteADDR == " << byte_addr:s_hex:-5;
//      cout << "  SenAmpNum == " << senamp:-5 << endl;
//      cout << endl;
//   } 
//}   /* TL_Get_SenAmp_From_CpuAddrData */
//
//void TL_Get_SenAmp_From_CpuAddrData_MS(      IntM msw_cpuaddr, IntM lsw_cpuaddr,
//                                              IntM msw_fdata, IntM lsw_fdata,
//                                                  IntM msw_mainaddr, IntM lsw_mainaddr,
//                                                IntM SenAmpNum)
//{
//   const  B2_ECC_START = 0xF0100000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B2_ECC_STOP = 0xF01FFFFF;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B0_ECC_START = 0xF0400000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B1_ECC_START = 0xF0410000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS B0_START = 0x08000000; 
//   const IntS B1_START = 0x08080000; 
//   const  B2_START = 0xF0200000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B2_ECC_START_MSW = 0xF010;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B2_ECC_STOP_MSW = 0xF01F;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B0_ECC_START_MSW = 0xF040;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  B1_ECC_START_MSW = 0xF041;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  BITMASKECC = 0x000FFFFF;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  BITMASKMAIN = 0xFFFFFFF0;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  BITMASKBYTE = 0x0000000F;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS MULTFACTOR = 8; 
//
//   IntS addr,bank_addr,byte_addr;
//   IntS bitpos,senamp,fdata;
//   IntS cpuwordoff,site;
//   FloatS bitposFloatS,fdataFloatS;
//   BoolS eccbank;
//
//   if(v_any_dev_active)  
//   {
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      {
//         if(v_dev_active[site])  
//         {
//            addr = ((msw_cpuaddr[site]<<16)&0xffff0000) + lsw_cpuaddr[site];
//            if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//               cout << "Site" << site:-4 << " cpu addr == " << addr:s_hex << endl;
//            
//            if((msw_cpuaddr[site]>==B2_ECC_START_MSW) and (msw_cpuaddr[site]<==B2_ECC_STOP_MSW))  
//            {
//                /*bank2 ecc*/
//               bank_addr = B2_START + ((addr&BITMASKECC)*MULTFACTOR);
//               eccbank = true;
//               if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//                  cout << "Bank2 ECC <<  bank_addr == " << bank_addr:s_hex << endl;
//            }
//            else if(msw_cpuaddr[site]>==B0_ECC_START_MSW)  
//            {
//                /*b0/b1 ecc*/
//               bank_addr = B0_START + ((addr&BITMASKECC)*MULTFACTOR);
//               eccbank = true;
//               if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//                  cout << "Bank0/1 ECC <<  bank_addr == " << bank_addr:s_hex << endl;
//            }
//            else
//            {
//                /*b0/b1/b2 main*/
//               bank_addr = addr&BITMASKMAIN;
//               byte_addr = addr&BITMASKBYTE;
//               eccbank = false;
//               if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//                  cout << "Bank0/1/2 Main <<  bank_addr == " << bank_addr:s_hex:-12 << " byte_addr == " << byte_addr:s_hex << endl;
//            } 
//            
//             /*bit position = log2(fdata)*/
//            fdata = ((msw_fdata[site]<<16)&0xffff0000) + lsw_fdata[site];
//            if(msw_fdata[site] != 0)  
//            {
//               fdatareal = msw_fdata[site];
//               bitposreal = (ln(fdatareal) / ln(2))+16;
//            }
//            else
//            {
//               if(lsw_fdata[site]==0)  
//                  if(tistdscreenprint)  
//                     cout << "*** Warning: fail data is all 0s <<  invalid result ***" << endl;
//               fdatareal = lsw_fdata[site];
//               bitposreal = ln(fdatareal) / ln(2);
//            } 
//            bitpos = trunc(bitposreal);
//            
//            if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//               cout << "FData == " << fdata:s_hex:-12 << " bitposreal == " << bitposreal << "  bitpos == " << bitpos << endl;
//            
//            if(eccbank)  
//            {
//               if(bitpos>==8)  
//                  senamp = bitpos-8;
//               else
//                  senamp = bitpos+136;
//            }
//            else
//            {
//               cpuwordoff = byte_addr>>2;  /*offset from start bank word*/
//               senamp = 8 + (cpuwordoff*32) + bitpos;   /*sense amp data starts at 8 for main array*/
//            } 
//
//            msw_mainaddr[site] = ((bank_addr&0xFFFF0000) >>16) & 0xFFFF;
//            lsw_mainaddr[site] = bank_addr&0x0000FFFF;
//            SenAmpNum[site] = senamp;  /*return 1st encountered sense amp from failing data*/
//            
//            if(tistdscreenprint and TI_FlashDebug)  
//            {
//               cout << "Site" << site:-4 << "MSW_CPUADDR  == " << msw_cpuaddr[site]:s_hex:-8 << " LSW_CPUADDR == " << lsw_cpuaddr[site]:s_hex:-8 << 
//                       "MSW_FDATA == " << msw_fdata[site]:s_hex:-8 << " LSW_FDATA == " << lsw_fdata[site]:s_hex:-8 << endl;
//               if(eccbank)  
//                  cout << "ECC BankWordADDR == " << bank_addr:s_hex:-16);
//               else
//                  cout << "Main BankWordADDR == " << bank_addr:s_hex:-16 << " ByteADDR == " << byte_addr:s_hex:-5;
//               cout << "  SenAmpNum == " << SenAmpNum[site]:-5 << endl;
//               cout << endl;
//            } 
//         }   /*v_dev_active*/
//      }   /*for site*/
//   }   /*v_any_dev_active*/
//}   /* TL_Get_SenAmp_From_CpuAddrData_MS */
//   
//void TL_Get_PhysSenAmp_From_ESDA_WorstBit(    IntS test_site,
//                                                   IntS PhysSenAmp,
//                                                   IntS MBoxWdIndex,
//                                                   IntS MBoxBitIndex)
//{
//   IntS site,senamp,numword_max,dbit;
//   IntS wdindex,bitpos,i,j,k;
//   BoolS foundbit;
//
//   switch(F021_Flash.DATAWIDTH) {
//     case 64  : numword_max = 4;
//     case 144 : numword_max = 9;
//     case 288 : numword_max = 18;
//     default: numword_max = 9;
//   }   /* case */
//
//   senamp = 0;
//   bitpos = 0;
//   foundbit = false;
//   site = test_site;
//
//   for (i = 0;i <= (numword_max-1);i++)
//   {
//      dbit = FL_WORSTBIT_FDATA[i+2][site];   /*FL_WORSTBIT_FDATA[1..10], skip dummy 1st word from esda data so [i+2]*/
//      if(dbit != 0)  
//      {
//         wdindex = i;  /*as appears in esda word index*/
//         for (j = 15;j >= 0;--j)
//         {
//            k = (dbit & (1<<j)) >>j;
//            if(k==1)  
//            {
//               bitpos = j;
//               foundbit = true;
//            } 
//         }   /*for j*/
//         foundbit = true;
//      }   /*dbit<>0*/
//      if(foundbit)  
//         break;
//   }   /*for i*/
//
//   if(numword_max==9)  
//   {
//      switch(wdindex) {
//        case 0 :  
//               if(bitpos<==7)  
//                  senamp = 136+bitpos;
//               else
//                  senamp = bitpos-8;
//             break; 
//        default:  
//           senamp = (120-((wdindex-1)*16))+bitpos;
//         break;            
//      }   /* case */
//      PhysSenAmp = senamp;
//      MBoxWdIndex = wdindex;
//      MBoxBitIndex = bitpos;
//   }
//   else
//   {
//       /*need to expand for other datawidth*/
//   } 
//} 


// Not converting this. It is the same, effectively, as F021_RunTestNumber_PMEX
// except the pattern is tested and the pass pin is tested. When we get MatchVector
// fixed, we will be testing pattern and I will add switch into _PMEX to allow
// testing the pass pin.  - JT
//BoolS F021_MatchLoopByPMU_MS(    StringS tpatt,
//                                    PinML pass_pin,
//                                    PinML done_pin,
//                                    PinML ndone_pin,
//                                    FloatS max_timeout,
//                                    IntS pmstop,
//                                    FloatM ret_timer,
//                                    BoolM test_results)
//{
////   FloatS ttimer1, ttimer2;
////   BoolM savestates;
////   BoolS result;
////   BoolM init_results;
////   BoolM done_results;
////   BoolM ndone_results;
////   BoolM pass_results;
////   BoolM tmp_results;
////   FloatS tdelay;
////   IntS tmpint;
////   IntS site;
////   BoolS debugprint;
////   option databit_1, databit_2, databit_3;
////   option config_1, config_2, config_3;
////   BoolS drv_1, drv_2, drv_3;
////   BoolS load_1, load_2, load_3;
////   BoolS pmu_1, pmu_2, pmu_3;
////   BoolS upmu_1, upmu_2, upmu_3;
////   BoolS statmask_1, statmask_2, statmask_3;
////   BoolM time_logged;
//
//   debugprint = TI_FlashDebug and TIIgnoreFail;
//   tdelay = 100us;
//   timernstart(ttimer1);
//
//   savestates = v_dev_active;
//   test_results = true;
//   time_logged = false;
////   DCconnectGet(nporrst,databit_1,config_1,drv_1,load_1,pmu_1,upmu_1,
////                statmask_1);
////
////   Enable(S_PMEXIT);
////   PMEXSetDelay(S_PFlags,pmstop);
//   if (using_pattern_match) 
//   {
//      test_results = DIGITAL.TestPattern(f021_shell_exepat, true);
//   } 
//   else if (using_external_match)// using external match with sync clock or cpu loop in pattern
//   {
//      DIGITAL.ExecutePattern(f021_shell_exepat);
//      DIGITAL.SetDriveMode(nporrst, DIGITAL_DRV_MODE_OFF);
//      DIGITAL.SetLoadMode(nporrst, DIGITAL_LD_MODE_OFF);
//      DIGITAL.Connect(nporrst, DIGITAL_DCL_TO_DUT);
//
//   // what all does vlct dcconnect do?
//      DIGITAL.SetDriveMode(F021_DONEPIN, DIGITAL_DRV_MODE_OFF);
//      DIGITAL.SetLoadMode(F021_DONEPIN, DIGITAL_LD_MODE_OFF);
//      DIGITAL.Connect(F021_DONEPIN, DIGITAL_DCL_TO_DUT);
//      DIGITAL.SetDriveMode(F021_NDONEPIN, DIGITAL_DRV_MODE_OFF);
//      DIGITAL.SetLoadMode(F021_NDONEPIN, DIGITAL_LD_MODE_OFF);
//      DIGITAL.Connect(F021_NDONEPIN, DIGITAL_DCL_TO_DUT);
//      
//      TIME.Wait(tdelay);
//      done = false;
//      timer2_start = TIME.GetTimer();
//
//      while((!done) && ((TIME.GetTimer() - timer2_start)<maxtime))
//      {      
//         done_results = DIGITAL.TestCompareState(F021_DONEPIN, DIGITAL_CMP_STATE_HIGH);
//         test_results = done_results; // forget the history to remove past fails
//         ndone_results = DIGITAL.TestCompareState(F021_NDONEPIN, DIGITAL_CMP_STATE_LOW);
//         test_results = DLOG.AccumulateResults(test_results, ndone_results);
//
//          /*KChau 02/08/10 - removed passpin strobe on param tests*/
//          /*if(TI_FlashDebug) then
//             discard(CompareGet(F021_PASSPIN));*/
//
//         done = (test_results == TM_PASS);  // done will only be true if all sites passed
//         if (!done)
//         {
//            TIME.Wait(tdelay);
//         }
//      }   /*while*/
//   } else if (using_fail_flag) {
//      DIGITAL.ExecutePattern(f021_shell_exepat);
//      
//      TIME.Wait(tdelay);
//      done = false;
//      timer2_start = TIME.GetTimer();
//
//      while((!done) && ((TIME.GetTimer() - timer2_start)<maxtime))
//      {      
//         DIGITAL.ReadFlag(F021_DONEPIN, DIGITAL_FLAG_FAIL, done_value, true);
//         DIGITAL.ReadFlag(F021_NDONEPIN, DIGITAL_FLAG_FAIL, ndone_value, true);
//         if (!((done_value == true) && (ndone_value == true))) // true is a fail and that's what we're looking for, pattern strobes low
//         // above will be true unless all sites are done
//         {
//            TIME.Wait(tdelay);
////            cout << "waiting on donepin" << endl;
//         } else {
//            done = true;
//         }
//      }   /*while*/
//      // check for results
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      {
//         if (done_value[*si])
//            done_results[*si] = TM_PASS;
//         else
//            done_results[*si] = TM_FAIL;
//         
//         if (ndone_value[*si])
//            ndone_results[*si] = TM_PASS;
//         else
//            ndone_results[*si] = TM_FAIL;
//            
//      }
//      test_results = done_results;
//      test_results = DLOG.AccumulateResults(test_results, ndone_results);
//      
//   } else if (using_long_repeat) {
//      DIGITAL.ExecutePattern(f021_shell_exepat);
//      test_results = TM_PASS; // just force a pass...this is debug :TODO: Remove this after debug
//   }
//   
//   if (using_cpu_loop) // let's end the loop
//   {
//      DIGITAL.SetFlag(DIGITAL_FLAG_CPU, false);
//   } 
//
//   Patternexecute(tmpint,tpatt);
//   ArrayAndBoolean(init_results,v_pf_status,v_dev_active,v_sites);
////   dcconnect(nporrst,s_high,s_ldoff);
//   if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//   {
//      cout << "F021_MatchLoopByPMU LOAD  ";
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      {
//         if(v_dev_active[site])  
//         {
//            if(init_results[site])  
//               cout << "  /  ");
//            else
//               cout << "  X  ";
//         }
//         else
//            cout << "  X  ";
//      }   /*for site*/
//      cout << endl;
//   } 
//            
//   if((not tiignorefail) and (not TI_FlashCOFEna))  
//      DevSetHoldStates(init_results);   /*de-activate failing site*/
//
//   if(V_any_dev_active)  
//   {         
//      DCConnect(done_pin,S_High,S_ldoff);  /*strobe hi*/
//      DCConnect(ndone_pin,S_Low,S_ldoff);  /*strobe low*/
//      DCConnect(pass_pin,s_High,s_ldoff);  /*strobe hi*/
//      TIME.Wait(5ms);
//      result = false;
//      timernstart(ttimer2);
//
//      while((not result) and (timernread(ttimer2)<max_timeout)) do
//      {
//         VoltageCompareOpt(S_DATA);
//         
//         CompareGet(done_pin);
//         done_results = v_pf_status;
//         CompareGet(ndone_pin);
//         ndone_results = v_pf_status;
//         ArrayAndBoolean(tmp_results,done_results,ndone_results,v_sites);
//         result = ArrayCompareBoolean(tmp_results,v_dev_active,v_sites);
//
//          /*record time for done site*/
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site] and tmp_results[site] and
//               (not time_logged[site]))  
//            {
//               ret_timer[site] = timernread(ttimer1);
//               time_logged[site] = true;
//            } 
//         TIME.Wait(tdelay);
//      }   /*while*/
//
//      CompareGet(pass_pin);
//      pass_results = v_pf_status;
//
//       /*record time for time-out site*/
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site] and (not time_logged[site]))  
//         {
//            ret_timer[site] = timernread(ttimer1);
//            time_logged[site] = true;
//         } 
//
//      if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//      {
//         cout << "        " << "DONE (1)":10 << "  " << "NDONE (0)":10 << "  " << 
//                 "PASS (1)" << endl;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if V_dev_active[site]  
//               cout << "Site " << site:2 << "  " << done_results[site]:10 << 
//                       "  " << ndone_results[site]:10 << "  " << pass_results[site] << endl;
//      } 
//      
//      ArrayAndBoolean(tmp_results,tmp_results,pass_results,v_sites);
//      ArrayAndBoolean(test_results,tmp_results,init_results,v_sites);
//      
//      if(tistdscreenprint and debugprint)  
//         cout << "EXEC TT " << timernread(ttimer2) << endl;
//      
//      Disable(s_pmexit);
//
//      if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//      {
//         cout << "MatchLoopByPMU EXEC ";
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         {
//            if(v_dev_active[site])  
//            {
//               if(test_results[site])  
//                  cout << "  /  ");
//               else
//                  cout << "  X  ";
//            }
//            else
//               cout << "  X  ";
//         }   /*for site*/
//         cout << endl;
//      }   /*if tistdscreenprint*/
//
//   if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//      cout << "MatchLoopByPMU TT : " << timernread(ttimer1) << endl;
//
//   Devsetholdstates(savestates);
//   DCConnect(nporrst,databit_1,config_1);
//   Clockstopfreerun(s_clock1a);
//   F021_MatchLoopByPMU_MS = v_any_dev_active;
//}   /* F021_MatchLoopByPMU_MS */

//BoolS F021_MatchLoopByPMU_MS_loader(    StringS tpatt,
//                                    PinML pass_pin,
//                                    PinML done_pin,
//                                    PinML ndone_pin,
//                                    FloatS max_timeout,
//                                    IntS pmstop,
//                                    FloatM ret_timer,
//                                    BoolM test_results)
//{
//   FloatS ttimer1, ttimer2;
//   BoolM savestates;
//   BoolS result;
//   BoolM init_results;
//   BoolM done_results;
//   BoolM ndone_results;
//   BoolM pass_results;
//   BoolM tmp_results;
//   FloatS tdelay;
//   IntS tmpint;
//   IntS site;
//   BoolS debugprint;
//   option databit_1, databit_2, databit_3;
//   option config_1, config_2, config_3;
//   BoolS drv_1, drv_2, drv_3;
//   BoolS load_1, load_2, load_3;
//   BoolS pmu_1, pmu_2, pmu_3;
//   BoolS upmu_1, upmu_2, upmu_3;
//   BoolS statmask_1, statmask_2, statmask_3;
//   BoolM time_logged;
//
//   if(V_any_dev_active)  
//   {
//      debugprint = TI_FlashDebug and TIIgnoreFail;
//      tdelay = 1us;
//      timernstart(ttimer1);
//
//      savestates = v_dev_active;
//      test_results = true;
//      time_logged = false;
//      DCconnectGet(nporrst,databit_1,config_1,drv_1,load_1,pmu_1,upmu_1,
//                   statmask_1);
// /*
//       DCconnectGet(pass_pin,databit_1,config_1,drv_1,load_1,pmu_1,upmu_1,
//                    statmask_1);
//       DCconnectGet(done_pin,databit_2,config_2,drv_2,load_2,pmu_2,upmu_2,
//                    statmask_2);
//       DCconnectGet(ndone_pin,databit_3,config_3,drv_3,load_3,pmu_3,upmu_3,
//                    statmask_3);
// */
//      Enable(S_PMEXIT);
//      PMEXSetDelay(S_PFlags,pmstop);
//      Patternexecute(tmpint,tpatt);
//      ArrayAndBoolean(init_results,v_pf_status,v_dev_active,v_sites);
//      dcconnect(nporrst,s_high,s_ldoff);
//      if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//      {
//         cout << "F021_MatchLoopByPMU LOAD  ";
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         {
//            if(v_dev_active[site])  
//            {
//               if(init_results[site])  
//                  cout << "  /  ");
//               else
//                  cout << "  X  ";
//            }
//            else
//               cout << "  X  ";
//         }   /*for site*/
//         cout << endl;
//      } 
//               
//      if((not tiignorefail) and (not TI_FlashCOFEna))  
//         DevSetHoldStates(init_results);   /*de-activate failing site*/
//
//      if(V_any_dev_active)  
//      {         
//         /* DCConnect(done_pin,S_High,S_ldoff); {strobe hi}*/
//         DCConnect(ndone_pin,S_Low,S_ldoff);  /*strobe low*/
//         DCConnect(pass_pin,s_High,s_ldoff);  /*strobe hi*/
//         TIME.Wait(5ms);
//         result = false;
//         timernstart(ttimer2);
//
//         while((not result) and (timernread(ttimer2)<max_timeout)) do
//         {
//            VoltageCompareOpt(S_DATA);
//            
//            /* discard(CompareGet(done_pin));
//             ArrayCopyBoolean(done_results,v_pf_status,v_sites);*/
//            CompareGet(ndone_pin);
//            tmp_results = v_pf_status;
//            /* ArrayAndBoolean(tmp_results,done_results,ndone_results,v_sites);*/
//            result = ArrayCompareBoolean(tmp_results,v_dev_active,v_sites);
//
//             /*record time for done site*/
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site] and tmp_results[site] and
//                  (not time_logged[site]))  
//               {
//                  ret_timer[site] = timernread(ttimer1);
//                  time_logged[site] = true;
//               } 
//            TIME.Wait(tdelay);
//         }   /*while*/
//
//         CompareGet(pass_pin);
//         pass_results = v_pf_status;
//
//          /*record time for time-out site*/
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site] and (not time_logged[site]))  
//            {
//               ret_timer[site] = timernread(ttimer1);
//               time_logged[site] = true;
//            } 
//
//         if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//         {
//            cout << "        " << "DONE (1)":10 << "  " << "PASS (1)" << endl;
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if V_dev_active[site]  
//                  cout << "Site " << site:2 << "  " << ndone_results[site]:10 << "  " << 
//          pass_results[site] << endl;
//         } 
//         
//         ArrayAndBoolean(tmp_results,tmp_results,pass_results,v_sites);
//         ArrayAndBoolean(test_results,tmp_results,init_results,v_sites);
//         
//         if(tistdscreenprint and debugprint)  
//            cout << "EXEC TT " << timernread(ttimer2) << endl;
//         
//         Disable(s_pmexit);
//
//         if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//         {
//            cout << "MatchLoopByPMU EXEC ";
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            {
//               if(v_dev_active[site])  
//               {
//                  if(test_results[site])  
//                     cout << "  /  ");
//                  else
//                     cout << "  X  ";
//               }
//               else
//                  cout << "  X  ";
//            }   /*for site*/
//            cout << endl;
//         }   /*if tistdscreenprint*/
//
// /*         DCConnect(nporrst,databit_1,config_1);*/
// /*
//          DCConnect(pass_pin,databit_1,config_1);
//          DCConnect(done_pin,databit_2,config_2);
//          DCConnect(ndone_pin,databit_3,config_3);
//         */
//      }   /*if v_any_dev_active*/
//
//      if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//         cout << "MatchLoopByPMU_loader TT : " << timernread(ttimer1) << endl;
//
//   }   /*if v_any_dev_active*/
//   Devsetholdstates(savestates);
//   DCConnect(nporrst,databit_1,config_1);
//   F021_MatchLoopByPMU_MS_loader = v_any_dev_active;
//}   /* F021_MatchLoopByPMU_MS_loader */

 /*Set flash test number via RAM PMT*/
void F021_SetTestNum(IntS testnum)
{
   StringS bitlabel;
   StringS strhi,strlo;
   IntS offsetcyc,length;
   IntS tnumhi,tnumlo;
   IntS strlength;
   PinML data_pins;
   StringS tpatt;
   
#if ($GL_USE_JTAG_RAMPMT || $GL_USE_DMLED_RAMPMT)
   IntS maxsrccount,maskbit,maxiter;
   IntS eindex,mindex,hindex,shiftbit;
   BoolS SaveMemSetBistData;
#endif

   strlength = 16;  /*16-bit length data string*/
   offsetcyc = 0;
//   bitlabel = f021_shell_exepat_name + ".MOD_TESTNUM";
   bitlabel = PatternBurst(f021_shell_exepat).GetPattern(0).GetName() + ".MOD_TESTNUM";

   tnumhi = ((int(testnum) & 0xffff0000) >> 16) & 0x0000ffff;
   tnumlo = testnum & 0x0000ffff;
   
   strhi = IntToVLSIDriveStr(tnumhi, strlength, true); //nibbles are msb to lsb w/ pin ordering
   strlo = IntToVLSIDriveStr(tnumlo, strlength, true); //nibbles are msb to lsb w/ pin ordering

#if $GL_USE_JTAG_RAMPMT || $GL_USE_DMLED_RAMPMT  
#if $GL_USE_JTAG_RAMPMT  
    /*lsb 1st - msb last*/
   data_pins = "JTAG_DIN";
   maxiter = 15;
   maskbit = 0x1;
   maxsrccount = 32;
   eindex = 15;
   length = 1;
   hindex = 17;
#else
   data_pins = "DMLED_INBUS";
   maxiter = 3;
   maskbit = 0xF;
   maxsrccount = 8;
   eindex = 12;
   length = 4;
   hindex = 5;
#endif

   tpatt = f021_shell_exepat;
   
   StringML SourceArrLo, SourceArrHi, SourceArr;
   StringS vector_data;
   for (offsetcyc = 0;offsetcyc <= maxiter;offsetcyc++)
   {
      shiftbit = length*offsetcyc;
      vector_data = strlo.Substring(eindex-shiftbit, length); 
      SourceArrLo += vector_data;
      vector_data = strhi.Substring(eindex-shiftbit, length);
      SourceArrHi += vector_data;
   }
   SourceArr = SourceArrLo + SourceArrHi;
   DIGITAL.ModifyVectors(data_pins, tpatt, bitlabel, SourceArr);

#else
   StringML SourceArrLo, SourceArrHi, SourceArr;
   StringS vector_data;
   data_pins = "PMT_RAMBUS";
   tpatt = f021_shell_exepat;
   if(GL_USE_RAMPMT_X64)  
   {
      for (offsetcyc = 0;offsetcyc <= 3;offsetcyc++)
      {
         vector_data = strlo.Substring(12-(4*offsetcyc), 4);
         SourceArrLo += vector_data;
         vector_data = strhi.Substring(12-(4*offsetcyc), 4);
         SourceArrHi += vector_data;
      } 
      SourceArr = SourceArrLo + SourceArrHi;
      DIGITAL.ModifyVectors(data_pins, tpatt, bitlabel, SourceArr); 

   }
   else
   {
      SourceArr += strlo;
      SourceArr += strhi;
      DIGITAL.ModifyVectors(data_pins, tpatt, bitlabel, SourceArr);
   } 
#endif

}  /*F021_SetTestNum*/

TMResultM Check_RAM_TNUM(IntS expTnum) {
   TMResultM test_results;
   IntS site,tnumhi,tnumlo;
   TMResultM tmp_results;
   IntM msw_tnum,lsw_tnum;


   tmp_results = TM_NOTEST;      
   tnumhi = ((expTnum & IntS(0xffff0000))>>16) & IntS(0x0000ffff);
   tnumlo = expTnum&0x0000ffff;

//   if(GL_DO_ESDA_WITH_SCRAM)  
//      Get_Flash_TestLogSpace_SCRAM;

   Get_TLogSpace_TNUM(msw_tnum,lsw_tnum);
   
   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
      if ((lsw_tnum[*si]!=tnumlo) or (msw_tnum[*si]!=tnumhi))  
         tmp_results[*si] = TM_FAIL;
   }
   test_results = tmp_results;

   if (tistdscreenprint and TI_FlashDebug) {
      cout << "Check RAM expected TNUM " << hex << expTnum << endl;
      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
         cout << "Site " << *si << hex <<msw_tnum[*si] << hex << lsw_tnum[*si];
         if (tmp_results[*si] == TM_PASS)  
            cout << "/";
         else
            cout << "X" << endl;
      } 
   }
   return(test_results);
}   /* Check_RAM_TNUM */
      

 /*Set Flash TestNumber in RAM and execute*/
TMResultM F021_RunTestNumber(    const IntS &testnum,
                                const FloatS &maxtimeout,
                                FloatM &ret_timer)
{
   TMResultM test_results(TM_NOTEST);
   TMResultM exec_results = TM_NOTEST;
   TMResultM tmp_results = TM_NOTEST;
   IntM value1,value2,value3;
   FloatS maxtime;
   IntS addr_loc,addr_loc2;
   IntS tnumhi,tnumlo;
   StringS str1;

   if(tistdscreenprint and TI_FlashDebug)  
      cout << "Running Test Number " << hex << testnum << dec << endl;
      
   // only start timer if we're going to stop it 
   if(tistdscreenprint and TI_FlashDebug)  
      TIME.StartTimer();  

   if(maxtimeout>0s)  
      maxtime = maxtimeout;
   else
      maxtime = GL_F021_MAXTIME;

   tnumhi = ((testnum&IntS(0xffff0000))>>16)&0xffff;
   tnumlo = testnum&0x0000ffff;
   
   ret_timer = 0;
   
// Commented out the below lines because we use F021_RunTestNumber_PMEX
// instead of recreating code and the _PMEX function has the following
// if clause.
//   if reload_flashshell then
//   {
//      DIGITAL.ExecutePattern(f021_shell_loadpat); /* temp JRR */
//      RAM_Upload_VHV_CT_Trimval(); /* temp JRR */
//      RAM_Upload_PMOS_TrimCode(); /* temp JRR */
//   }

    /* +++ Execute test +++ */
   exec_results = F021_RunTestNumber_PMEX(testnum, maxtime, true);

    /*check to make sure correct testnumber is written in device ram.*/
    /*this is to preventing running previous testnumber due to problem*/
    /*during updating new testnumber which can cause false pass*/


   Get_Flash_TestLogSpace_SCRAM();

   Get_TLogSpace_TNUM(value2,value1);
   
   if (TI_FlashDebug)
   {
      Get_TLogSpace_PFBin(value3);
      addr_loc2 = ADDR_PF_BIN;
      addr_loc = ADDR_TEST_INFO;
      IO.Print(str1, "RAM Loc (PF/Tnum) @ %x / %x  ==", addr_loc2, addr_loc);
      DLOG.Text(str1);
      DLOG.Value(value3, UTL_VOID, UTL_VOID, UTL_VOID, "FL_PFBIN");
   }

   tmp_results = DLOG.Value(value1, tnumlo, tnumlo, UTL_VOID, "Readback F021 Test Number Low");
   test_results = DLOG.Value(value2, tnumhi, tnumhi, UTL_VOID, "Readback F021 Test Number High");
   
   test_results = DLOG.AccumulateResults(tmp_results, test_results);
   test_results = DLOG.AccumulateResults(test_results, exec_results);

   if(tistdscreenprint and TI_FlashDebug)  
   {
      DLOG.Value(test_results, TM_PASS, TM_PASS, UTL_VOID, "RunTestNumber");
      cout << "  TT " << TIME.StopTimer() << endl;
   } 

   return (test_results);
}   /* F021_RunTestNumber */


TMResultM F021_LoadFlashShell_func()
{
   const IntS TESTID = 1; 

   TMResultM pat_results;
   FloatS ttimer;
   StringS tw_prefix, tw_name;
   StringS unitval;
   StringM site_cof_inst_str;

   if(tistdscreenprint and TI_FlashDebug)  
      IO.Print(IO.Stdout,"+++++ F021_LoadFlashShell_func +++++\n");

   GL_FLTESTID = TESTID;
   tw_prefix = "LoadFlashShell";

   TIME.StartTimer();

// :TODO: come back to this, skipping for now
//   if(TI_FlashCOFEna)  
//      F021_Init_COF_Inst_Str(site_cof_inst_str);
   
   pat_results = DIGITAL.TestPattern(f021_shell_loadpat, false, TM_PASS);

   ttimer = TIME.StopTimer();
   tw_name = tw_prefix + "_TT";
   unitval = "s";
   //TWTRealToRealMS(tt_timer,realval,unitval);
   TWPDLDataLogRealVariable(tw_name, unitval, ttimer, TWMinimumData);
   
   // very temporary debug stuff
   cout << tw_prefix << " pattern results " << pat_results << endl;

    /*KChau 12/21/07 - determine if any site is failing to log to TW.*/
   if (pat_results.AnyEqual(TM_FAIL)) 
   {
// :TODO: come back to the testware pattern logging...it's a doozy
//      F021_Log_FailPat_To_TW(tmpstr3,final_results,fl_testname);

// :TODO: come back to the FlashCOFEna stuff as well
//      if(TI_FlashCOFEna)  
//         F021_Update_COF_Inst_Str(tmpstr3,site_cof_inst_str,final_results);
   } 

// :TODO: fix the screen print stuff (Header and Result not implemented yet)
//   if(tistdscreenprint)  
//   {
//      PrintHeaderBool(GL_PLELL_FORMAT);
//      PrintResultBool(tmpstr3,0,final_results,GL_PLELL_FORMAT);
//      IO.Print(IO.Stdout,"   TT ",timernread(ttimer1));
//      IO.Print(IO.Stdout,"");
//   } 

// :TODO: come back to the FlashCOFEna stuff
//   if(TI_FlashCOFEna)  
//      F021_Save_COF_Info('',site_cof_inst_str,final_results);
   
    /*updated shell loaded*/
   GL_PREVIOUS_SHELL = "FlashShell";

// do we need to worry about the TI_FlashCOFEna here?
// or is this a flow-issue??
//   if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//      Devsetholdstates(final_results);

   return pat_results;
}   /* F021_LoadFlashShell_func */

//void CmpTRealLULim(    FloatM test_val,
//                            FloatS test_LLimit,
//                            FloatS test_ULimit,
//                            BoolM test_results)
//{
//   IntS site;
//   BoolM results;
//
//   results = false;
//   
//   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      if(v_dev_active[site])  
//         if((test_val[site]>==test_LLimit) and (test_val[site]<==test_ULimit))  
//            results[site] = true;
//   
//   test_results = results;
//}   /* CmpTRealLULim */
//   
//
//BoolS F021_Meas_TPAD(    PinM TPAD,
//                            IntS testnum,
//                            BoolS Imeasure,
//                            FloatS test_LLimit,
//                            FloatS test_ULimit,
//                            FloatS force_volt,
//                            FloatS iload,
//                            FloatS delaytime,
//                            BoolS x64soft,
//                            FloatM Meas_Value,
//                            BoolM Test_results)
//{
//   FloatS vrange, vrangehi, vrangelo;
//   FloatS irange, irangehi, irangelo;
//   FloatS tdelay;
//   IntS tmpint;
//   FloatS tmpval;
//   IntS count;
//   IntS site;
//   FloatS ttimer1;
//   FloatM tt_timer;
//   BoolS negdir;
//   option read_opt;
//   BoolM tmp_results,meas_results;
//   BoolM final_results;
//   IntS pmstop;
//   FloatS maxtime;
//
//   if(V_any_dev_active)  
//   {
//       /*measure current*/
//      if(Imeasure)  
//      {
//         read_opt = s_current;
//         if(force_volt>==5v)  
//            vrangehi = 1.5*force_volt;
//         else
//            vrangehi = 5V;
//          /*vrangelo := 0V;*/
//         vrangelo = force_volt;
//         if(test_ULimit<0ua)  
//            irange = test_LLimit*1.2;
//         else if(abs(test_LLimit)<abs(test_ULimit))  
//            irange = test_ULimit*1.2;
//         else
//            irange = test_LLimit*1.2;
//      }
//      else
//      {  /*measure voltage*/
//         read_opt = s_voltage;
//         if(test_ULimit<5v)  
//            vrangehi = 5V;
//         else
//            vrangehi = test_ULimit*1.2;
//         vrangelo = force_volt;  /*0V;*/
//         irange = iload;
//          /*irange := 20nA;*/
//      } 
//
//      if(delaytime <== 10us)  
//         tdelay = 2ms;
//      else
//         tdelay = delaytime;
//
//      
//      count = 10;
//      pmstop = 1;
//      maxtime = 10ms;
//      
//      final_results = true;
//      timernstart(ttimer1);
//
//      STDSetVI(TPAD, vrangelo, irange);
//      
//      TIME.Wait(tdelay);
//
//      Enable(S_pmexit);
//      PMExSetdelay(S_PFLAGS,pmstop);
//
//         F021_SetTestNum(testnum);
//         Patternexecute(tmpint,f021_shell_exepat);
//
//      TIME.Wait(maxtime);
//      
//      tmp_results = v_pf_status;
//      meas_results = false;
//
//       /*KChau 12/19/07 - removed if TUIVERSION >=3.6 statements*/
//      switch(read_opt) {
//        case S_CURRENT : STDMeasI(TPAD, count, Meas_Value);
//        case S_VOLTAGE : STDMeasV(TPAD, count, Meas_Value);
//      }   /* case */
//
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//            if((Meas_Value[site] >== test_LLimit) and (Meas_Value[site] <== test_ULimit))  
//
//      ArrayAndBoolean(final_results,tmp_results,meas_results,v_sites);
//      test_results = final_results;
//      
//      Disable(S_pmexit);
//
//      STDSetVI(TPAD, 0v, irange);
//      TIME.Wait(tdelay);
//   }   /*v_any_dev_active*/
//
//   F021_Meas_TPAD = V_any_dev_active;
//
//}   /* F021_Meas_TPAD */

void F021_Set_TPADS(IntS TCRnum,
                         TPModeType TCRMode)
{
   FloatS tdelay,iProg,vProg,vRange,vforce;
   PinM tsupply;  /*PSSupplyName;*/
   IntS tpnum,special_opt;
   StringS str1;
   BoolS suppena;
   TPMeasType meastype;
   VIForceTypeS viforce_type;
   VIMeasureTypeS vimeas_type;

   if(tistdscreenprint and TI_FlashDebug)  
      IO.Print(IO.Stdout,"\n");

   if(TCRnum==52)  
     special_opt = 3;
   else
     special_opt = 0;
   
   for (tpnum = GL_TPADMIN;tpnum <= GL_TPADMAX;tpnum++)
   {
      suppena = false;
      switch(tpnum) {
        case 1 :  
               if(TCR.TP1_Ena[TCRnum]) 
               {
                  meastype = TCR.TP1_MeasType[TCRnum];
                  if(meastype==MeasVoltType) 
                  {
                     vRange = 1.2*TCR.TP1_VRange[TCRnum][TCRMode];
                     vProg  = 0V;
                  }
                  else
                  { 
                     vRange = TCR.TP1_VRange[TCRnum][TCRMode];
                     vProg  = vRange;
                  }

                  if(meastype==MeasCurrType)  
                     iProg = 1.2*MATH.Abs(FloatS(TCR.TP1_IRange[TCRnum][TCRMode]));
                  else
                     // removed Abs because we need to be able to sink current during voltage measures
                     iProg = TCR.TP1_IRange[TCRnum][TCRMode];
                     
                  tsupply  = FLTP1;
                  str1     = "TP1";
                  if(special_opt=3)  
                     suppena = false;
                  else
                     suppena  = true;
               }
               break; 
        case 2 :  
               if(TCR.TP2_Ena[TCRnum])  
               { 
                  meastype = TCR.TP2_MeasType[TCRnum];
                  if(meastype==MeasVoltType)  
                  { 
                     vRange = 1.2*TCR.TP2_VRange[TCRnum][TCRMode];
                     vProg  = 0V;
                  } 
                  else
                  { 
                     vRange = TCR.TP2_VRange[TCRnum][TCRMode];
                     vProg  = vRange;
                  } 
                     
                  if(meastype==MeasCurrType)  
                     iProg = 1.2*MATH.Abs(FloatS(TCR.TP2_IRange[TCRnum][TCRMode]));
                  else
                     iProg = TCR.TP2_IRange[TCRnum][TCRMode];  
                     
                  tsupply  = FLTP2;
                  str1     = "TP2";
                  suppena  = true;
                }
                break;  
#if $TP3_TO_TP5_PRESENT  
        case 3 : 
               if(TCR.TP3_Ena[TCRnum])  
               {
                  meastype = TCR.TP3_MeasType[TCRnum];
                  if(meastype==MeasVoltType)  
                  {
                     vRange = 1.2*TCR.TP3_VRange[TCRnum][TCRMode];
                     vProg  = 0V;
                  }
                  else
                  {
                     vRange = TCR.TP3_VRange[TCRnum][TCRMode];
                     vProg  = vRange;
                  } 

                  if(meastype==MeasCurrType)  
                     iProg = 1.2*MATH.Abs(FloatS(TCR.TP3_IRange[TCRnum][TCRMode]));
                  else
                     iProg = TCR.TP3_IRange[TCRnum][TCRMode];
                     
                  tsupply  = FLTP3;
                  str1     = "TP3";
                  suppena  = true;
               } 
               break; 
        4 :
               if(TCR.TP4_Ena[TCRnum])  
               {
                  meastype = TCR.TP4_MeasType[TCRnum];
                  if(meastype==MeasVoltType)  
                  {
                     vRange = 1.2*TCR.TP4_VRange[TCRnum][TCRMode];
                     vProg  = 0V;
                  }
                  else
                  {
                     vRange = TCR.TP4_VRange[TCRnum][TCRMode];
                     vProg  = vRange;
                  } 
                  
                  if(meastype==MeasCurrType)  
                     iProg = 1.2*MATH.Abs(FloatS(TCR.TP4_IRange[TCRnum][TCRMode]));
                  else
                     iProg = TCR.TP4_IRange[TCRnum][TCRMode];
                     
                  tsupply  = FLTP4;
                  str1     = "TP4";
                  suppena  = true;
               } 
               break;
        5 : 
               if(TCR.TP5_Ena[TCRnum])  
               {
                  meastype = TCR.TP5_MeasType[TCRnum];
                  if(meastype==MeasVoltType)  
                  {
                     vRange = 1.2*TCR.TP5_VRange[TCRnum][TCRMode];
                     vProg  = 0V;
                  }
                  else
                  {
                     vRange = TCR.TP5_VRange[TCRnum][TCRMode];
                     vProg  = vRange;
                  } 
                  
                  if(meastype==MeasCurrType)  
                     iProg = 1.2*MATH.Abs(FloatS(TCR.TP5_IRange[TCRnum][TCRMode]));
                  else
                     iProg = TCR.TP5_IRange[TCRnum][TCRMode];
                     
                  tsupply  = FLTP5;
                  str1     = "TP5";
                  suppena  = true;
               } 
               break;
#endif
#if $TADC_PRESENT  
        6 : 
               if(TCR.TADC_Ena[TCRnum])  
               {
                  meastype = TCR.TADC_MeasType[TCRnum];
                  if(meastype==MeasVoltType)  
                  {
                     vRange = 1.2*TCR.TADC_VRange[TCRnum][TCRMode];
                     vProg  = 0V;
                  }
                  else
                  {
                     vRange = TCR.TADC_VRange[TCRnum][TCRMode];
                     vProg  = vRange;
                  } 

                  if(meastype==MeasCurrType)  
                     iProg = 1.2*MATH.Abs(FloatS(TCR.TADC_IRange[TCRnum][TCRMode]));
                  else
                     iProg = TCR.TADC_IRange[TCRnum][TCRMode];
                     
                  tsupply  = P_TADC;
                  str1     = "TADC";
                  suppena  = true;
               } 
               break; 
#endif
      }   /* case */

      if(suppena)  
      {
         if (!STDGetConnect(tsupply)) // at least one site not connected to DUT
         { 
            STDConnect(tsupply);
         }
         GetVITypesFromTPMeasType(meastype, viforce_type, vimeas_type);
         STDSetVI(tsupply, vProg, iProg, viforce_type, vimeas_type, vRange);
         if(tistdscreenprint and TI_FlashDebug)  
         {
            IO.Print(IO.Stdout,"Setting TPADs --  TCR %5d\n",TCRnum);
            IO.Print(IO.Stdout,"%5s Vprog = %5.3f VRange = %5.3f IProg = %5.3e\n",str1, 
                     vProg,vRange,iProg);
         } 
      }   /*if suppena*/
   }   /*for tpnum*/

   if(special_opt==3)  
   {
      if(TCR.TP1_Ena[TCRnum])  
      {
         meastype = TCR.TP1_MeasType[TCRnum];
         if(meastype==MeasVoltType)  
         {
            vRange = 1.2*TCR.TP1_VRange[TCRnum][TCRMode];
            vProg  = 0V;
         }
         else
         {
            vRange = TCR.TP1_VRange[TCRnum][TCRMode];
            vProg  = vRange;
         } 
    
         if(meastype==MeasCurrType)  
            iProg = 1.2*MATH.Abs(FloatS(TCR.TP1_IRange[TCRnum][TCRMode]));
         else
            iProg = TCR.TP1_IRange[TCRnum][TCRMode];
            
         tsupply  = FLTP1;
         str1     = "TP1";
         suppena  = true;
      } 

      if(suppena)  
      {
         if (!STDGetConnect(tsupply)) // at least one site not connected to DUT
         { 
            STDConnect(tsupply);
         }
         GetVITypesFromTPMeasType(meastype, viforce_type, vimeas_type);
         STDSetVI(tsupply, vProg, iProg, viforce_type, vimeas_type, vRange);
         if(tistdscreenprint and TI_FlashDebug)  
         {
            IO.Print(IO.Stdout,"Setting TPADs --  TCR %5d\n",TCRnum);
            IO.Print(IO.Stdout,"%5s Vprog = %5.3f VRange = %5.3f IProg = %5.3e\n",str1, 
                     vProg,vRange,iProg);
         } 
      }   /*if suppena*/
   }   /*special_opt=3*/
   
   tdelay = 10us;
   TIME.Wait(tdelay);
   if(tistdscreenprint and TI_FlashDebug)  
      IO.Print(IO.Stdout,"\n");
}   /* F021_Set_TPADS */

void F021_Set_TPADS_ByOrder(IntS TCRnum,
                                 TPModeType TCRMode,
                                 BoolS rampup) {

   FloatS tdelay,iProg,vProg,vRange,vforce;
   IntS fdlen1,fdlen2;
   PinM tsupply;  // PSSupplyName
   IntS tpnum,special_opt,i,miniter,maxiter;
   StringS str1;
   BoolS suppena;
   TPMeasType meastype;
   vttype stresstype;
 
   if (tistdscreenprint and TI_FlashDebug)  
      cout << endl;

   fdlen1 = 5;
   fdlen2 = 3;

   // look up vt/stress type
   switch(TCRnum) {
     case 23 :  
        switch(TCRMode) {
           case EvfyMode : stresstype = EGFG4VT0; break;
           case PvfyMode : stresstype = EGFG3VT0; break;
           default:  
              stresstype = EGFG4VT0;
              if (tistdscreenprint)  
                 cout << "*** WARNING: INVALID TCRNUM/TCRMODE !!! ***" << endl;
              break; 
        }
        break;   // case 23
     case 52: case 107: case 108:
        switch(TCRMode) {
           case CvfyMode : stresstype = TUNOXTSMCVT1;
           case EvfyMode : stresstype = TUNOXVT1;
           case ProgMode : stresstype = PGMFFVT1;
           case PvfyMode : stresstype = FGWLVT1;
           default:  
              stresstype = TUNOXVT1;
              if (tistdscreenprint)  
                 cout << "*** WARNING: INVALID TCRNUM/TCRMODE !!! ***" << endl;
              break; 
        }
        break;   // case 52
     case 53:
        stresstype = ONOVT0;
        break;
     case 54:
        switch(TCRMode) {
           case ErsMode  : stresstype = THINOXVT1;  break;
           case PvfyMode : stresstype = PUNTHRUVT1; break;
           case ProgMode : stresstype = REVTUNVT1;  break;
           default:  
              stresstype = THINOXVT1;
              if (tistdscreenprint)  
                 cout << "*** WARNING: INVALID TCRNUM/TCRMODE !!! ***" << endl;
              break; 
        }
        break;   // case 54
     case 58:
        switch(TCRMode) {
           case ReadMode : stresstype = RDDISTBVT0;  break;
           case PvfyMode : stresstype = RDDISTB2VT0; break;
           default:  
              stresstype = RDDISTBVT0;
              if (tistdscreenprint)  
                 cout << "*** WARNING: INVALID TCRNUM/TCRMODE !!! ***" << endl;
              break; 
        }
        break;   // case 58 
     case 84: case 110:
        stresstype = CSFGVT0;
        break;
     default:
        stresstype = EGFG1VT0;
        if (tistdscreenprint)  
           cout << "*** WARNING: INVALID TCRNUM/TCRMODE !!! ***" << endl;
        break;
   }   // switch TRCnum

   miniter = 1;
   maxiter = 5;

   if (rampup) {
      for (i = miniter;i <= maxiter;i++) {
         tpnum = TPadSeq.TPUPSEQ[stresstype][i];
         suppena = false;

         if (tpnum==0)  
            break;
         
         switch(tpnum) {
            case 1 :  
               if (TCR.TP1_Ena[TCRnum]) {
                  meastype = TCR.TP1_MeasType[TCRnum];
                  if (meastype==MeasVoltType)  { 
                     vRange = 1.2*TCR.TP1_VRange[TCRnum][TCRMode];
                     vProg  = 0V;
                  }
                  else {
                     vRange = TCR.TP1_VRange[TCRnum][TCRMode];
                     vProg  = vRange;
                  }
                     
                  if (meastype==MeasCurrType)  
                     iProg = 1.2*TCR.TP1_IRange[TCRnum][TCRMode];
                  else
                     iProg = TCR.TP1_IRange[TCRnum][TCRMode];

                  tsupply  = FLTP1;
                  str1     = "TP1";
                  suppena  = true;
               }
               break; 
           case 2 :  
              if (TCR.TP2_Ena[TCRnum]) {
                 meastype = TCR.TP2_MeasType[TCRnum];
                 if (meastype==MeasVoltType) {
                    vRange = 1.2*TCR.TP2_VRange[TCRnum][TCRMode];
                    vProg  = 0V;
                 }
                 else {
                    vRange = TCR.TP2_VRange[TCRnum][TCRMode];
                    vProg  = vRange;
                 }
                     
                 if (meastype==MeasCurrType)  
                    iProg = 1.2*TCR.TP2_IRange[TCRnum][TCRMode];
                 else
                    iProg = TCR.TP2_IRange[TCRnum][TCRMode];                        

                 tsupply  = FLTP2;
                 str1     = "TP2";
                 suppena  = true;
                   break; 
              }
              break; 
#if $TP3_TO_TP5_PRESENT  
           case 3:  
              if (TCR.TP3_Ena[TCRnum])  {
                 meastype = TCR.TP3_MeasType[TCRnum];
                 if (meastype==MeasVoltType)  {
                    vRange = 1.2*TCR.TP3_VRange[TCRnum][TCRMode];
                    vProg  = 0V;
                 }
                 else {
                    vRange = TCR.TP3_VRange[TCRnum][TCRMode];
                    vProg  = vRange;
                 } 
                     
                 if (meastype==MeasCurrType)  
                    iProg = 1.2*abs(TCR.TP3_IRange[TCRnum][TCRMode]);
                 else
                    iProg = abs(TCR.TP3_IRange[TCRnum][TCRMode]);

                 tsupply  = FLTP3;
                 str1     = "TP3";
                 suppena  = true;
              } 
              break;
           case 4:
              if (TCR.TP4_Ena[TCRnum]) {
                 meastype = TCR.TP4_MeasType[TCRnum];
                 if (meastype==MeasVoltType)  {
                    vRange = 1.2*TCR.TP4_VRange[TCRnum][TCRMode];
                    vProg  = 0V;
                 }
                 else {
                    vRange = TCR.TP4_VRange[TCRnum][TCRMode];
                    vProg  = vRange;
                 } 
                  
                 if(meastype==MeasCurrType)  
                    iProg = 1.2*abs(TCR.TP4_IRange[TCRnum][TCRMode]);
                 else
                    iProg = abs(TCR.TP4_IRange[TCRnum][TCRMode]);

                 tsupply  = FLTP4;
                 str1     = "TP4";
                 suppena  = true;
             } 
             break;
           case 5:
              if (TCR.TP5_Ena[TCRnum])  {
                 meastype = TCR.TP5_MeasType[TCRnum];
                 if (meastype==MeasVoltType)  {
                    vRange = 1.2*TCR.TP5_VRange[TCRnum][TCRMode];
                    vProg  = 0V;
                 }
                 else {
                    vRange = TCR.TP5_VRange[TCRnum][TCRMode];
                    vProg  = vRange;
                 } 
                     
                 if (meastype==MeasCurrType)  
                    iProg = 1.2*abs(TCR.TP5_IRange[TCRnum][M]);
                 else
                    iProg = abs(TCR.TP5_IRange[TCRnum][TCRMode]);

                 tsupply  = FLTP5;
                 str1     = "TP5";
                 suppena  = true;
              } 
              break;
#endif
         }   // switch(tpnum)
         
         if (suppena) {
//            STDSetVRange(tsupply,vRange);
//            STDSetVI(tsupply,vProg,iProg);
            if (tistdscreenprint and TI_FlashDebug) {
               cout << "Setting TPADs --  TCR " << TCRnum << endl;
               cout << str1 << " Vprog == " << vProg;
               cout << " VRange == " << vRange << " Iprog == " << iProg << endl;
            } 
         }   // if suppena
      }   // for i
   }  // rampup
   else {
      for (i = maxiter;i <= miniter;i++) {
         tpnum = TPadSeq.TPUPSEQ[stresstype][i];
         suppena = false;
         vProg = 0V;
         iProg = 1mA;
         switch(tpnum) {
            case 1 :  
               if (TCR.TP1_Ena[TCRnum]) {
                  tsupply = FLTP1;
                  str1 = "TP1";
                  suppena = true;
               }
               break; 
            case 2 :  
               if (TCR.TP2_Ena[TCRnum]) {
                  tsupply = FLTP2;
                  str1 = "TP2";
                  suppena = true;
               }
               break; 
#if $TP3_TO_TP5_PRESENT  
            case 3 :  
               if (TCR.TP3_Ena[TCRnum]) {
                  tsupply = FLTP3;
                  str1 = "TP3";
                  suppena = true;
               } 
               break; 
            case 4 :  
               if (TCR.TP4_Ena[TCRnum]) {
                  tsupply = FLTP4;
                  str1 = "TP4";
                  suppena = true;
               } 
               break; 
            case 5 :  
               if (TCR.TP5_Ena[TCRnum]) {
                  tsupply = FLTP5;
                  str1 = "TP5";
                  suppena = true;
               } 
               break; 
#endif
         }   // switch(tpnum)

         if (suppena)  {
//          STDSetVI(tsupply,vProg,iProg);
            if (tistdscreenprint and TI_FlashDebug) {
               cout << " TPADs --  TCR " << TCRnum << endl;
               cout << str1 << " Vprog == " << vProg << " Iprog == " << iProg << endl;
            } 
         }   // if suppena
      }   // for i
   }   // rampdown

   tdelay = 10us;
   TIME.Wait(tdelay);
   if (tistdscreenprint and TI_FlashDebug)  
      cout << endl;
}   // F021_Set_TPADS_ByOrder
      
//
//void F021_UnSet_TPADS(IntS TCRnum)
//{
//   FloatS tdelay;
//
//   if(v_any_dev_active)  
//   {
//      if(TCR.TP1_Ena[TCRnum])  
//         STDSetVI(FLTP1,0v,1ma);
//      if(TCR.TP2_Ena[TCRnum])  
//         STDSetVI(FLTP2,0v,1ma);
//#if $TP3_TO_TP5_PRESENT  
//      if(TCR.TP3_Ena[TCRnum])  
//         STDSetVI(FLTP3,0v,1ma);
//      if(TCR.TP4_Ena[TCRnum])  
//         STDSetVI(FLTP4,0v,1ma);
//      if(TCR.TP5_Ena[TCRnum])  
//         STDSetVI(FLTP5,0v,1ma);
//#endif
//#if $TADC_PRESENT  
//      if(TCR.TADC_Ena[TCRnum])  
//         STDSetVI(P_TADC,0v,1ma);
//#endif
//      
//      tdelay = 2ms;
//      TIME.Wait(tdelay);
//   } 
//}   /* F021_UnSet_TPADS */

void F021_TurnOff_AllTPADS()
{
   FloatS tdelay;

   VI.Gate(FLTP1, VI_GATE_OFF_LOZ);
   VI.Gate(FLTP2, VI_GATE_OFF_LOZ);
//   VI.Disconnect(FLTP1);
//   VI.Disconnect(FLTP2);
//   STDSetVI(FLTP1,0V,1mA);
//   STDSetVI(FLTP2,0V,1mA);
#if $TP3_TO_TP5_PRESENT  
   VI.Gate(FLTP3, VI_GATE_OFF_LOZ);
   VI.Gate(FLTP4, VI_GATE_OFF_LOZ);
   VI.Gate(FLTP5, VI_GATE_OFF_LOZ);
//   VI.Disconnect(FLTP3);
//   VI.Disconnect(FLTP4);
//   VI.Disconnect(FLTP5);
//   STDSetVI(FLTP3,0V,1mA);
//   STDSetVI(FLTP4,0V,1mA);
//   STDSetVI(FLTP5,0V,1mA);
#endif
#if $TADC_PRESENT  
   VI.Gate(P_TADC, VI_GATE_OFF_LOZ);
//   VI.Disconnect(P_TADC);
//   STDSetVI(P_TADC,0V,1mA);
#endif
      
   tdelay = 2ms;
   TIME.Wait(tdelay);
   
}   /* F021_TurnOff_AllTPADS */

void F021_Ramp_TPAD(PinM TPAD,
                         FloatS rampstart,
                         FloatS rampstop,
                         FloatS iProg)
//pgmMode isn't even used in the code??                         Option pgmMode)
{
   IntS fdlen1,fdlen2;
   FloatS vstart,vstop,vstep;
   FloatS tdelay,vProg;
   IntS rampstep,count,site;
//not sure this is even used   option iGainMode;
   PinM tsupply;
   StringS str1;
//Unison is sited
//   if(V_any_dev_active)  
//   {
      if(tistdscreenprint and TI_FlashDebug)  
      {
         cout << endl;
         cout << "Ramping TPAD ... " << endl;
         fdlen1 = 5;
         fdlen2 = 3;
      } 

      TIME.QueueDelay("tdelay", 1usec);
      rampstep = 3;
//Not used again?      iGainMode = s_igain_1x; 
//anyhow, s_igain_1x isn't declared in this scope.  Not sure where it comes from.      
      vstart = rampstart;
      vstop  = rampstop;
      vstep  = 0V;

      if(vstart==vstop)  
         rampstep = 1;
      else
         vstep = (vstop-vstart)/rampstep;  /*negative=ramp down,pos=ramp up*/

      tsupply = TPAD;

      if(TPAD==FLTP1)  
      {
         str1 = "TP1";
      }
      else if(TPAD==FLTP2)  
      {
         str1 = "TP2";
      } 
#if $TP3_TO_TP5_PRESENT  
      if(TPAD==FLTP3)  
      {
         str1 = "TP3";
      }
      else if(TPAD==FLTP4)  
      {
         str1 = "TP4";
      }
      else if(TPAD==FLTP5)  
      {
         str1 = "TP5";
      } 
#endif
#if $TADC_PRESENT  
      if(TPAD==P_TADC)  
      {
         str1 = "TADC";
      } 
#endif

//this functionality is rolled into STDsetVI code
//      if(vstart>vstop)  
//         STDSetVRange(tsupply,vstart);
//      else
//         STDSetVRange(tsupply,vstop);
//         
      for (count = 1;count <= (rampstep-1);count++)
      {
         vProg = vstart+(count*vstep);
         if(vstart>vstop)
            STDSetVI(tsupply,vProg,iProg,VI_FORCE_V,VI_MEASURE_I,vstart);
         else
            STDSetVI(tsupply,vProg,iProg,VI_FORCE_V,VI_MEASURE_I,vstop);
         TIME.Wait("tdelay");
         if(tistdscreenprint and TI_FlashDebug)  
//original code            cout << "Ramping " << str1 << " @ " << vProg:fdlen1:fdlen2 << " @ " << iProg << endl;
            cout<<"Ramping "<<str1<<" @ "<<setw(fdlen1)<<setw(fdlen2)<<vProg<<" @ "<<iProg<<endl;
      } 

      if(vstop>10V)  
         STDSetVI(tsupply,vstop,iProg,VI_FORCE_V,VI_MEASURE_I,vstop);
//         STDSetVRange(tsupply,vstop);
      else
         STDSetVI(tsupply,vstop,iProg,VI_FORCE_V,VI_MEASURE_I,UTL_VOID);
      TIME.Wait("tdelay");            
      if(tistdscreenprint and TI_FlashDebug)  
//original code         cout << "Ramping " << str1 << " @ " << vstop:fdlen1:fdlen2 << " @ " << iProg << endl;
         cout <<"Ramping "<<str1<<" @ "<<setw(fdlen1)<<setw(fdlen2)<<vstop<<" @ "<<iProg<<endl;
      
//Unison is isted
//   }   /*if v_any_dev_active*/
}   /* F021_Ramp_TPAD */

// This is just a measure function now. Do the testing elsewhere.
FloatM F021_Meas_TPAD_PMEX(   PinM TPAD,
                                 IntS TCRnum,
                                 TPModeType TCRMode)
{
   BoolS read_voltage;
   PinM tsupply;
   TMResultM final_results;
   FloatS ulim,llim;
   BoolS validsupp,validpgm;
   UnsignedS count;
   BoolS debugprint;
   FloatM Sim_Value = 0.0;
   FloatM Meas_Value;
   
   bool debug_sample_repeatability = false;

   validsupp = false;
   tsupply = TPAD;
   
   if((TPAD==FLTP1) and TCR.TP1_Ena[TCRnum] and
      ((TCR.TP1_MeasType[TCRnum]==MeasCurrType) or (TCR.TP1_MeasType[TCRnum]==MeasVoltType)))  
   {
      if(TCR.TP1_MeasType[TCRnum]==MeasCurrType)  
         read_voltage = false;
      else if(TCR.TP1_MeasType[TCRnum]==MeasVoltType)  
         read_voltage = true;
      validsupp = true;
   }
   else if((TPAD==FLTP2) and TCR.TP2_Ena[TCRnum] and
      ((TCR.TP2_MeasType[TCRnum]==MeasCurrType) or (TCR.TP2_MeasType[TCRnum]==MeasVoltType)))  
   {
      if(TCR.TP2_MeasType[TCRnum]==MeasCurrType)  
         read_voltage = false;
      else if(TCR.TP2_MeasType[TCRnum]==MeasVoltType)  
         read_voltage = true;
      validsupp = true;
   } 
   
   if(not validsupp)  
   {
    
#if $TP3_TO_TP5_PRESENT  
      if((TPAD==FLTP3) and TCR.TP3_Ena[TCRnum] and
         ((TCR.TP3_MeasType[TCRnum]==MeasCurrType) or (TCR.TP3_MeasType[TCRnum]==MeasVoltType)))  
      {
         if(TCR.TP3_MeasType[TCRnum]==MeasCurrType)  
            read_voltage = false;
         else if(TCR.TP3_MeasType[TCRnum]==MeasVoltType)  
            read_voltage = true;
         validsupp = true;
      }
      else if((TPAD==FLTP4) and TCR.TP4_Ena[TCRnum] and
         ((TCR.TP4_MeasType[TCRnum]==MeasCurrType) or (TCR.TP4_MeasType[TCRnum]==MeasVoltType)))  
      {
         if(TCR.TP4_MeasType[TCRnum]==MeasCurrType)  
            read_voltage = false;
         else if(TCR.TP4_MeasType[TCRnum]==MeasVoltType)  
            read_voltage = true;
         validsupp = true;
      }
      else if((TPAD==FLTP5) and TCR.TP5_Ena[TCRnum] and
         ((TCR.TP5_MeasType[TCRnum]==MeasCurrType) or (TCR.TP5_MeasType[TCRnum]==MeasVoltType)))  
      {
         if(TCR.TP5_MeasType[TCRnum]==MeasCurrType)  
            read_voltage = false;
         else if(TCR.TP5_MeasType[TCRnum]==MeasVoltType)  
            read_voltage = true;
         validsupp = true;
      } 
#endif
   } 
   
   if(not validsupp)  
   {
    
#if $TADC_PRESENT  
      if((TPAD==P_TADC) and TCR.TADC_Ena[TCRnum] and
         ((TCR.TADC_MeasType[TCRnum]==MeasCurrType) or (TCR.TADC_MeasType[TCRnum]==MeasVoltType)))  
      {
         if(TCR.TADC_MeasType[TCRnum]==MeasCurrType)  
            read_voltage = false;
         else if(TCR.TADC_MeasType[TCRnum]==MeasVoltType)  
            read_voltage = true;
         validsupp = true;
      } 
#endif
   } 

   if(validsupp)  
   {
      count = 10;
      
      // remove after debug
      FloatM1D meas_values(1000,0);

      if (read_voltage) 
      {
//         cout << "I'm-a reading voltage!" << endl;
         // remove after debug!!
         if (debug_sample_repeatability)
         {
            STDMeasVSampled(tsupply, 1000, meas_values, Sim_Value);
         }
         
         STDMeasV(tsupply, count, Meas_Value, Sim_Value);
      } else {
//         cout << "I'm-a reading current!" << endl;
         // remove after debug!!
         if (debug_sample_repeatability)
         {
            STDMeasISampled(tsupply, 1000, meas_values, Sim_Value);
         }
         
         STDMeasI(tsupply, count, Meas_Value, Sim_Value);
      }

      // since other messages go to stdout and not the datalog stream buffer, we
      // should probably keep the debug data here in stdout instead of using 
      // the datalog stream from DLOG.Value.
      debugprint = false;
      if(debugprint and tistdscreenprint)  
         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
            cout << "Site " << *si << " Meas_Value=" << Meas_Value[*si] << endl;
   }
   return (Meas_Value);

}   /* F021_Meas_TPAD_PMEX */

 /*execute tnumber w/ pmex enable and remain w/o disable pmex*/
TMResultM F021_RunTestNumber_PMEX(    IntS testnum,
                                     FloatS maxtimeout,
                                     BoolS testPassPin)
{
   FloatS maxtime,tdelay,ttimer1,timer2_start;
   TMResultM test_results = TM_NOTEST;
   BoolS done,debugprint;
   bool using_pattern_match = false;   
   bool using_cpu_loop = true;
   BoolM done_value, ndone_value, pass_value, all_bool;
   
   TIME.StartTimer();
   debugprint = TI_FlashDebug and tiprintpass;      
   if(tistdscreenprint and debugprint)  
      IO.Print(IO.Stdout,"Running Test Number PMEX 0x%x\n",testnum);

   if(maxtimeout>0s)  
      maxtime = maxtimeout;
   else
      maxtime = GL_F021_MAXTIME;

   tdelay = 100us;
   
   if (reload_flashshell)
   {
      DIGITAL.ExecutePattern(f021_shell_loadpat); /* temp JRR */
      RAM_Upload_VHV_CT_TrimVal(); /* temp JRR */
      RAM_Upload_PMOS_TrimCode(); /* temp JRR */
   }
   
   F021_SetTestNum(testnum);
   
   if (using_pattern_match) 
   {
      test_results = DIGITAL.TestPattern(f021_shell_exepat, true);
   } 
   else {
      DIGITAL.ExecutePattern(f021_shell_exepat);
      
      TIME.Wait(tdelay);
      done = false;
      timer2_start = TIME.GetTimer();

      while((!done) && ((TIME.GetTimer() - timer2_start)<maxtime))
      {      
         DIGITAL.ReadFlag(F021_DONEPIN, DIGITAL_FLAG_FAIL, done_value, true);
         DIGITAL.ReadFlag(F021_NDONEPIN, DIGITAL_FLAG_FAIL, ndone_value, true);
         if (!((done_value == true) & (ndone_value == true))) // true is a fail and that's what we're looking for, pattern strobes low
         // above will be true unless all sites are done
         {
            TIME.Wait(tdelay);
//            cout << "waiting on donepin" << endl;
         } else {
            done = true;
         }
      }   /*while*/
      
      // And done and ndone and pass, if needed
      if (testPassPin)
      {
         DIGITAL.ReadFlag(F021_PASSPIN, DIGITAL_FLAG_FAIL, pass_value, true);
         all_bool = done_value & pass_value & ndone_value;
      } else 
      {
         all_bool = done_value & ndone_value;
      }
      
      // check for results
      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
         test_results[*si] = all_bool[*si] ? TM_PASS : TM_FAIL;
      
   }
   
   if (using_cpu_loop) // let's end the loop
   {
      DIGITAL.SetFlag(DIGITAL_FLAG_CPU, false);
   } 

   ttimer1 = TIME.StopTimer();

   if(tistdscreenprint and debugprint)  
   {
      // these values will be meaningless for matchvector
      if (!using_pattern_match)
      {
         IO.Print(IO.Stdout,"F021_DONEPIN  (H) : ");
         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
            if(done_value[*si])  
               IO.Print(IO.Stdout,"  /  ");
            else
               IO.Print(IO.Stdout,"  X  ");
         IO.Print(IO.Stdout,"\n");
         IO.Print(IO.Stdout,"F021_NDONEPIN (L) : ");
         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
            if(ndone_value[*si])  
               IO.Print(IO.Stdout,"  /  ");
            else
               IO.Print(IO.Stdout,"  X  ");
         IO.Print(IO.Stdout,"\n");
         if (testPassPin)
         {
            IO.Print(IO.Stdout,"F021_PASSPIN  (H) : ");
            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
               if(pass_value[*si])  
                  IO.Print(IO.Stdout,"  /  ");
               else
                  IO.Print(IO.Stdout,"  X  ");
            IO.Print(IO.Stdout,"\n");
         }
      }
      IO.Print(IO.Stdout,"\n");
      IO.Print(IO.Stdout,"F021_RunTestNumber_PMEX TT : %e\n",ttimer1);
      IO.Flush(IO.Stdout);
   } 
   
   if(tistdscreenprint and TI_FlashDebug)  
   {
      IO.Print(IO.Stdout,"RunTestNumber_PMEX 0x%x\n",testnum);
      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
         if(test_results[*si] == TM_PASS)  
            IO.Print(IO.Stdout,"  /  ");
         else
            IO.Print(IO.Stdout,"  X  ");
      IO.Print(IO.Stdout,"\n");
      IO.Flush(IO.Stdout);
   }             

   return (test_results);
}   /* F021_RunTestNumber_PMEX */

//void MBox_Upload_IProg(IntS senampnum)
//{
//   IntS site,length,count,index;
//   IntS wr_flag_num,dbit,sbit;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   IntS addr_loc,tmp_value;
//   BoolS bcd_format,hexvalue;
//   IntS1D din_array(19);
//   BoolS debugprint;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ MBox_Upload_IProg +++++" << endl;
//
//      wr_flag_num = 0x1234;
//      bcd_format  = true;
//      hexvalue    = true;
//      addr_loc = ADDR_RAM_MAILBOX;
//
//      switch(F021_Flash.DATAWIDTH) {
//        case 64  : numword_max = 4;
//        case 144 : numword_max = 9;
//        case 288 : numword_max = 18;
//        default: numword_max = 9;
//      }   /* case */
//      
//      for (count = 0;count <= numword_max;count++)
//         din_array[count] = 0xffff;
//
//       /*upload write flag (msw) and data length (lsw)*/
//      msw_data = wr_flag_num;  /*msword*/
//      lsw_data = numword_max;  /*lsword*/
//       /*upload to ram 32-bit write flag and data length*/
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//
//      index = senampnum div 16;
//      sbit = senampnum mod 16;
//      dbit = 1 << (15-sbit);
//      din_array[index] = din_array[index] ^ dbit;  /*bit=0 means selected*/
//
//      debugprint = false;
//      if(tistdscreenprint and debugprint)  
//         cout << "Sense Amp Number " << senampnum:-5 << " DataMask == " << din_array[index]:s_hex << endl;
//
//      for count = 0 to (numword_max-1) by 2 do
//      {
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         msw_data = din_array[count];
//         lsw_data = din_array[count+1];
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                                  msw_data,hexvalue,bcd_format);
//      }   /*for count*/
//
//      if(tistdscreenprint and debugprint)  
//         DumpRamMailbox;
//   } 
//   
//}   /* MBox_Upload_IProg */
//
//
//void MBox_Upload_ISenAmp(IntS senampnum)
//{
//   IntS site,length,count,index;
//   IntS wr_flag_num,dbit,sbit;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   IntS addr_loc,tmp_value;
//   BoolS bcd_format,hexvalue;
//   IntS1D din_array(19);
//   BoolS debugprint;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ MBox_Upload_ISenAmp +++++" << endl;
//
//      bcd_format  = true;
//      hexvalue    = true;
//      wr_flag_num = 0x1234;
//
//      addr_loc    = ADDR_RAM_MAILBOX;
//
//      switch(F021_Flash.DATAWIDTH) {
//        case 64  : numword_max = 4;
//        case 144 : numword_max = 9;
//        case 288 : numword_max = 18;
//        default: numword_max = 9;
//      }   /* case */
//      
//      for (count = 0;count <= numword_max;count++)
//         din_array[count] = 0xffff;
//      
//       /*upload write flag (msw) and data length (lsw)*/
//      msw_data = wr_flag_num;  /*msword*/
//      lsw_data = numword_max;  /*lsword*/
//       /*upload to ram 32-bit write flag and data length*/
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//
//      if(numword_max==9)  
//      {
//         if(((senampnum>==0) and (senampnum<==7)) or ((senampnum>==136) and (senampnum<==143)))  
//         {
//            index = 8;
//            if(senampnum<==7)  
//               dbit = 1 << (senampnum+8);
//            else
//               dbit = 1 << (senampnum-136);
//         }
//         else if((senampnum>==8) and (senampnum<==39))  
//         {
//            if(senampnum>==24)  
//            {
//               index = 0;
//               dbit  = 1 << (senampnum-24);
//            }
//            else
//            {
//               index = 1;
//               dbit  = 1 << (senampnum-8);
//            } 
//         }
//         else if((senampnum>==40) and (senampnum<==71))  
//         {
//            if(senampnum>==56)  
//            {
//               index = 2;
//               dbit  = 1 << (senampnum-56);
//            }
//            else
//            {
//               index = 3;
//               dbit  = 1 << (senampnum-40);
//            } 
//         }
//         else if((senampnum>==72) and (senampnum<==103))  
//         {
//            if(senampnum>==88)  
//            {
//               index = 4;
//               dbit  = 1 << (senampnum-88);
//            }
//            else
//            {
//               index = 5;
//               dbit  = 1 << (senampnum-72);
//            } 
//         }
//         else  /*104 to 135*/
//         {
//            if(senampnum>==120)  
//            {
//               index = 6;
//               dbit  = 1 << (senampnum-120);
//            }
//            else
//            {
//               index = 7;
//               dbit  = 1 << (senampnum-104);
//            } 
//         } 
//
//         din_array[index] = din_array[index] ^ dbit;  /*bit=0 means selected*/
//      }
//      else
//      {
//         index = senampnum div 16;
//         sbit = senampnum mod 16;
//         dbit = 1 << (15-sbit);
//         din_array[index] = din_array[index] ^ dbit;  /*bit=0 means selected*/
//      } 
//
//      debugprint = false;
//      if(tistdscreenprint and debugprint)  
//         cout << "Sense Amp Number " << senampnum:-5 << " DataMask == " << din_array[index]:s_hex << endl;
//         
//      for count = 0 to (numword_max-1) by 2 do
//      {
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         msw_data = din_array[count];
//         lsw_data = din_array[count+1];
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                                  msw_data,hexvalue,bcd_format);
//      }   /*for count*/
//
//      if(tistdscreenprint and debugprint)  
//         DumpRamMailbox;
//   } 
//   
//}   /* MBox_Upload_ISenAmp */
//
//
//
// /*++++++++++ Flash Tools ++++++++++*/
//
//void TL_Swizzle_VHVE(IntS value)
//{
//   IntS swizzle_val,i,j;
//
//   i = (value&0x1e0)>>5;
//   j = (value&0x01f)<<4;
//   swizzle_val = i+j;
//   if(tistdscreenprint)  
//      cout << "VHVE value==" << value:s_hex:-8 << " swizzle value==" << swizzle_val:s_hex:-8 << endl;
//} 
//   
//void TL_UnSwizzle_VHVE(IntS value)
//{
//   IntS swizzle_val,i,j;
//
//   i = (value&0x01f0)>>4;
//   j = (value&0x000f)<<5;
//   swizzle_val = i+j;
//   if(tistdscreenprint)  
//      cout << "VHVE swizzle value==" << value:s_hex:-8 << " unswizzle value==" << swizzle_val:s_hex:-8 << endl;
//}   /* TL_Swizzle_VHVE */
//   
//void TL_GetFMWInfo_TNUM(IntS tnum)
//{
//   IntS testnum,site;
//   FloatS maxtime;
//   FloatM tt_timer;
//   BoolM final_results;
//   BoolS enakey;
//
//   if(v_any_dev_active)  
//   {
//      enakey = true;
//      TL_FMW_EnableKey(enakey);  /*set enable key*/
//      maxtime = GL_F021_MAXTIME;
//      F021_RunTestNumber(tnum,maxtime,tt_timer,final_results);
//      TL_GetFMWInfo;
//      enakey = false;
//      TL_FMW_EnableKey(enakey);  /*clear enable key*/
//   } 
//}   /* TL_GetFMWInfo_TNUM */
//
// /*override 30 Time/CT index. any input param is negative then not override*/
// /*example: ovr_psu=0x28, ovr_esu= -1, ..., ovr_esu is skip*/
//void TL_EngOvride_TIME_CT(  IntS ovr_psu, IntS ovr_esu, IntS ovr_pvsu, IntS ovr_evsu, IntS 
//                               ovr_rptvsu, IntS ovr_cvsu, IntS ovr_aexezsu, IntS ovr_pvacc, IntS 
//                               ovr_ph, IntS ovr_eh, IntS ovr_rh, IntS ovr_pvh, IntS 
//                               ovr_pvh2, IntS ovr_ppw, IntS ovr_epw, IntS ovr_vstat, IntS 
//                               ovr_maxpp, IntS ovr_maxep, IntS ovr_vhv_estart_ct, IntS ovr_vhv_estep, IntS 
//                               ovr_vhv_estop_ct, IntS ovr_vhv_pg_ct, IntS ovr_vhv_er_ct, IntS ovr_vhv_pv_ct, IntS 
//                               ovr_vcg2p5_ct, IntS ovr_vinh_ct, IntS ovr_vsl_ct, IntS ovr_vwl_ct, IntS 
//                               ovr_vrd_ct, IntS ovr_vsa5_ct)
//{
//   const IntS MB_WRFLAG = 0x1234; 
//
//   IntM msw_data,lsw_data;
//   BoolS hexvalue,bcd_format;
//   IntS addr_loc,numword,count,site;
//   BoolS1D ovrena(33);
//   IntS1D ovrdata(33);
//   StringS1D ovrlabel(33);
//
//   if(v_any_dev_active)  
//   {
//      for (count = 1;count <= 32;count++)
//         ovrena[count] = false;
//      
//      bcd_format = true;
//      hexvalue = true;
//
//       /*write override index/value 1st then go back write mbox flag/numword later*/
//      numword = 0;
//      addr_loc = ADDR_RAM_MAILBOX+ADDR_RAM_INC;
//      
//      count = 1;
//      if((ovr_psu>==0) and (ovr_psu<==0xff))  
//      {
//         msw_data = OVRIND_PSU;
//         lsw_data = ovr_psu;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_psu;
//         ovrlabel[count] = "PSU";
//      }
//      else if(ovr_psu>0xff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for PSU !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_esu>==0) and (ovr_esu<==0xff))  
//      {
//         msw_data = OVRIND_ESU;
//         lsw_data = ovr_esu;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_esu;
//         ovrlabel[count] = "ESU";
//      }
//      else if(ovr_esu>0xff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for ESU !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_pvsu>==0) and (ovr_pvsu<==0xff))  
//      {
//         msw_data = OVRIND_PVSU;
//         lsw_data = ovr_pvsu;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_pvsu;
//         ovrlabel[count] = "PVSU";
//      }
//      else if(ovr_pvsu>0xff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for PVSU !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_evsu>==0) and (ovr_evsu<==0xff))  
//      {
//         msw_data = OVRIND_EVSU;
//         lsw_data = ovr_evsu;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_evsu;
//         ovrlabel[count] = "EVSU";
//      }
//      else if(ovr_evsu>0xff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for EVSU !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_rptvsu>==0) and (ovr_rptvsu<==0xff))  
//      {
//         msw_data = OVRIND_RPTVSU;
//         lsw_data = ovr_rptvsu;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_rptvsu;
//         ovrlabel[count] = "RPTVSU";
//      }
//      else if(ovr_rptvsu>0xff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for RPTVSU !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_cvsu>==0) and (ovr_cvsu<==0xff))  
//      {
//         msw_data = OVRIND_CVSU;
//         lsw_data = ovr_cvsu;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_cvsu;
//         ovrlabel[count] = "CVSU";
//      }
//      else if(ovr_cvsu>0xff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for CVSU !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_aexezsu>==0) and (ovr_aexezsu<==0xff))  
//      {
//         msw_data = OVRIND_AEXEZSU;
//         lsw_data = ovr_aexezsu;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_aexezsu;
//         ovrlabel[count] = "AEXEZSU";
//      }
//      else if(ovr_aexezsu>0xff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for AEXEZSU !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_pvacc>==0) and (ovr_pvacc<==0xff))  
//      {
//         msw_data = OVRIND_PVACC;
//         lsw_data = ovr_pvacc;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_pvacc;
//         ovrlabel[count] = "PVACC";
//      }
//      else if(ovr_pvacc>0xff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for PVACC !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_ph>==0) and (ovr_ph<==0xff))  
//      {
//         msw_data = OVRIND_PH;
//         lsw_data = ovr_ph;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_ph;
//         ovrlabel[count] = "PH";
//      }
//      else if(ovr_ph>0xff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for PH !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_eh>==0) and (ovr_eh<==0xff))  
//      {
//         msw_data = OVRIND_EH;
//         lsw_data = ovr_eh;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_eh;
//         ovrlabel[count] = "EH";
//      }
//      else if(ovr_eh>0xff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for EH !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_rh>==0) and (ovr_rh<==0xff))  
//      {
//         msw_data = OVRIND_RH;
//         lsw_data = ovr_rh;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_rh;
//         ovrlabel[count] = "RH";
//      }
//      else if(ovr_rh>0xff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for RH !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_pvh>==0) and (ovr_pvh<==0xff))  
//      {
//         msw_data = OVRIND_PVH;
//         lsw_data = ovr_pvh;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_pvh;
//         ovrlabel[count] = "PVH";
//      }
//      else if(ovr_pvh>0xff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for PVH !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_pvh2>==0) and (ovr_pvh2<==0xff))  
//      {
//         msw_data = OVRIND_PVH2;
//         lsw_data = ovr_pvh2;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_pvh2;
//         ovrlabel[count] = "PVH2";
//      }
//      else if(ovr_pvh2>0xff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for PVH2 !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_ppw>==0) and (ovr_ppw<==0xffff))  
//      {
//         msw_data = OVRIND_PPW;
//         lsw_data = ovr_ppw;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_ppw;
//         ovrlabel[count] = "PPW";
//      }
//      else if(ovr_ppw>0xffff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for PPW !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_epw>==0) and (ovr_epw<==0xfffffff))  
//      {
//         spareint1 = (ovr_epw & 0x0fff0000) >> 16;
//         msw_data = OVRIND_EPWHI;
//         lsw_data = spareint1;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         count = count+1;
//         spareint1 = ovr_epw & 0x0000ffff;
//         msw_data = OVRIND_EPW;
//         lsw_data = spareint1;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_epw;
//         ovrlabel[count] = "EPW";
//      }
//      else if(ovr_epw>0xfffffff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for EPW !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_vstat>==0) and (ovr_vstat<==0xf))  
//      {
//         msw_data = OVRIND_VSTAT;
//         lsw_data = ovr_vstat;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_vstat;
//         ovrlabel[count] = "VSTAT";
//      }
//      else if(ovr_vstat>0xf)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for VSTAT !!!" << endl;
//      } 
//      
//      count = count+1;
//      if((ovr_maxpp>==0) and (ovr_maxpp<==0xffff))  
//      {
//         msw_data = OVRIND_MAXPP;
//         lsw_data = ovr_maxpp;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_maxpp;
//         ovrlabel[count] = "MAXPP";
//      }
//      else if(ovr_maxpp>0xffff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for MAXPP !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_maxep>==0) and (ovr_maxep<==0xffff))  
//      {
//         msw_data = OVRIND_MAXEP;
//         lsw_data = ovr_maxep;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_maxep;
//         ovrlabel[count] = "MAXEP";
//      }
//      else if(ovr_maxep>0xffff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for MAXEP !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_vhv_estart_ct>==0) and (ovr_vhv_estart_ct<==0x1ff))  
//      {
//         msw_data = OVRIND_VHV_ESTART_CT;
//         lsw_data = ovr_vhv_estart_ct;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_vhv_estart_ct;
//         ovrlabel[count] = "VHV_ESTART_CT";
//      }
//      else if(ovr_vhv_estart_ct>0x1ff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for VHV_ESTART_CT !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_vhv_estep>==0) and (ovr_vhv_estep<==0x1ff))  
//      {
//         msw_data = OVRIND_VHV_ESTEP;
//         lsw_data = ovr_vhv_estep;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_vhv_estep;
//         ovrlabel[count] = "VHV_ESTEP";
//      }
//      else if(ovr_vhv_estep>0x1ff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for VHV_ESTEP !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_vhv_estop_ct>==0) and (ovr_vhv_estop_ct<==0x1ff))  
//      {
//         msw_data = OVRIND_VHV_ESTOP_CT;
//         lsw_data = ovr_vhv_estop_ct;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_vhv_estop_ct;
//         ovrlabel[count] = "VHV_ESTOP_CT";
//      }
//      else if(ovr_vhv_estop_ct>0x1ff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for VHV_ESTOP_CT !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_vhv_pg_ct>==0) and (ovr_vhv_pg_ct<==0x1ff))  
//      {
//         msw_data = OVRIND_VHV_PG_CT;
//         lsw_data = ovr_vhv_pg_ct;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_vhv_pg_ct;
//         ovrlabel[count] = "VHV_PG_CT";
//      }
//      else if(ovr_vhv_pg_ct>0x1ff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for VHV_PG_CT !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_vhv_er_ct>==0) and (ovr_vhv_er_ct<==0x1ff))  
//      {
//         msw_data = OVRIND_VHV_ER_CT;
//         lsw_data = ovr_vhv_er_ct;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_vhv_er_ct;
//         ovrlabel[count] = "VHV_ER_CT";
//      }
//      else if(ovr_vhv_er_ct>0x1ff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for VHV_ER_CT !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_vhv_pv_ct>==0) and (ovr_vhv_pv_ct<==0x1ff))  
//      {
//         msw_data = OVRIND_VHV_PV_CT;
//         lsw_data = ovr_vhv_pv_ct;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_vhv_pv_ct;
//         ovrlabel[count] = "VHV_PV_CT";
//      }
//      else if(ovr_vhv_pv_ct>0x1ff)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for VHV_PV_CT !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_vcg2p5_ct>==0) and (ovr_vcg2p5_ct<==0x1f))  
//      {
//         msw_data = OVRIND_VCG2P5_CT;
//         lsw_data = ovr_vcg2p5_ct;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_vcg2p5_ct;
//         ovrlabel[count] = "VCG2P5_CT";
//      }
//      else if(ovr_vcg2p5_ct>0x1f)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for VCG2P5_CT !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_vinh_ct>==0) and (ovr_vinh_ct<==0x1f))  
//      {
//         msw_data = OVRIND_VINH_CT;
//         lsw_data = ovr_vinh_ct;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_vinh_ct;
//         ovrlabel[count] = "VINH_CT";
//      }
//      else if(ovr_vinh_ct>0x1f)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for VINH_CT !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_vsl_ct>==0) and (ovr_vsl_ct<==0xf))  
//      {
//         msw_data = OVRIND_VSL_CT;
//         lsw_data = ovr_vsl_ct;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_vsl_ct;
//         ovrlabel[count] = "VSL_CT";
//      }
//      else if(ovr_vsl_ct>0xf)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for VSL_CT !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_vwl_ct>==0) and (ovr_vwl_ct<==0x1f))  
//      {
//         msw_data = OVRIND_VWL_CT;
//         lsw_data = ovr_vwl_ct;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_vwl_ct;
//         ovrlabel[count] = "VWL_CT";
//      }
//      else if(ovr_vwl_ct>0x1f)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for VWL_CT !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_vrd_ct>==0) and (ovr_vrd_ct<==0xf))  
//      {
//         msw_data = OVRIND_VRD_CT;
//         lsw_data = ovr_vrd_ct;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_vrd_ct;
//         ovrlabel[count] = "VRD_CT";
//      }
//      else if(ovr_vrd_ct>0xf)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for VRD_CT !!!" << endl;
//      } 
//
//      count = count+1;
//      if((ovr_vsa5_ct>==0) and (ovr_vsa5_ct<==0xf))  
//      {
//         msw_data = OVRIND_VSA5_CT;
//         lsw_data = ovr_vsa5_ct;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         numword = numword+1;
//         addr_loc = addr_loc+ADDR_RAM_INC;
//         ovrena[count]   = true;
//         ovrdata[count]  = ovr_vsa5_ct;
//         ovrlabel[count] = "VSA5_CT";
//      }
//      else if(ovr_vsa5_ct>0xf)  
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: Invalid override data for VSA5_CT !!!" << endl;
//      } 
//
//       /*write mbox flag/numword*/
//      addr_loc = ADDR_RAM_MAILBOX;
//      msw_data = MB_WRFLAG;
//      lsw_data = numword;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      if(tistdscreenprint)  
//      {
//         if(TI_FlashDebug)  
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//                  readramaddress(site,addr_loc,addr_loc+(count*ADDR_RAM_INC));
//         
//         cout << endl;
//         cout << "Eng Override Timing/CT Setting" << endl;
//         cout << "++++++++++++++++++++++++++++++" << endl;
//         for (numword = 1;numword <= count;numword++)
//            if(ovrena[numword])  
//               cout << ovrlabel[numword]:15 << " == " << ovrdata[numword]:s_hex:-10 << endl;
//         cout << endl;
//      } 
//      
//   }   /*if v_any_dev_active*/
//}   /* TL_EngOvride_TIME_CT */
//   
//void TL_EngOvride_IP()
//{
//   const IntS MAXNUMWORD = 30; 
//
//   BoolS1D ovrena(33);
//   IntS1D ovrdata(33);
//   IntS numword,count;
//
//   if(v_any_dev_active)  
//   {
//      for (count = 1;count <= MAXNUMWORD;count++)
//         ovrena[count] = false;
//
//      if(tistdscreenprint)  
//         cout << "Please Enter Selection on Execution Window" << endl;
//
//      numword = 0;
//
//      for (count = 1;count <= MAXNUMWORD;count++)
//      {
//      } 
//
//   }   /*if v_any_dev_active*/
//}   /* TL_EngOvride_IP */
//
//void TL_ArbitraryRead(IntS banknum,
//                           IntS msw_addr,
//                           IntS lsw_addr,
//                           IntS msw_length,
//                           IntS lsw_length)
//{
//   IntS site,testnum;
//   IntS addr_loc,length;
//   FloatM tt_timer;
//   BoolM final_results;
//   StringS str1,str2,str3,str4;
//   FloatS maxtime;
//
//   if(v_any_dev_active)  
//   {
//      TL_SetARBADDR(msw_addr,lsw_addr);
//      TL_SetARBLENGTH(msw_length,lsw_length);
//         
//      final_results = v_dev_active;
//
//      maxtime = GL_F021_MAXTIME;
//      testnum =  0x80000A00 + (banknum<<4); /*TNUM_BANK_ARB_RD*/
//      F021_RunTestNumber(testnum,maxtime,tt_timer,final_results);
//         
//      if(tistdscreenprint)  
//      {
//         if(TI_FlashDebug)  
//         {
//            PrintHeaderBool(GL_PLELL_FORMAT);
//            PrintResultBool("ArbitraryRead",testnum,final_results,GL_PLELL_FORMAT);
//         } 
//         writestring(str1,msw_addr:s_hex:-1);
//         writestring(str2,lsw_addr:s_hex:-1);
//         length = len(str2);
//         str2 = mid(str2,3,length-2);
//         while((len(str2)) < 4) do
//            str2 = "0" + str2;
//         str1 = str1 + str2;
//         writestring(str3,msw_length:s_hex:-1);
//         writestring(str4,lsw_length:s_hex:-1);
//         length = len(str4);
//         str4 = mid(str4,3,length-2);
//         while((len(str4)) < 4) do
//            str4 = "0" + str4;
//         str3 = str3 + str4;
// /*         
//          writeln(tiwindow,"Flash Aribtrary Read - Bank",banknum:-4,
//                  " Start address = ",str1:-14," Length = ",str3:-14);
//          addr_loc := ADDR_RAM_MAILBOX;
//          length := ((msw_length<<16)+lsw_length) >>2;
//          for site := 1 to v_sites do
//             if(v_dev_active[site]) then
//                readramaddress(site,addr_loc,addr_loc+length); */
//      }   /*if tistdscreenprint*/
//
//   }   /*if v_any_dev_active*/
//   
//}   /* TL_ArbitraryRead */
//
//   
//void TL_IV_Curve(IntS Address,
//                      IntS SenAmpNum,
//                      FloatS Start_V,
//                      FloatS Stop_V,
//                      FloatS Inc_V,
//                      BoolS OvrideBL,
//                      FloatS BLBias_Vforce,
//                      BoolS Test_All_IOS)
//{
//   const IntS MINSENAMP = 0; 
//   const IntS MAXSENAMP = 288; 
//   const IntS MAXSAMPLE = 4096; 
//   const  TARGET_ARB = 0x00000A00;  /* :MANUAL FIX REQUIRED: Unknown const type */
//
//   IntS site,counter,numread;
//   FloatM iref_rd_ARRAY,meas_val;
//   Array[MINSENAMP..MAXSENAMP,1..MAXSAMPLE,1..NUMSITES] of FloatS iv_rd_ARRAY; 
//   BoolM tmp_results;
//   IntS tnum_iv,tnum_iref,msw_addr,lsw_addr;
//   FloatS tdelay1,tdelay2,tdelay3,maxtime;
//   FloatS llim,ulim,vstart,vstop;
//   IntS fdlen1,fdlen2,unitlen,decpt;
//   FloatS tmpFloatS;
//   FloatS vforce_BLV,vProg,tp_iProg,cp_IProg;
//   IntS test_IOS,min_IOS,max_IOS;
//   IntS tcrnum_iref,tcrnum;
//   TPModeType tcrmode_iref,tcrmode;
//   PinM tp_iref;
//   PinM tp_iv,cp_iv;
//   StringS str1,str2,str3,current_shell;
//   BoolS debugprint;
//   option vdd_pgmMode,vdd_iGMode;
//   FloatS vdd_iProg,vdd_vProg;
//
//
//   if(v_any_dev_active)  
//   {
//      current_shell = "FlashShell";
//      if(GL_PREVIOUS_SHELL != current_shell)  
//         F021_LoadFlashShell_func;
//      
//      tdelay1 = 2ms;
//      tdelay2 = 10ms;
//      tdelay3 = 100ms;
//      maxtime = GL_F021_PARAM_MAXTIME;
//      numread = 20;
//      
//
//       /*+++ Measure IrefRd +++*/
//      tnum_iref = TNUM_BANK_IREF_READ_EVEN;      
//      tcrnum_iref = 25;
//      tcrmode_iref = ReadMode;
//      tp_iref = FLTP2;
//      
//      tcrnum  = 128;
//      tcrmode = ReadMode;
//      TCR.TP1_Ena[tcrnum] = true;
//      TCR.TP1_MeasType[tcrnum] = ForceVoltType;
//      TCR.TP1_VRange[tcrnum][tcrmode] = TCR.TP1_VRange[tcrnum_iref][tcrmode_iref];
//      TCR.TP1_IRange[tcrnum][tcrmode] = TCR.TP1_IRange[tcrnum_iref][tcrmode_iref];
//      TCR.TP1_ULim[tcrnum][tcrmode]   = TCR.TP1_ULim[tcrnum_iref][tcrmode_iref];
//      TCR.TP1_LLim[tcrnum][tcrmode]   = TCR.TP1_LLim[tcrnum_iref][tcrmode_iref];
//
//      TCR.TP2_Ena[tcrnum] = true;
//      TCR.TP2_MeasType[tcrnum] = MeasCurrType;       
//      TCR.TP2_VRange[tcrnum][tcrmode] = TCR.TP2_VRange[tcrnum_iref][tcrmode_iref];
//      TCR.TP2_IRange[tcrnum][tcrmode] = TCR.TP2_IRange[tcrnum_iref][tcrmode_iref];
//      TCR.TP2_ULim[tcrnum][tcrmode]   = TCR.TP2_ULim[tcrnum_iref][tcrmode_iref];
//      TCR.TP2_LLim[tcrnum][tcrmode]   = TCR.TP2_LLim[tcrnum_iref][tcrmode_iref];
//
//      TCR.TP3_Ena[tcrnum] = false;
//      TCR.TP4_Ena[tcrnum] = false;
//      TCR.TP5_Ena[tcrnum] = false;
//      TCR.TADC_Ena[tcrnum] = false;
//     
//      llim = TCR.TP2_LLim[tcrnum][tcrmode];
//      ulim = TCR.TP2_ULim[tcrnum][tcrmode];
//      
//      if(OvrideBL)  
//         vforce_BLV = BLBias_Vforce;
//      else
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               STDGetVI(VDD,vdd_vProg,vdd_iProg);
//               break;
//            } 
//         vforce_BLV = vdd_vProg;
//      } 
//      
//      iref_rd_ARRAY =  0A;
//      F021_Set_TPADS(tcrnum,tcrmode);
//      TIME.Wait(tdelay1);
//      if(TI_FlashDebug)  
//      {
//         F021_RunTestNumber_PMEX(tnum_iref,maxtime,tmp_results);
//         TIME.Wait(tdelay2);
//         F021_Meas_TPAD_PMEX(tp_iref,tcrnum,tcrmode,llim,ulim,iref_rd_ARRAY,tmp_results);
//         Disable(s_pmexit);
//         F021_TurnOff_AllTPADS;
//         
//         if(tistdscreenprint)  
//         {
//            cout << "TP1(VCG)== " << TCR.TP1_VRange[tcrnum][tcrmode]:-5:3 << 
//                    "  TP2(VBL)== " << vforce_BLV:-5:3 << endl;
//            str1 = "IREF_RD";
//            PrintHeaderParam(GL_PLELL_FORMAT);
//            PrintResultParam(str1,tnum_iref,tmp_results,llim,ulim,iref_rd_ARRAY,GL_PLELL_FORMAT);
//         } 
//      } 
//
//       /*+++ Collecting IV Curve +++*/
//      tnum_iv    = TNUM_BITLINE_ACCESS+TARGET_ARB;
//      cp_iv      = FLTP1;
//      cp_iProg   = 100mA;
//      tp_iv      = FLTP2;
//      tp_iProg   = 500uA;
//
//      if(Test_All_IOS)  
//      {
//         min_IOS = 0;
//         max_IOS = F021_Flash.DATAWIDTH-1;
//      }
//      else
//      {
//         min_IOS = SenAmpNum;
//         max_IOS = SenAmpNum;
//      } 
//
//      debugprint = false;
//
//      if(start_v<stop_v)  
//      {
//         vstart = start_v;
//         vstop  = stop_v;
//      }
//      else
//      {
//         vstart = stop_v;
//         vstop  = start_v;
//      } 
//      
//      for (test_IOS = MIN_IOS;test_IOS <= max_IOS;test_IOS++)
//      {
//         msw_addr = ((Address&0xffff0000) >>16) & 0xffff;
//         lsw_addr = Address&0x0000ffff;
//         TL_SetARBADDR(msw_addr,lsw_addr);
//         MBox_Upload_ISenAmp(test_IOs);
//         
//         STDSetVRange(cp_iv,vstop);
//         STDSetVI(cp_iv,vstart,cp_iProg);
//         STDSetVRange(tp_iv,vforce_BLV);
//         STDSetVI(tp_iv,vforce_BLV,tp_iProg);
//
//         TIME.Wait(tdelay1);
//         F021_RunTestNumber_PMEX(tnum_iv,maxtime,tmp_results);
//         TIME.Wait(tdelay3);
//         ClockStopFreeRun(S_Clock1A);
//      
//          /*+++ Start collecting IV Curve data and store it in an array +++*/
//         STDSetVRange(cp_iv,stop_v);
//            
//         counter=1;
//         for vProg = Start_V to Stop_V by Inc_V do
//         {
//            STDSetVI(cp_iv,vProg,cp_iProg);
//            TIME.Wait(tdelay2);
//            STDMeasI(tp_iv,numread,meas_val);
//            iv_rd_Array[test_IOS][counter] = meas_val;
//             /*added for tcr1 vs. tcr6 debug func. note: save on a single senseamp only & max of 512 steps*/
//            if(GL_DO_SAVE_IV_DATA)  
//            {
//               FL_IV_DATA[counter] = meas_val;
//               FL_IV_DATA_COUNT = counter;
//            } 
//            if(debugprint and tistdscreenprint)  
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                     cout << "Site" << site:-5 << " test_IOS==" << test_IOS:-5 << 
//                             " counter==" << counter:-5 << " vProg==" << vProg:-5:3 << " ISA==" << meas_val[site] << endl;
//            counter=counter + 1;
//            if(counter>MAXSAMPLE)  
//            {
//               if(tistdscreenprint)  
//                  cout << "*** Exceeding sample " << MAXSAMPLE << endl;
//               break;
//            } 
//         }   /*for vProg*/
//         
//         Disable(S_PMEXIT);
//         STDSetVI(cp_iv,0v,cp_iProg);
//         TIME.Wait(tdelay1);
//      }   /*for test_IOS*/
//
//      STDSetVI(cp_iv,0v,1mA);
//      STDSetVI(tp_iv,0v,1mA);
//      Wait(tdelay2);
//      TL_SetARBADDR(0,0);
//
//      
//       /* Display IV Curve data and IRefRd results */
//      if(tistdscreenprint)  
//      {
//         fdlen1  = 30;
//         fdlen2  = 12;
//         decpt   = 3;
//
//         cout << endl;
//         cout << TIWindow << "IV Curve results:  Address==" << Address:s_hex:-12 << endl;
//         cout << endl;
//
//         str1 = "IV_CURVE";
//         cout << str1:-fdlen1 << " " << "VCG":fdlen2 << " " << "VBL":fdlen2 << " ";
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               writestring(str2,site:1);
//               str2 = "Site" + str2;
//               str2 = str2 + "_I(uA)";
//               cout << str2:fdlen2 << " ";
//            } 
//         cout << endl;
//
//         for (test_IOS = min_IOS;test_IOS <= max_IOS;test_IOS++)
//         {
//            writestring(str1,test_IOS:1);
//            str1 = "IV_CURVE_SA" + str1;
//
//            counter=1;
//            for vProg = vstart to vstop by Inc_V do
//            {
//               cout << str1:-fdlen1 << " ";
//               tmpreal = single(vProg/1v);
//               cout << tmpreal:fdlen2:decpt << " ";
//               tmpreal = single(vforce_BLV/1v);
//               cout << tmpreal:fdlen2:decpt << " ";
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                  {
//                     tmpreal = single(iv_rd_Array[test_IOS][counter][site]/1uA);
//                     cout << tmpreal:fdlen2:decpt << " ";
//                  } 
//               cout << endl;
//               counter = counter+1;
//               if(counter>MAXSAMPLE)  
//                  break;
//            }   /*for vProg*/
//         }   /*for test_IOS*/
//
//         cout << endl;
//      }   /*tistdscreenprint*/
//      
//   }   /*if v_any_dev_active*/
//}   /* TL_IV_Curve */


void CloneTCR_To_TCR128(TPModeType tcrmode_tget,
                             TPModeType tcrmode_src,
                             IntS tcrnum_src)
{
   const IntS TCR128 = 128; 

   TCR.TP1_Ena[TCR128] = TCR.TP1_Ena[tcrnum_src];
   TCR.TP1_MeasType[TCR128] = TCR.TP1_MeasType[tcrnum_src];
   TCR.TP1_VRange[TCR128][tcrmode_tget]  = TCR.TP1_VRange[tcrnum_src][tcrmode_src];
   TCR.TP1_IRange[TCR128][tcrmode_tget]  = TCR.TP1_IRange[tcrnum_src][tcrmode_src];
   TCR.TP1_ULim[TCR128][tcrmode_tget]    = TCR.TP1_ULim[tcrnum_src][tcrmode_src];
   TCR.TP1_LLim[TCR128][tcrmode_tget]    = TCR.TP1_LLim[tcrnum_src][tcrmode_src];
   TCR.TP1_FTime[TCR128][tcrmode_tget]   = TCR.TP1_FTime[tcrnum_src][tcrmode_src];
   TCR.TP1_VCharLo[TCR128][tcrmode_tget] = TCR.TP1_VCharLo[tcrnum_src][tcrmode_src];
   TCR.TP1_VCharHi[TCR128][tcrmode_tget] = TCR.TP1_VCharHi[tcrnum_src][tcrmode_src];
   
   TCR.TP2_Ena[TCR128] = TCR.TP2_Ena[tcrnum_src];
   TCR.TP2_MeasType[TCR128] = TCR.TP2_MeasType[tcrnum_src];
   TCR.TP2_VRange[TCR128][tcrmode_tget]  = TCR.TP2_VRange[tcrnum_src][tcrmode_src];
   TCR.TP2_IRange[TCR128][tcrmode_tget]  = TCR.TP2_IRange[tcrnum_src][tcrmode_src];
   TCR.TP2_ULim[TCR128][tcrmode_tget]    = TCR.TP2_ULim[tcrnum_src][tcrmode_src];
   TCR.TP2_LLim[TCR128][tcrmode_tget]    = TCR.TP2_LLim[tcrnum_src][tcrmode_src];
   TCR.TP2_FTime[TCR128][tcrmode_tget]   = TCR.TP2_FTime[tcrnum_src][tcrmode_src];
   TCR.TP2_VCharLo[TCR128][tcrmode_tget] = TCR.TP2_VCharLo[tcrnum_src][tcrmode_src];
   TCR.TP2_VCharHi[TCR128][tcrmode_tget] = TCR.TP2_VCharHi[tcrnum_src][tcrmode_src];
   
   TCR.TP3_Ena[TCR128] = TCR.TP3_Ena[tcrnum_src];
   TCR.TP3_MeasType[TCR128] = TCR.TP3_MeasType[tcrnum_src];
   TCR.TP3_VRange[TCR128][tcrmode_tget]  = TCR.TP3_VRange[tcrnum_src][tcrmode_src];
   TCR.TP3_IRange[TCR128][tcrmode_tget]  = TCR.TP3_IRange[tcrnum_src][tcrmode_src];
   TCR.TP3_ULim[TCR128][tcrmode_tget]    = TCR.TP3_ULim[tcrnum_src][tcrmode_src];
   TCR.TP3_LLim[TCR128][tcrmode_tget]    = TCR.TP3_LLim[tcrnum_src][tcrmode_src];
   TCR.TP3_FTime[TCR128][tcrmode_tget]   = TCR.TP3_FTime[tcrnum_src][tcrmode_src];
   TCR.TP3_VCharLo[TCR128][tcrmode_tget] = TCR.TP3_VCharLo[tcrnum_src][tcrmode_src];
   TCR.TP3_VCharHi[TCR128][tcrmode_tget] = TCR.TP3_VCharHi[tcrnum_src][tcrmode_src];
   
   TCR.TP4_Ena[TCR128] = TCR.TP4_Ena[tcrnum_src];
   TCR.TP4_MeasType[TCR128] = TCR.TP4_MeasType[tcrnum_src];
   TCR.TP4_VRange[TCR128][tcrmode_tget]  = TCR.TP4_VRange[tcrnum_src][tcrmode_src];
   TCR.TP4_IRange[TCR128][tcrmode_tget]  = TCR.TP4_IRange[tcrnum_src][tcrmode_src];
   TCR.TP4_ULim[TCR128][tcrmode_tget]    = TCR.TP4_ULim[tcrnum_src][tcrmode_src];
   TCR.TP4_LLim[TCR128][tcrmode_tget]    = TCR.TP4_LLim[tcrnum_src][tcrmode_src];
   TCR.TP4_FTime[TCR128][tcrmode_tget]   = TCR.TP4_FTime[tcrnum_src][tcrmode_src];
   TCR.TP4_VCharLo[TCR128][tcrmode_tget] = TCR.TP4_VCharLo[tcrnum_src][tcrmode_src];
   TCR.TP4_VCharHi[TCR128][tcrmode_tget] = TCR.TP4_VCharHi[tcrnum_src][tcrmode_src];
   
   TCR.TP5_Ena[TCR128] = TCR.TP5_Ena[tcrnum_src];
   TCR.TP5_MeasType[TCR128] = TCR.TP5_MeasType[tcrnum_src];
   TCR.TP5_VRange[TCR128][tcrmode_tget]  = TCR.TP5_VRange[tcrnum_src][tcrmode_src];
   TCR.TP5_IRange[TCR128][tcrmode_tget]  = TCR.TP5_IRange[tcrnum_src][tcrmode_src];
   TCR.TP5_ULim[TCR128][tcrmode_tget]    = TCR.TP5_ULim[tcrnum_src][tcrmode_src];
   TCR.TP5_LLim[TCR128][tcrmode_tget]    = TCR.TP5_LLim[tcrnum_src][tcrmode_src];
   TCR.TP5_FTime[TCR128][tcrmode_tget]   = TCR.TP5_FTime[tcrnum_src][tcrmode_src];
   TCR.TP5_VCharLo[TCR128][tcrmode_tget] = TCR.TP5_VCharLo[tcrnum_src][tcrmode_src];
   TCR.TP5_VCharHi[TCR128][tcrmode_tget] = TCR.TP5_VCharHi[tcrnum_src][tcrmode_src];
   
   TCR.TADC_Ena[TCR128] = TCR.TADC_Ena[tcrnum_src];
   TCR.TADC_MeasType[TCR128] = TCR.TADC_MeasType[tcrnum_src];
   TCR.TADC_VRange[TCR128][tcrmode_tget]  = TCR.TADC_VRange[tcrnum_src][tcrmode_src];
   TCR.TADC_IRange[TCR128][tcrmode_tget]  = TCR.TADC_IRange[tcrnum_src][tcrmode_src];
   TCR.TADC_ULim[TCR128][tcrmode_tget]    = TCR.TADC_ULim[tcrnum_src][tcrmode_src];
   TCR.TADC_LLim[TCR128][tcrmode_tget]    = TCR.TADC_LLim[tcrnum_src][tcrmode_src];
   TCR.TADC_FTime[TCR128][tcrmode_tget]   = TCR.TADC_FTime[tcrnum_src][tcrmode_src];
   TCR.TADC_VCharLo[TCR128][tcrmode_tget] = TCR.TADC_VCharLo[tcrnum_src][tcrmode_src];
   TCR.TADC_VCharHi[TCR128][tcrmode_tget] = TCR.TADC_VCharHi[tcrnum_src][tcrmode_src];
}   /* CloneTCR_To_TCR128 */
   
void RestoreTCR_Fr_TCR128(TPModeType tcrmode_tget,
                               TPModeType tcrmode_src,
                               IntS tcrnum_src)
{
   const IntS TCR128 = 128; 

   TCR.TP1_Ena[tcrnum_src] = TCR.TP1_Ena[TCR128];
   TCR.TP1_MeasType[tcrnum_src] = TCR.TP1_MeasType[TCR128];
   TCR.TP1_VRange[tcrnum_src][tcrmode_src]  = TCR.TP1_VRange[TCR128][tcrmode_tget];
   TCR.TP1_IRange[tcrnum_src][tcrmode_src]  = TCR.TP1_IRange[TCR128][tcrmode_tget];
   TCR.TP1_ULim[tcrnum_src][tcrmode_src]    = TCR.TP1_ULim[TCR128][tcrmode_tget];
   TCR.TP1_LLim[tcrnum_src][tcrmode_src]    = TCR.TP1_LLim[TCR128][tcrmode_tget];
   TCR.TP1_FTime[tcrnum_src][tcrmode_src]   = TCR.TP1_FTime[TCR128][tcrmode_tget];
   TCR.TP1_VCharLo[tcrnum_src][tcrmode_src] = TCR.TP1_VCharLo[TCR128][tcrmode_tget];
   TCR.TP1_VCharHi[tcrnum_src][tcrmode_src] = TCR.TP1_VCharHi[TCR128][tcrmode_tget];
   
   TCR.TP2_Ena[tcrnum_src] = TCR.TP2_Ena[TCR128];
   TCR.TP2_MeasType[tcrnum_src] = TCR.TP2_MeasType[TCR128];
   TCR.TP2_VRange[tcrnum_src][tcrmode_src]  = TCR.TP2_VRange[TCR128][tcrmode_tget];
   TCR.TP2_IRange[tcrnum_src][tcrmode_src]  = TCR.TP2_IRange[TCR128][tcrmode_tget];
   TCR.TP2_ULim[tcrnum_src][tcrmode_src]    = TCR.TP2_ULim[TCR128][tcrmode_tget];
   TCR.TP2_LLim[tcrnum_src][tcrmode_src]    = TCR.TP2_LLim[TCR128][tcrmode_tget];
   TCR.TP2_FTime[tcrnum_src][tcrmode_src]   = TCR.TP2_FTime[TCR128][tcrmode_tget];
   TCR.TP2_VCharLo[tcrnum_src][tcrmode_src] = TCR.TP2_VCharLo[TCR128][tcrmode_tget];
   TCR.TP2_VCharHi[tcrnum_src][tcrmode_src] = TCR.TP2_VCharHi[TCR128][tcrmode_tget];
   
   TCR.TP3_Ena[tcrnum_src] = TCR.TP3_Ena[TCR128];
   TCR.TP3_MeasType[tcrnum_src] = TCR.TP3_MeasType[TCR128];
   TCR.TP3_VRange[tcrnum_src][tcrmode_src]  = TCR.TP3_VRange[TCR128][tcrmode_tget];
   TCR.TP3_IRange[tcrnum_src][tcrmode_src]  = TCR.TP3_IRange[TCR128][tcrmode_tget];
   TCR.TP3_ULim[tcrnum_src][tcrmode_src]    = TCR.TP3_ULim[TCR128][tcrmode_tget];
   TCR.TP3_LLim[tcrnum_src][tcrmode_src]    = TCR.TP3_LLim[TCR128][tcrmode_tget];
   TCR.TP3_FTime[tcrnum_src][tcrmode_src]   = TCR.TP3_FTime[TCR128][tcrmode_tget];
   TCR.TP3_VCharLo[tcrnum_src][tcrmode_src] = TCR.TP3_VCharLo[TCR128][tcrmode_tget];
   TCR.TP3_VCharHi[tcrnum_src][tcrmode_src] = TCR.TP3_VCharHi[TCR128][tcrmode_tget];
   
   TCR.TP4_Ena[tcrnum_src] = TCR.TP4_Ena[TCR128];
   TCR.TP4_MeasType[tcrnum_src] = TCR.TP4_MeasType[TCR128];
   TCR.TP4_VRange[tcrnum_src][tcrmode_src]  = TCR.TP4_VRange[TCR128][tcrmode_tget];
   TCR.TP4_IRange[tcrnum_src][tcrmode_src]  = TCR.TP4_IRange[TCR128][tcrmode_tget];
   TCR.TP4_ULim[tcrnum_src][tcrmode_src]    = TCR.TP4_ULim[TCR128][tcrmode_tget];
   TCR.TP4_LLim[tcrnum_src][tcrmode_src]    = TCR.TP4_LLim[TCR128][tcrmode_tget];
   TCR.TP4_FTime[tcrnum_src][tcrmode_src]   = TCR.TP4_FTime[TCR128][tcrmode_tget];
   TCR.TP4_VCharLo[tcrnum_src][tcrmode_src] = TCR.TP4_VCharLo[TCR128][tcrmode_tget];
   TCR.TP4_VCharHi[tcrnum_src][tcrmode_src] = TCR.TP4_VCharHi[TCR128][tcrmode_tget];
   
   TCR.TP5_Ena[tcrnum_src] = TCR.TP5_Ena[TCR128];
   TCR.TP5_MeasType[tcrnum_src] = TCR.TP5_MeasType[TCR128];
   TCR.TP5_VRange[tcrnum_src][tcrmode_src]  = TCR.TP5_VRange[TCR128][tcrmode_tget];
   TCR.TP5_IRange[tcrnum_src][tcrmode_src]  = TCR.TP5_IRange[TCR128][tcrmode_tget];
   TCR.TP5_ULim[tcrnum_src][tcrmode_src]    = TCR.TP5_ULim[TCR128][tcrmode_tget];
   TCR.TP5_LLim[tcrnum_src][tcrmode_src]    = TCR.TP5_LLim[TCR128][tcrmode_tget];
   TCR.TP5_FTime[tcrnum_src][tcrmode_src]   = TCR.TP5_FTime[TCR128][tcrmode_tget];
   TCR.TP5_VCharLo[tcrnum_src][tcrmode_src] = TCR.TP5_VCharLo[TCR128][tcrmode_tget];
   TCR.TP5_VCharHi[tcrnum_src][tcrmode_src] = TCR.TP5_VCharHi[TCR128][tcrmode_tget];
   
   TCR.TADC_Ena[tcrnum_src] = TCR.TADC_Ena[TCR128];
   TCR.TADC_MeasType[tcrnum_src] = TCR.TADC_MeasType[TCR128];
   TCR.TADC_VRange[tcrnum_src][tcrmode_src]  = TCR.TADC_VRange[TCR128][tcrmode_tget];
   TCR.TADC_IRange[tcrnum_src][tcrmode_src]  = TCR.TADC_IRange[TCR128][tcrmode_tget];
   TCR.TADC_ULim[tcrnum_src][tcrmode_src]    = TCR.TADC_ULim[TCR128][tcrmode_tget];
   TCR.TADC_LLim[tcrnum_src][tcrmode_src]    = TCR.TADC_LLim[TCR128][tcrmode_tget];
   TCR.TADC_FTime[tcrnum_src][tcrmode_src]   = TCR.TADC_FTime[TCR128][tcrmode_tget];
   TCR.TADC_VCharLo[tcrnum_src][tcrmode_src] = TCR.TADC_VCharLo[TCR128][tcrmode_tget];
   TCR.TADC_VCharHi[tcrnum_src][tcrmode_src] = TCR.TADC_VCharHi[TCR128][tcrmode_tget];
}   /* RestoreTCR_Fr_TCR128 */
   
//void TL_PumpOutput_VHV(VCornerType vcorner)
//{
//   const IntS MINCT = 0; 
//   const IntS MAXCT = 511; 
//   const IntS MINPARM = 1; 
//   const IntS MAXPARM = 3; 
//   const IntS MINSLP = 0; 
//   const IntS MAXSLP = 15; 
//
//   IntS tcrnum_vhv,tcrnum,site,loop,i,j,tnum;
//   TPModeType tcrmode;
//   array[MINPARM..MAXPARM] of TPModeType tcrmode_vhv; /* Unknown Array type :MANUAL FIX REQUIRED: */ /* :MANUAL FIX REQUIRED: array dimensions are : MINPARM..MAXPARM */
//   IntS1D tnum_vhv; /* :MANUAL FIX REQUIRED: array dimensions are : MINPARM..MAXPARM */
//   PinM tpad;
//   FloatS maxtime,tdelay,tdelay2,ttimer1,llim,ulim;
//   FloatM meas_value,tt_timer;
//   FloatM2D pvalue; /* :MANUAL FIX REQUIRED: array dimensions are : MINPARM..MAXPARM,MINCT..MAXCT */
//   StringS str1,str2,str3,str4,str5;
//   FloatM FloatSval;
//   TWunit unitval;
//   FloatS FloatS1,FloatS2;
//   BoolM spbool1,spbool2;
//   IntS minloop,maxloop,minp,maxp,addr_loc;
//   IntS slpct,slpctmin,slpctmax;
//   IntM msw_val,lsw_val,vsa5val,slpval,foscval;
//    /*-----------------------*/
//   procedure SetVHVSlopeCT; /* didn"t match any chunk types, FIX */
//   var
//      IntS ctval,addr;
//      IntM msw_data,lsw_data;
//   
//      addr = ADDR_RAM_SLOPECT_TRIM;
//      ctval = slpct;
//      arrayaddintegervalue(msw_data,vsa5val,ctval,v_sites);
//      WriteRamContentDec_32Bit(addr,foscval,true,msw_data,true,true);
//   } 
//    /*-----------------------*/
//{
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint)  
//      {
//         cout << endl;
//         cout << "**** TL_PumpOutput_VHV ****" << endl;
//         cout << endl;
//      } 
//      
//      maxtime = GL_F021_PARAM_MAXTIME;
//      tdelay  = 50ms;
//      tdelay2 = 5ms;
//
//      tcrnum_vhv  = 115;
//      tpad        = FLTP1;
//      tnum_vhv[1] = TNUM_PUMP_VHVPROG;
//      tnum_vhv[2] = TNUM_PUMP_VHVERS;
//      tnum_vhv[3] = TNUM_PUMP_VHVPVFY;
//      tcrmode_vhv[1]  = ProgMode;
//      tcrmode_vhv[2]  = ErsMode;
//      tcrmode_vhv[3]  = PvfyMode;
//
//      tcrnum      = 128;
//
//      minloop = MINCT;
//      maxloop = MAXCT;
//      minp    = MINPARM;
//      maxp    = MAXPARM;
//
//      switch(vcorner) {
//        case  VMN: case VMNO: case VMNE :   
//           PowerUpAtVmin(dcsetup_loosevmin,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vmin],v[vil_loose]);
//         break; 
//        case  VNM: case VNMO: case VNME :   
//           PowerUpAtVnom(dcsetup_loosevnom,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vnom],v[vil_loose]);
//         break; 
//        case  VMX: case VMXO: case VMXE :   
//           PowerUpAtVmax(dcsetup_loosevmax,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vmax],v[vil_loose]);
//         break; 
//        default:  
//           PowerUpAtVnom(dcsetup_loosevnom,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vnom],v[vil_loose]);
//         break;            
//      }   /* case */
//
//      TIME.Wait(tdelay2);
//      if(GL_PREVIOUS_SHELL != "FlashShell")        
//         f021_loadflashshell_func;
//
//      for (i = minp;i <= maxp;i++)
//      {
//         tnum    = tnum_vhv[i];
//         tcrmode = tcrmode_vhv[i];
//         CloneTCR_TO_TCR128(tcrmode,tcrmode,tcrnum_vhv);
//         llim = TCR.TP1_LLim[tcrnum][tcrmode];
//         ulim = TCR.TP1_ULim[tcrnum][tcrmode];
//
//         if(i==minp)  
//         {
//            slpctmin = MINSLP;
//            slpctmax = MAXSLP;
//         }
//         else
//         {
//            slpctmin = MINSLP;
//            slpctmax = MINSLP;
//         }             
//
//         for (slpct = slpctmin;slpct <= slpctmax;slpct++)
//         {
//            if(tistdscreenprint)  
//            {
//               spbool2 = v_dev_active;
//               PrintHeaderParam(GL_PLELL_FORMAT);
//            } 
//
//            if(i==minp)  
//            {
//                /*read once*/
//               if(slpct==slpctmin)  
//               {
//                  addr_loc = ADDR_RAM_SLOPECT_TRIM;
//                  GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_val);
//                  GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,foscval);
//                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                     if(v_dev_active[site])  
//                     {
//                        vsa5val[site] = (msw_val[site]>>8) & 0xff;
//                        slpval[site] = msw_val[site] & 0xff;
//                     } 
//               } 
//               SetVHVSlopeCT;
//            }
//            else
//            {
//                /*restore orig value*/
//               WriteRamContentDec_32Bit(addr_loc,foscval,true,msw_val,true,true);
//            } 
//            
//            for (loop = minloop;loop <= maxloop;loop++)
//            {
//               F021_TurnOff_AllTpads;
//               
//               switch(i) {
//                 case 1 : TL_EngOvride_VHV_PG_CT(loop);
//                 case 2 : TL_EngOvride_VHV_ER_CT(loop);
//                 case 3 : TL_EngOvride_VHV_PV_CT(loop);
//               }   /* case */
//               
//               TIME.Wait(tdelay2);
//               F021_RunTestNumber_PMEX(tnum,maxtime,spbool1);
//               TIME.Wait(tdelay);
//               F021_Set_TPADS(tcrnum,tcrmode);
//               F021_Meas_TPAD_PMEX(tpad,tcrnum,tcrmode,llim,ulim,meas_value,spbool1);
//               F021_TurnOff_AllTpads;
//               Disable(s_pmexit);
//               TIME.Wait(tdelay2);
//                /*ArraycopyTreal(pvalue[i,loop],meas_value,v_sites);*/
//
//               if(tistdscreenprint)  
//               {
//                  switch(i) {
//                    case 1 : str1 = "VHV_PG_CT_";
//                    case 2 : str1 = "VHV_ER_CT_";
//                    case 3 : str1 = "VHV_PV_CT_";
//                  }   /* case */
//
//                  writestring(str2,loop:1);
//                  str2 = str1 + str2;
//                  if(i==minp)  
//                  {
//                     writestring(str3,slpct:1);
//                     str3 = "_SLPCT" + str3;
//                     str2 = str2 + str3;
//                  } 
//                  
//                  PrintResultParam(str2,tnum,spbool2,0v,16v,meas_value,GL_PLELL_FORMAT);
//               }   /*scrnprint*/
//            }   /*for loop*/
//            if(tistdscreenprint)  
//               cout << endl;
//
//         }   /*slpct*/
//      }   /*for i*/
//
//   }   /*if v_any_dev_active*/
//} 
//   
//
//void TL_EngOvride_W89_RAM(IntS catnum,
//                               IntS pmos_ratio,
//                               IntS nmos_pvratio,
//                               IntS nmos_evratio,
//                               IntS nmos_rm0ratio,
//                               IntS nmos_rm1ratio,
//                               IntS nmos_rdratio)
//{
//   IntS site,bank,count;
//   IntS int1,int2,int3,int4;
//   IntS val1,val2,val3,val4;
//   IntS1D w8_val(4),w9_val(4);
//   IntS addr_loc,loop;
//   IntM msw_data,lsw_data;
//   BoolS debugprint;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint)  
//      {
//         cout << "+++ TL_EngOvride_W89_RAM Template +++" << endl;
//         cout << "CAT" << catnum:-2 << "  Ratio PMOS==" << pmos_ratio:-4 << 
//                 " NMOS PV==" << nmos_pvratio:-4 << " NMOS EV==" << nmos_evratio:-4 << 
//                 " NMOS RM0==" << nmos_rm0ratio:-4 << " NMOS RM1==" << nmos_rm1ratio:-4 << 
//                 " NMOS RD==" << nmos_rdratio:-4 << endl;
//      } 
//      
//      debugprint = false;
//
//      for (loop = 0;loop <= 1;loop++)
//      {
//         if(loop==0)  
//         {
//            val1 = W8_0_DEF_CAT0;
//            val2 = W8_4_DEF_CAT0;
//            val3 = W8_8_DEF_CAT0;
//            val4 = W8_C_DEF_CAT0;
//         }
//         else
//         {
//            val1 = W9_0_DEF_CAT0;
//            val2 = W9_4_DEF_CAT0;
//            val3 = W9_8_DEF_CAT0;
//            val4 = W9_C_DEF_CAT0;
//         } 
//
//         if(tistdscreenprint)  
//         {
//            if(loop==0)  
//               cout << "W8 Orig == ");
//            else
//               cout << "W9 Orig == ";
//            cout << val1:s_hex:-12 << val2:s_hex:-12 << val3:s_hex:-12 << val4:s_hex:-12 << endl;
//         } 
//      
//          /*nmos pv ratio*/
//         if(nmos_pvratio>==0)  
//         {
//            int1 = val1 & (0xffffffe0);  /*clear bit4:0*/
//            int1 = int1 | nmos_pvratio;
//            val1 = int1;
//            if(tistdscreenprint and debugprint)  
//               cout << "Updated Nmos PV ratio Val1==" << val1:s_hex << endl;
//         } 
//         
//          /*pmos pv ratio*/
//         if(pmos_ratio>==0)  
//         {
//            int1 = val1 & (0xfffffC1F);  /*clear bit9:5*/
//            int1 = int1 | (pmos_ratio<<5);
//            val1 = int1;
//            if(tistdscreenprint and debugprint)  
//               cout << "Updated Pmos PV ratio Val1==" << val1:s_hex << endl;
//         } 
//         
//          /*nmos ev ratio*/
//         if(nmos_evratio>==0)  
//         {
//            int1 = val1 & (0xfff83fff);  /*clear bit18:14*/
//            int1 = int1 | (nmos_evratio<<14);
//            val1 = int1;
//            if(tistdscreenprint and debugprint)  
//               cout << "Updated Nmos EV ratio Val1==" << val1:s_hex << endl;
//         } 
//         
//          /*pmos ev ratio*/
//         if(pmos_ratio>==0)  
//         {
//            int1 = val1 & (0xff07ffff);  /*clear bit23:19*/
//            int1 = int1 | (pmos_ratio<<19);
//            val1 = int1;
//            if(tistdscreenprint and debugprint)  
//               cout << "Updated Pmos EV ratio Val1==" << val1:s_hex << endl;
//         } 
//         
//         
//          /*not doing cv ratio*/
//         
//          /*nmos rm0 ratio*/
//         if(nmos_rm0ratio>==0)  
//         {
//            int2 = val2 & (0xffff83ff);  /*clear bit14:10*/
//            int2 = int2 | (nmos_rm0ratio<<10);
//            val2 = int2;
//            if(tistdscreenprint and debugprint)  
//               cout << "Updated Nmos RM0 ratio Val2==" << val2:s_hex << endl;
//         } 
//         
//          /*pmos rm0 ratio*/
//         if(pmos_ratio>==0)  
//         {
//            int2 = val2 & (0xfff07fff);  /*clear bit19:15*/
//            int2 = int2 | (pmos_ratio<<15);
//            val2 = int2;
//            if(tistdscreenprint and debugprint)  
//               cout << "Updated Pmos RM0 ratio Val2==" << val2:s_hex << endl;
//         } 
//         
//         
//          /*nmos rm1 ratio*/
//         if(nmos_rm1ratio>==0)  
//         {
//            int3 = val3 & (0xffffE0ff);  /*clear bit12:8*/
//            int3 = int3 | (nmos_rm1ratio<<8);
//            val3 = int3;
//            if(tistdscreenprint and debugprint)  
//               cout << "Updated Nmos RM1 ratio Val3==" << val3:s_hex << endl;
//         } 
//         
//          /*pmos rm1 ratio*/
//         if(pmos_ratio>==0)  
//         {
//            int3 = val3 & (0xfffC1fff);  /*clear bit17:13*/
//            int3 = int3 | (pmos_ratio<<13);
//            val3 = int3;
//            if(tistdscreenprint and debugprint)  
//               cout << "Updated Pmos RM1 ratio Val3==" << val3:s_hex << endl;
//         } 
//         
//         
//          /*skip 2 unused*/
//         
//          /*nmos rd bkup ratio*/
//         if(nmos_rdratio>==0)  
//         {
//            int4 = val4 & (0xff83ffff);  /*clear bit22:18*/
//            int4 = int4 | (nmos_rdratio<<18);
//            val4 = int4;
//            if(tistdscreenprint and debugprint)  
//               cout << "Updated Nmos RD BK ratio Val4==" << val4:s_hex << endl;
//         } 
//         
//          /*pmos rd bkup ratio*/
//         if(pmos_ratio>==0)  
//         {
//            int4 = val4 & (0xf07fffff);  /*clear bit27:23*/
//            int4 = int4 | (pmos_ratio<<23);
//            val4 = int4;
//            if(tistdscreenprint and debugprint)  
//               cout << "Updated Pmos RD BK ratio Val4==" << val4:s_hex << endl;
//         } 
//
//         if(loop==0)  
//         {
//            w8_val[0] = val1;
//            w8_val[1] = val2;
//            w8_val[2] = val3;
//            w8_val[3] = val4;
//         }
//         else
//         {
//            w9_val[0] = val1;
//            w9_val[1] = val2;
//            w9_val[2] = val3;
//            w9_val[3] = val4;
//         } 
//      }   /*for loop*/
//
//      addr_loc = ADDR_RAM_OTP_TEMP_W8;
//
//      for (loop = 0;loop <= 1;loop++)
//      {
//         for (count = 0;count <= 3;count++)
//         {
//            if(loop==0)  
//            {
//               int1 = (w8_val[count] & 0xffff0000) >> 16;
//               int1 = int1 & 0xffff;
//               int2 = w8_val[count] & 0xffff;
//            }
//            else
//            {
//               int1 = (w9_val[count] & 0xffff0000) >> 16;
//               int1 = int1 & 0xffff;
//               int2 = w9_val[count] & 0xffff;
//            } 
//               
//            msw_data = int1;
//            lsw_data = int2;
//            WriteRamContentDec_32Bit(addr_loc,lsw_data,true,msw_data,true,true);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//         }   /*for count*/
//      }   /*for loop*/
//
//      switch(catnum) {
//        case 1 :  
//               W8_0_DEF_CAT1 = w8_val[0];
//               W8_4_DEF_CAT1 = w8_val[1];
//               W8_8_DEF_CAT1 = w8_val[2];
//               W8_C_DEF_CAT1 = w8_val[3];
//               W9_0_DEF_CAT1 = w9_val[0];
//               W9_4_DEF_CAT1 = w9_val[1];
//               W9_8_DEF_CAT1 = w9_val[2];
//               W9_C_DEF_CAT1 = w9_val[3];
//             break; 
//        case 2 :  
//               W8_0_DEF_CAT2 = w8_val[0];
//               W8_4_DEF_CAT2 = w8_val[1];
//               W8_8_DEF_CAT2 = w8_val[2];
//               W8_C_DEF_CAT2 = w8_val[3];
//               W9_0_DEF_CAT2 = w9_val[0];
//               W9_4_DEF_CAT2 = w9_val[1];
//               W9_8_DEF_CAT2 = w9_val[2];
//               W9_C_DEF_CAT2 = w9_val[3];
//             break; 
//        case 3 :  
//               W8_0_DEF_CAT3 = w8_val[0];
//               W8_4_DEF_CAT3 = w8_val[1];
//               W8_8_DEF_CAT3 = w8_val[2];
//               W8_C_DEF_CAT3 = w8_val[3];
//               W9_0_DEF_CAT3 = w9_val[0];
//               W9_4_DEF_CAT3 = w9_val[1];
//               W9_8_DEF_CAT3 = w9_val[2];
//               W9_C_DEF_CAT3 = w9_val[3];
//             break; 
//        case 4 :  
//               W8_0_DEF_CAT4 = w8_val[0];
//               W8_4_DEF_CAT4 = w8_val[1];
//               W8_8_DEF_CAT4 = w8_val[2];
//               W8_C_DEF_CAT4 = w8_val[3];
//               W9_0_DEF_CAT4 = w9_val[0];
//               W9_4_DEF_CAT4 = w9_val[1];
//               W9_8_DEF_CAT4 = w9_val[2];
//               W9_C_DEF_CAT4 = w9_val[3];
//             break; 
//        default:  
//               W8_0_DEF_CAT5 = w8_val[0];
//               W8_4_DEF_CAT5 = w8_val[1];
//               W8_8_DEF_CAT5 = w8_val[2];
//               W8_C_DEF_CAT5 = w8_val[3];
//               W9_0_DEF_CAT5 = w9_val[0];
//               W9_4_DEF_CAT5 = w9_val[1];
//               W9_8_DEF_CAT5 = w9_val[2];
//               W9_C_DEF_CAT5 = w9_val[3];
//         break; 
//      }   /* case */
//
//
//      if(tistdscreenprint)  
//      {
//         cout << "W8/W9 Override CAT" << catnum:-2 << " : " << endl;
//         cout << "W8 New  == " << w8_val[0]:s_hex:-12 << w8_val[1]:s_hex:-12 << w8_val[2]:s_hex:-12 << w8_val[3]:s_hex:-12 << endl;
//         cout << "W9 New  == " << w9_val[0]:s_hex:-12 << w9_val[1]:s_hex:-12 << w9_val[2]:s_hex:-12 << w9_val[3]:s_hex:-12 << endl;
//         if(debugprint)  
//         {
//            int3 = ADDR_RAM_OTP_TEMP_W8;
//            cout << "Reading OTP Template in RAM after Eng Override" << endl;
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//                  readramaddress(site,int3,int3+(10*ADDR_RAM_INC));
//         } 
//      } 
//   }   /*if v_any_dev_active*/
//      
//}   /* TL_EngOvride_W89_RAM */


void TL_RunTestNum(IntS start_testnum,
                        StringS logstr)
{
   IntS bank,sblk,eblk;
   IntS testnum,pattype,count,i;
   FloatS maxtime;
   FloatM tt_timer;
   TMResultM tmp_results;
   BoolS logena;
   StringS str1,str2,str3,str4,str5;

   if(logstr!="")  
   {
      str1 = logstr;
      logena = true;
   }
   else
   {
      str1 = "FLASHTEST";
      logena = false;
   } 

   i = (start_testnum&0x00000f00) >> 8;
   switch(i) {
     case 0 : pattype = BANKTYPE;
     case 1 : pattype = SECTTYPE;
     case 2 : pattype = BLOCKTYPE;
     case 3 : pattype = QUADTYPE;
     default: pattype = OTPTYPE;
   }   /* case */

   maxtime = GL_F021_MAXTIME;

//   PrintHeaderBool(GL_PLELL_FORMAT);

   for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
   {
      if((pattype==BANKTYPE) or (pattype==OTPTYPE))  
      {
         sblk = bank;
         eblk = bank;
      }
      else if(pattype==BLOCKTYPE)  
      {
         sblk = 0;
         eblk = F021_Flash.MAXBLOCK[bank];
      }
      else if(pattype==QUADTYPE)  
      {
         sblk = 0;
         eblk = FL_MAX_QUADRANT;
      }
      else
      {
         sblk = 0;
         eblk = F021_Flash.MAXSECT[bank];
      } 

      testnum = start_testnum+(bank<<4);
      
      for (count = sblk;count <= eblk;count++)
      {
         tmp_results = F021_RunTestNumber(testnum,maxtime,tt_timer);
         str2 = bank + "_B";
         
         if((pattype==BLOCKTYPE) or (pattype==SECTTYPE))  
         {
            if(pattype==BLOCKTYPE)  
               str3 = "BLK" + count;
            else
               str3 = "S" + count;
            str2 = str2 + str3;
         } 

         str4 = str1 + str2;

//         PrintResultBool(str4,testnum,tmp_results,GL_PLELL_FORMAT);

         if(logena)  
         {
            str5 = str4 + "_TT";
            TWPDLDataLogRealVariable(str5, "s",tt_timer,TWMinimumData);
         } 

         testnum = testnum+1;
      }   /*count*/
   }   /*bank*/
}   /*TL_RunTestNum*/

   
//void TL_DumpOTP()
//{
//   IntS site,bank,tnum,i;
//   IntS saddr,eaddr;
//   IntS1D testnum(4);
//   StringS1D str1(4);
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint)  
//      {
//         testnum[0] = TNUM_OTP_RD_LOG1_MBOX;
//         testnum[1] = TNUM_OTP_RD_ID_MBOX;
//         testnum[2] = TNUM_OTP_RD_VT_MBOX;
//         testnum[3] = TNUM_OTP_RD_LOG3_MBOX;
//         str1[0] = "OTP LOG1 SPACE";
//         str1[1] = "OTP ID SPACE";
//         str1[2] = "OTP VT/BCC SPACE";
//         str1[3] = "OTP LOG3 SPACE";
//
//         saddr = ADDR_RAM_MAILBOX;
//         eaddr = saddr+(68*ADDR_RAM_INC);
//
//         for (i = 0;i <= 3;i++)
//            for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//            {
//               tnum = testnum[i]+(bank<<4);
//               F021_RunTestNumber(tnum,10s,spare_mstreal1,spare_msbool1);
//               cout << "*** DUMPING " << str1[i] << " ***" << endl;
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                     readramaddress(site,saddr,eaddr);
//            }   /*bank*/
//      } 
//   } 
//}   /* TL_DumpOTP */
//
// /*extract raw data from FL_SCRAM_CAPT_ARR and output to text file*/
// /*must run F021_GetESDA_NonSCRAM or Get_Flash_ESDASpace_SCRAM before calling this procedure*/
//void TL_DumpRawESDA_ToFile(IntS imgnum,
//                                StringS logstr)
//{
//   const IntS IND_DSIZE = 8; 
//   const IntS IND_FCOUNT_MSW = 9; 
//   const IntS IND_FCOUNT_LSW = 10; 
//   const IntS IND_STARTADDR = 11; 
//   const  STARTFLAG = 0xFEDE;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  ENDFLAG1 = 0xFE9F;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  ENDFLAG2 = 0xCDEF;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS DSIZE144 = 160; 
//   const IntS ROWMAX = 4096; 
//   const IntS COLMAX = 32; 
//   const IntS HEADWORD = 10; 
//type /* didn"t match any chunk types, FIX */
//   WordType20 = array[1..20] of char; /* :MANUAL FIX REQUIRED: */
//var
//   IntS site,count,length,addr,saddr,headwords,i;
//   IntS sdatalen,edatalen,loop,index,maxfail;
//   IntM msw_val,lsw_val,failcnt,tmpval,expfailcnt;
//   BoolM savesites,logsites;
//   StringS s,str1,str2,pgpathname,datestr;
//   BoolS dumptofile,pbistena;
//   StringS Fname,this_wfrid;
//   IntM xpos,ypos,tnum;
//   text fileid;
//   FloatS ttimer1;
//
//   if(v_any_dev_active)  
//   {
//      timernstart(ttimer1);
//      savesites = v_dev_active;
//      logsites = v_dev_active;
//
//      maxfail = GL_ESDA_MAXSIZE;
//      headwords = HEADWORD;
//
//      pgpathname = ProgramGetName;
//      datestr = Date2kGet;
//
//       /*get fail count*/
//      expfailcnt = FL_SCRAM_CAPT_ARR[IND_FCOUNT_MSW];
//      arraymultintegervalue(expfailcnt,expfailcnt,0x10000,v_sites);
//      arrayaddinteger(expfailcnt,expfailcnt,FL_SCRAM_CAPT_ARR[IND_FCOUNT_LSW],v_sites);
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//            if((expfailcnt[site]<==0) or (FL_SCRAM_CAPT_ARR[2][site]!= STARTFLAG))  
//            {
//               logsites[site] = false;
//               devsetholdstate(site,false);
//            } 
//      
//      if(v_any_dev_active)  
//      {
//          /*get data word length*/
//         tmpval = FL_SCRAM_CAPT_ARR[IND_DSIZE];
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               length = tmpval[site];
//               switch(length) {
//                 case DSIZE144 :  
//                               sdatalen = 1;
//                               edatalen = 5;
//                             break; 
//                 default:  
//                    sdatalen = 1;
//                    edatalen = 2;
//                  break; 
//               }   /* case */
//               break;
//            }   /*if v_dev_active*/
//
//          /*get tnum*/
//         Get_TLogSpace_TNUM(msw_val,lsw_val);
//         arraymultintegervalue(tnum,msw_val,0x10000,v_sites);
//         arrayaddinteger(tnum,tnum,lsw_val,v_sites);
//         
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site] and logsites[site])  
//            {
//               if IsProber  
//               {
//                  this_wfrid = prober.waferIDStr;
//                  xpos[site] = STPTWDevX[site];
//                  ypos[site] = STPTWDevY[site];
//               }
//               else
//               {
//                  this_wfrid = "C_1234567_25";
//                  xpos[site] = site;
//                  ypos[site] = site+1;
//               } 
//               
//               Fname = "./logs/" + this_wfrid;
//               Fname = Fname + "_ESDA.txt";
//               RewriteAppend(fileid,Fname);
//               
//               cout << fileid << endl;
//               cout << fileid << pgpathname << endl;
//               cout << fileid << "TEST DATE :  " << datestr << endl;
//               cout << fileid << "WAFERID : " << this_wfrid << "  XPOS : " << xpos[site]:-5 << "  YPOS : " << ypos[site]:-5 << endl;
//               cout << fileid << "ESDA IMAGENUM : " << imgnum:-5 << " TNUM : " << Tnum[site]:s_hex:-12 << " " << logstr << endl;
//               
//               str1 = "Header";
//               write(fileid << str1:-12 << " ";
//               for (i = 1;i <= headwords;i++)
//                  write(fileid << FL_SCRAM_CAPT_ARR[i][site]:s_hex:-8 << " ";
//               cout << fileid << endl;
//               
//               index = IND_STARTADDR;
//               
//               for (i = 1;i <= expfailcnt[site];i++)
//               {
//                  if((index+1)>maxfail)  
//             break;
//                  addr = (FL_SCRAM_CAPT_ARR[index][site]<<16) + FL_SCRAM_CAPT_ARR[index+1][site];
//                  write(fileid << addr:s_hex:-12 << " ";
//                  index = index+2;
//
//                  for (loop = sdatalen;loop <= edatalen;loop++)
//                  {
//                     if((index+1) > maxfail)  
//                        break;
//                     write(fileid << FL_SCRAM_CAPT_ARR[index][site]:s_hex:-8 << " " << FL_SCRAM_CAPT_ARR[index+1][site]:s_hex:-8 << " ";
//                     index = index+2;
//                  } 
//                  cout << fileid << endl;
//                  if(index>==maxfail)  
//                     break;
//               } 
//               
//               str1 = "Footer";
//               cout << fileid << str1:-12 << " " << ENDFLAG1:s_hex:-8 << " " << ENDFLAG2:s_hex:-8 << endl;
//               cout << fileid << endl;
//               cout << fileid << endl;
//               
//               FileClose(fileid);
//            }   /*v_dev_act and logsites*/
//      }   /*if v_any_dev_act*/
//      
//      devsetholdstates(savesites);
//
//      if(tistdscreenprint)  
//         cout << "TL_DumpRawESDA_ToFile TT : " << timernread(ttimer1) << endl;
//   } 
//end;  /* didn"t match any chunk types, FIX */ /*TL_DumpRawESDA_ToFile*/
//
//void TL_SaveESDAImage(IntS imgnum,
//                           IntS banknum)
//{
//   const IntS HEADWORD = 10; 
//   const IntS IND_DSIZE = 8; 
//   const IntS IND_FCOUNT_MSW = 9; 
//   const IntS IND_FCOUNT_LSW = 10; 
//   const IntS IND_STARTADDR = 11; 
//   const  STARTFLAG = 0xFEDE;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  ENDFLAG1 = 0xFE9F;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  ENDFLAG2 = 0xCDEF;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS DSIZE144 = 160; 
//type /* didn"t match any chunk types, FIX */
//   WordType20 = array[1..24] of char; /* :MANUAL FIX REQUIRED: */
//var
//   IntS site,index,scram_ind,i,j,headwords,row,col;
//   IntS rmask,rshift,cmask,sdatalen,edatalen,loop;
//   BoolM savesites,allsitefalse;
//   BoolS dumptofile,do_ena;
//   WordType20 EsdaWordArr;
//   IntM failcnt,msw_val,lsw_val;
//
//   if(v_any_dev_active)  
//   {
//      savesites = v_dev_active;
//      allsitefalse = false;
//
//       /*v_dev_MemImageFlag[site], v_MemSaveImage, memresetimages, memsaveimage(s), esdasavedata*/
//      V_Dev_MemImageFlag = true;
//      MemResetImages;
//      V_Dev_MemImageFlag = false;
//      V_MemSaveImage = true;
//
//      dumptofile = GL_DUMP_RAWESDA_TOFILE;
//      headwords = HEADWORD;
//      
//      devsetholdstates(allsitefalse);
//
//       /*++++ format addr/data each site ++++*/
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      {
//         if(savesites[site])  
//         {
//            devsetholdstate(site,true);
//            MemSetImageSite(site);
//            V_Dev_MemImageFlag[site] = true;
//             /*MemResetImage;*/
//
//            failcnt[site] = (FL_SCRAM_CAPT_ARR[IND_FCOUNT_MSW][site]<<16) + FL_SCRAM_CAPT_ARR[IND_FCOUNT_LSW][site];
//            if(failcnt[site]>0)  
//        {
//           do_ena = true;
//           if(FL_SCRAM_CAPT_ARR[2][site]!=STARTFLAG)  
//          do_ena = false;
//        }
//            else
//               do_ena = false;
//
//            if(do_ena)  
//            {
//                /*header info*/
//               index = 1;
//               row = 1;
//               col = 1;
//
//               j = FL_SCRAM_CAPT_ARR[2][site];
//               EsdaWordArr[index]   = chr((j&0xff00) div 256);
//               EsdaWordArr[index+1] = chr(j&0x00ff);
//               index = index+2;
//               j = FL_SCRAM_CAPT_ARR[1][site];
//               EsdaWordArr[index]   = chr((j&0xff00) div 256);
//               EsdaWordArr[index+1] = chr(j&0x00ff);
//               index = index+2;
//
//               for (i = 3;i <= headwords;i++)
//               {
//                  j = FL_SCRAM_CAPT_ARR[i][site];
//                  EsdaWordArr[index]   = chr((j&0xff00) div 256);
//                  EsdaWordArr[index+1] = chr(j&0x00ff);
//                  index = index+2;
//               } 
//               MemUpdateImage(row,col,EsdaWordArr);
//               row = row+1;
// /*               
//                if(F021_Flash.MUXFACT[banknum]=16) then
//                begin
//                   rmask  := 0x0fff0;
//                   rshift := 4;
//                   cmask  := 0xf;
//                end
//                else
//                begin
//                   rmask  := 0x1fff0;
//                   rshift := 5;
//                   cmask  := 0x1f;
//                end;
// */
//               i = FL_SCRAM_CAPT_ARR[IND_DSIZE][site];
//               switch(i) {
//                 case DSIZE144 :  
//                               sdatalen = 1;
//                               edatalen = 5;
//                             break; 
//                 default:  
//                    sdatalen = 1;
//                    edatalen = 2;
//                  break; 
//               }   /* case */
//                               
//               scram_ind = IND_STARTADDR;
//               for (i = 1;i <= failcnt[site];i++)
//               {
//                  if((i<GL_ESDA_MAXSIZE) and ((scram_ind+1) <== GL_ESDA_MAXSIZE))  
//                  {
//                     index = 1;
//                     msw_val[site] = FL_SCRAM_CAPT_ARR[scram_ind][site];
//                     lsw_val[site] = FL_SCRAM_CAPT_ARR[scram_ind+1][site];
//                     scram_ind = scram_ind+2;
//                     EsdaWordArr[index]   = chr((msw_val[site]&0xff00) div 256);
//                     EsdaWordArr[index+1] = chr((msw_val[site]&0x00ff));
//                     EsdaWordArr[index+2] = chr((lsw_val[site]&0xff00) div 256);
//                     EsdaWordArr[index+3] = chr((lsw_val[site]&0x00ff));
//                     index = index+4;
//
//                     for (loop = sdatalen;loop <= edatalen;loop++)
//                     {
//                        if((scram_ind+1)>GL_ESDA_MAXSIZE)  
//                           break;
//                        msw_val[site] = FL_SCRAM_CAPT_ARR[scram_ind][site];
//                        lsw_val[site] = FL_SCRAM_CAPT_ARR[scram_ind+1][site];
//                        scram_ind = scram_ind+2;
//                        EsdaWordArr[index]   = chr((msw_val[site]&0xff00) div 256);
//                        EsdaWordArr[index+1] = chr((msw_val[site]&0x00ff));
//                        EsdaWordArr[index+2] = chr((lsw_val[site]&0xff00) div 256);
//                        EsdaWordArr[index+3] = chr((lsw_val[site]&0x00ff));
//                        index = index+4;
//                     }   /*for loop*/
//                     
//                     MemUpdateImage(row,col,EsdaWordArr);
//                     row = row+1;
//                  } 
//               }   /*for i failcnt*/
//               
//                /*terminator*/
//               i = ENDFLAG1;
//               j = ENDFLAG2;
//               EsdaWordArr[1]   = chr((i&0xff00) div 256);
//               EsdaWordArr[2] = chr((i&0x00ff));
//               EsdaWordArr[3] = chr((j&0xff00) div 256);
//               EsdaWordArr[4] = chr((j&0x00ff));
//               
//               for (i = 5;i <= 24;i++)
//                  EsdaWordArr[i] = chr(0);
//               
//               MemUpdateImage(row,col,EsdaWordArr);
//               
//               MemSaveImage(imgnum);   /*/usr/tc/<tester>/ESDA/*/
//               if(tistdscreenprint)  
//                  cout << "Site" << site:-5 << "Saving ESDA Image *.Z file..." << endl;
//
//               if(dumptofile)  
//                  TL_DumpRawESDA_ToFile(imgnum," ");
//
//                /*MemResetImages;*/
//            }   /*if do_ena*/
//            
//            V_Dev_MemImageFlag[site] = false;
//            
//            devsetholdstate(site,false);
//         }   /*if savesites*/
//      }   /*for site*/
//
//      devsetholdstates(savesites);
//      V_MemSaveImage = false;
//      
//   } 
//}   /* TL_SaveESDAImage */
//
//void F021_GetESDA_NonSCRAM(IntS imgnum,
//                                IntS banknum)
//{
//   const IntS IND_DSIZE = 8; 
//   const IntS IND_FCOUNT_MSW = 9; 
//   const IntS IND_FCOUNT_LSW = 10; 
//   const IntS IND_STARTADDR = 11; 
//   const  STARTFLAG = 0xFEDE;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  ENDFLAG1 = 0xFE9F;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const  ENDFLAG2 = 0xCDEF;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS SADDROFFSET = 5; 
//   const IntS DSIZEOFFSET = 3; 
//   const IntS DSIZE144 = 160; 
//   const IntS ROWMAX = 4096; 
//   const IntS COLMAX = 32; 
//   const IntS HEADWORD = 10; 
//
//   IntS site,count,length,addr,saddr,headwords;
//   IntS sdatalen,edatalen,loop,index,maxfail;
//   IntS i,row,col,j,rmask,rshift,cmask,cshift,k;
//   IntM msw_val,lsw_val,failcnt,tmpval;
//   IntM msw_addr,lsw_addr,expfailcnt;
//   BoolM savesites,logsites,activesites;
//   BoolM sitedone;
//   BoolS sbool1,done,debugprint;
//   StringS s,str1,str2;
//   BoolS dumptofile,pbistena;
//   StringS Fname,this_wfrid;
//   IntM xpos,ypos,tnum;
//   text fileid;
//   FloatS ttimer1;
//
//   if(v_any_dev_active)  
//   {
//      timernstart(ttimer1);
//      savesites = v_dev_active;
//      logsites = v_dev_active;
//      activesites = v_dev_active;
//
//       /*store raw data to file*/
//      dumptofile = GL_DUMP_RAWESDA_TOFILE;
//
//       /*get tnum*/
//      addr = ADDR_TEST_INFO;
//      GetRamContentDec_16bit(ramread_nburst_msw,addr,msw_val);
//      GetRamContentDec_16bit(ramread_nburst_lsw,addr,lsw_val);
//
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            tnum[site] = msw_val[site]<<16;
//            tnum[site] = tnum[site]+lsw_val[site];
//         } 
//      
//      saddr = ADDR_RAM_ESDA;
//      addr  = saddr;
//
//       /*get header info*/
//      headwords = HEADWORD;
//      for i = 1 to headwords by 2 do
//      {
//         GetRamContentDec_16bit(ramread_nburst_msw,addr,msw_val);
//         GetRamContentDec_16bit(ramread_nburst_lsw,addr,lsw_val);
//         FL_SCRAM_CAPT_ARR[i] = msw_val;
//         FL_SCRAM_CAPT_ARR[i+1] = lsw_val;
//         addr = addr+ADDR_RAM_INC;
//      } 
//
//       /*check start flag 0xfede*/
//      sbool1 = true;
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site] and (FL_SCRAM_CAPT_ARR[2][site]!=STARTFLAG))  
//         {
//            logsites[site] = false;
//            sbool1 = false;
//            if(tistdscreenprint)  
//               cout << "*** WARNING : Site" << site:-3 << " No Start Flag " << STARTFLAG:s_hex:-8 << 
//                       " Disable site !!!" << endl;
//         } 
//
//      if(not sbool1)  
//         devsetholdstates(logsites);
//
//       /*check fail count*/
//      if(v_any_dev_active)  
//      {
//         sbool1 = true;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               expfailcnt[site] = (FL_SCRAM_CAPT_ARR[IND_FCOUNT_MSW][site]<<16)+FL_SCRAM_CAPT_ARR[IND_FCOUNT_LSW][site];
//
//               if(expfailcnt[site]==0)  
//               {
//                  logsites[site] = false;
//                  sbool1 = false;
//                  if(tistdscreenprint)  
//                     cout << "*** WARNING : Site" << site:-3 << " FailCount == 0 so Disable site !!!" << endl;
//               } 
//            } 
//         if(not sbool1)  
//             /*if(not TIIgnoreFail) then*/
//               devsetholdstates(logsites);
//      } 
//
//
//       /*+++ 1 +++*/
//       /*gather raw data*/
//      if(v_any_dev_active)  
//      {
//          /*get word len*/
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               length = FL_SCRAM_CAPT_ARR[IND_DSIZE][site];
//                /*need expand for diff data size later*/
//               switch(length) {
//                 case DSIZE144 :  
//                               sdatalen = 1;
//                               edatalen = 5;
//                               pbistena = false;
//                             break; 
//                 default:  
//                               sdatalen = 1;
//                               edatalen = 2;
//                               pbistena = true;
//                             break; 
//               }   /* case */
//               break;
//            } 
//
//         activesites = v_dev_active;
//         sitedone = false;
//         failcnt = 0;
//         
//         addr = saddr+(SADDROFFSET*ADDR_RAM_INC);  /*1st fail addr loc @ 0x514*/
//         debugprint = false;
//         maxfail = GL_ESDA_MAXSIZE;
//
//          /*+++*/
//         k = HEADWORD+1;
//         failcnt = 0;
//         for (count = 1;count <= maxfail;count++)
//         {
//            if(not v_any_dev_active)  
//               break;
//             /*abort if s key is pressed*/
//            if(debugprint or TI_FlashDebug)  
//               if(Inkey(s))  
//                  break;
//
//            if((k+1) > GL_ESDA_MAXSIZE)  
//               break;
//            
//             /*get fail addr and keep track fail count*/
//            GetRamContentDec_16bit(ramread_nburst_msw,addr,msw_addr);
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr,lsw_addr);
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site] and (expfailcnt[site]>0))  
//               {
//                  FL_SCRAM_CAPT_ARR[k][site]   = msw_addr[site];
//                  FL_SCRAM_CAPT_ARR[k+1][site] = lsw_addr[site];
//               } 
//
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  failcnt[site] = failcnt[site]+1;
//                  i = failcnt[site];
//               } 
//
//            k = k+2;
//            addr = addr+ADDR_RAM_INC;
//
//             /*get datasize fail data (10 16bit word or 8 for pbist)*/
//            for (loop = sdatalen;loop <= edatalen;loop++)
//            {
//               if((k+1) > GL_ESDA_MAXSIZE)  
//                  break;
//               GetRamContentDec_16bit(ramread_nburst_msw,addr,msw_val);
//               GetRamContentDec_16bit(ramread_nburst_lsw,addr,lsw_val);
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site] and (expfailcnt[site]>0))  
//                  {
//                     i = failcnt[site];
//                     FL_SCRAM_CAPT_ARR[k][site]   = msw_val[site];
//                     FL_SCRAM_CAPT_ARR[k+1][site] = lsw_val[site];
//                  } 
//               k = k+2;
//           if(k>==maxfail)  
//          break;
//               addr = addr+ADDR_RAM_INC;
//            }   /*for loop*/
//
//             /*check to see if done*/
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site] and (failcnt[site]==expfailcnt[site]))  
//               {
//                  sitedone[site] = true;
//                  activesites[site] = false;
//               } 
//
//            devsetholdstates(activesites);
//
//            if(not v_any_dev_active)  
//               break;
//         }   /*for count maxfail*/
//          /*+++*/
//      } 
//       /*+++ 1 +++*/
//      
//      devsetholdstates(savesites);
//
//       /*TL_SaveESDAImage(imgnum,banknum);*/
//      
//      if(tistdscreenprint)  
//         cout << "F021_GetESDA_NonSCRAM TT : " << timernread(ttimer1) << endl;
//   } 
//}   /*F021_GetESDA_NonSCRAM*/
//
//void F021_Set_TPADS_ESDA(  IntS bank, IntS  sect)
//{
//   IntS site,i,j,iratio;
//   FloatS tdelay;
//   PinM tsupply,tp_cg;
//   BoolS tg_ena;
//   FloatM irval,cgval;
//   FloatS cg_irange,cg_vrange;
//   FloatS vProg,iProg,offset_bcc;
//   BoolM savesites,activesites;
//   vttype vt_type; 
//   prepostcorner prepost;
// 
//   if(v_any_dev_active)  
//   {
//      savesites = v_dev_active;
//      activesites = v_dev_active;
//      
//      F021_TurnOff_AllTpads;
//      
//      switch(FLEsda.TCRNum) {
//        case 6  :   
//                 tsupply = FLTP2;
//                 tp_cg   = FLTP1;
//                 tg_ena  = true;
//               break; 
//        case 38 :  
//                tsupply = FLTP2;
//                tg_ena  = false;
//              break; 
//        case 39 :  
//                tsupply = FLTP1;
//                tp_cg   = FLTP2;
//                tg_ena  = true;
//              break; 
//        default:  
//                tsupply = FLTP1;
//                tg_ena  = false;
//              break; 
//      }   /* case */
//
//      vt_type = FLEsda.VT_type;
//      prepost = FLEsda.PPCorner;
//      
//      if(FLEsda.UseBcc)  
//      {
//         offset_bcc = 2uA;
//         iratio = MainBCC.IRATIO[vt_type][prepost];
//         
//         if(tg_ena)  
//         {
//            if(FLEsda.TCRNum == 39)  
//               cg_vrange = TCR.TP2_VRange[FLEsda.TCRNum][FLEsda.TCRMode];
//            else
//               cg_vrange = TCR.TP1_VRange[FLEsda.TCRNum][FLEsda.TCRMode];
//
//            cg_irange = 100mA;
//            STDSetVRange(tp_cg,cg_vrange);
//            STDSetVI(tp_cg,cg_vrange,cg_irange);
//            if(tistdscreenprint)  
//               cout << "Set CG voltage on " << tp_cg << " @ " << cg_vrange << " @ " << cg_irange << endl;
//         } 
//         
//         vProg = 2.5V;  /*iref vrng*/
//         
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(activesites[site])  
//            {
//               iProg = BANK_BCC_VALUE[bank][sect][vt_type][prepost][site];
//                /*translate to external value*/
//               if(iratio==TNUM_MULT2)  
//                  iProg = 0.5*iProg;
//               else if(iratio==TNUM_MULT4)  
//                  iProg = 0.25*iProg;
//               else if(iratio==TNUM_DIV2)  
//                  iProg = 2*iProg;
//               
//               switch(vt_type) {
//                 CHKVT0, CHKVT0DRL, ONOVT0, CSFGVT0, EGFG1VT0, EGFG2VT0, EGFG3VT0, EGFG4VT0, EGFG5VT0,
//                 case  RDDISTBVT0: case  RCODEVT0 :   
//                    if(iProg<==2uA)  
//                       iProg = MainBCC.SSTART[vt_type][prepost];
//                    else
//                       iProg = iProg - offset_bcc;
//                  break; 
//
//                 default:  
//                    if(iProg<==2uA)  
//                     
//                       if(iratio==TNUM_MULT2)  
//                          iProg = 0.5*Bank_Iref_Read_Target;
//                       else if(iratio==TNUM_MULT4)  
//                          iProg = 0.25*Bank_Iref_Read_Target;
//                       else if(iratio==TNUM_DIV2)  
//                          iProg = 2*Bank_Iref_Read_Target;
//                       else
//                          iProg = Bank_Iref_Read_Target;
//                     
//                    else
//                       iProg = iProg + offset_bcc;
//                  break; 
//               }   /* case */
//               
//           STDSetVRange(tsupply,1.2*vProg);
//               STDSetVI(tsupply,vProg,iProg);
//               devsetholdstate(site,false);
//               if(tistdscreenprint)  
//                  cout << "Site" << site:-4 << " Set IREF voltage on " << tsupply << " @ " << vProg << " @ " << iProg << endl;
//            }   /*if activesites*/
//
//         devsetholdstates(savesites);
//         TIME.Wait(2ms);
//      }  /*if usebcc*/
//      else
//      {
//         offset_bcc = 50mV;
//         iProg = 100mA;
//
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(activesites[site])  
//            {
//               vProg = BANK_VT_VALUE[bank][sect][vt_type][prepost][site];
//               if(vProg <== 0.5v)  
//                  vProg = Vread_Target;
//               else
//                  vProg = vProg+offset_bcc;
//           STDSetVRange(tsupply,1.2*vProg);
//               STDSetVI(tsupply,vProg,iProg);
//               devsetholdstate(site,false);
//               if(tistdscreenprint)  
//                  cout << "Site" << site:-4 << " Set VCG voltage on " << tsupply << " @ " << vProg << " @ " << iProg << endl;
//            }   /*if activesites*/
//
//         devsetholdstates(savesites);
//         TIME.Wait(2ms);
//      }   /*not usebcc*/
//
//   }         /*v_any_dev_active*/
//   
//}   /* F021_Set_TPADS_ESDA */
   
// F021_CollectESDA : expects passing sites (no need esda) active & failing sites (need esda) inactive
// it temporary restores failing sites, do esda then disable that site.
void F021_CollectESDA(IntS imagenum) {

     IO.Print(IO.Stdout, " *** Create function to do ESDA data collection ***");
//   const  IntS OPERVTBCC = 5; 
//   const  OPERPBIST = 0xB;  /* :MANUAL FIX REQUIRED: Unknown const type */

//   BoolM savesites,logsites,failsites,allfalse,drlsites;
//   IntS bank,sect,sblk,eblk,imgesda,tnumesda,i;
//   IntS start_tnum,redtnum,maskbit,esdabit,redbit;
//   FloatS maxtime;
//   BoolS sbool1,sbool2,pbistena,redena,do_ena;
//
//   savesites = v_dev_active;
//   failsites = GL_SITE_TO_ESDA;
//   allfalse = false;
//   sbool1 = false;
//   sbool2 = false;
//   pbistena = false;
//   redena = false;
//   do_ena = false;
//
//   if(TIIgnoreFail or TI_FlashCOFEna) {
//      if(not ArrayCompareBoolean(failsites,allfalse,v_sites))  
//         do_ena = true;
//   }
//   else {
//      arrayandboolean(drlsites,GL_VT0DRL_RESULT,GL_VT1DRL_RESULT,v_sites);
//      arrayandboolean(drlsites,drlsites,GL_BCC0DRL_RESULT,v_sites);
//      arrayandboolean(drlsites,drlsites,GL_BCC1DRL_RESULT,v_sites);
//      
//      if((not ArrayCompareBoolean(GL_FLASH_SAVESITES,savesites,v_sites)) or
//         (not ArrayCompareBoolean(GL_FLASH_SAVESITES,drlsites,v_sites)))  
//         if(not ArrayCompareBoolean(failsites,allfalse,v_sites))  
//            do_ena = true;
//   } 
//   
//   if(do_ena) {
//         sbool1  = true;
//         maxtime = 2s;  // GL_F021_MAXTIME;
//
//         i = ((FLEsda.Tnum&0xf0000000) >>28) & 0xf;
//         if(i==OPERVTBCC)  
//            sbool2 = true;
//         
//         if(i==OPERPBIST) {
//            pbistena = true;
//            if(GL_DO_REDENA)  
//               redena = true;
//         } 
//
//         if(pbistena) {
//            maskbit = 0xff3fffff;
//            esdabit = 0x00400000;
//            redbit  = 0x00800000;
//         }
//         else {
//            maskbit = 0xfffcffff;
//            esdabit = 0x00020000;
//         } 
//
//         start_tnum = FLEsda.Tnum & maskbit;
//
//         for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//         {
//            if((FLEsda.Pattype==BANKTYPE) or (FLEsda.Pattype==OTPTYPE))  
//            {
//               sblk = bank;
//               eblk = bank;
//            }
//            else if(FLEsda.Pattype==BLOCKTYPE)  
//            {
//               sblk = 0;
//               eblk = F021_Flash.MAXBLOCK[bank];
//            }
//            else if(FLEsda.Pattype==QUADTYPE)  
//            {
//               sblk = 0;
//               eblk = FL_MAX_QUADRANT;
//            }
//            else
//            {
//               sblk = 0;
//               eblk = F021_Flash.MAXSECT[bank];
//            } 
//
//            tnumesda = (start_tnum|esdabit)+(bank<<4);
//            
//            for (sect = sblk;sect <= eblk;sect++)
//            {
//               logsites = GL_BANK_TO_ESDA[bank][sect];
//               failsites = GL_SITE_TO_ESDA;
//               ArrayAndBoolean(logsites,logsites,failsites,v_sites);
//               
//               if(not ArrayCompareboolean(logsites,allfalse,v_sites))  
//               {
//                  DevSetHoldStates(logsites);
//                  imgesda  = imagenum+bank;
//                  if(sbool2)  
//          {
//             if((FLEsda.Pattype==BANKTYPE) or (FLEsda.Pattype==OTPTYPE))  
//            F021_Set_TPADS_ESDA(bank,0);
//             else
//            F021_Set_TPADS_ESDA(bank,sect);
//          } 
//                  
//                  if(not pbistena)  
//                  {
//                     f021_runtestnumber(tnumesda,maxtime,spare_mstreal1,spare_msbool1);
//                     if(not GL_DO_ESDA_WITH_SCRAM)  
//                        F021_GetESDA_NonSCRAM(imgesda,bank);
//                     else
//                        Get_Flash_ESDASpace_SCRAM;
//                     TL_SaveESDAImage(imgesda,bank);
//                  }
//                  else
//                  {
//                     f021_runtestnumber(tnumesda,maxtime,spare_mstreal1,spare_msbool1);
//                     if(not GL_DO_ESDA_WITH_SCRAM)  
//                     {
//                        F021_GetESDA_NonSCRAM(imgesda,bank);
//                        TL_SaveESDAImage(imgesda,bank);
//                     } 
//                     if(redena)  
//                     {
//                        redtnum = tnumesda | redbit;
//                        f021_runtestnumber(redtnum,maxtime,spare_mstreal1,spare_msbool1);
//                        if(not GL_DO_ESDA_WITH_SCRAM)  
//                        {
//                           F021_GetESDA_NonSCRAM(1000+imgesda,bank);
//                           TL_SaveESDAImage(1000+imgesda,bank);
//                        }                            
//                     } 
//                  } 
//                  
//                  ClearFlashEsdaVars(bank,sect);
//               } 
//               tnumesda = tnumesda+1;
//            }   /*for sect*/
//         }   /*for bank*/
//   }   /*if do_ena*/
//
//   if(sbool1)  
//      DevSetHoldStates(savesites);
}   // F021_CollectESDA
   
//   
//void TL_BitHistogram(IntS pattype,
//                          IntS testnum,
//                          FloatS vcg_start,
//                          FloatS vcg_stop,
//                          FloatS vcg_inc,
//                          FloatS iref_start,
//                          FloatS iref_stop,
//                          FloatS iref_inc,
//                          BoolS logena,
//                          StringS logstr)
//{
//   const IntS OPER_TCR5 = 0x0; 
//   const IntS OPER_TCR6 = 0x1; 
//   const IntS OPER_TCR39 = 0x2; 
//   const IntS OPER_TCR38 = 0x3; 
//   const IntS MAXBOUND = 4096; 
//   const IntS IND_DSIZE = 8; 
//   const IntS IND_STARTADDR = 11; 
//   const IntS DSIZE144 = 160; 
//
//   IntS site,max_bits,exp_max_bits;
//   IntS tmpint,fdlen1,fdlen2,decpt;
//   IntS opertype,tnum_fail,dtastrb,invdtastrb;
//   IntS tnum,addr_loc,bankcount,count;
//   IntS counter,loop,unitlen,int1;
//   FloatS tdelay,maxtime,vProg,iProg;
//   FloatS iref_iProg,iref_vdd,iref_vProg;
//   FloatS cg_iProg,cg_vProg;   
//   FloatS vProgunit,iProgunit;
//   BoolS tp_iref_ena,tp_cg_ena,debugprint;
//   IntM lsb_val,msb_val,sumbit;
//   FloatM tt_timer;
//   BoolM tmp_results;
//   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
//   StringS str1,str2,str3,s,vstr,istr,twlogstr;
//   StringS unitstr,current_shell;
//   FloatS vProgFloatS,iProgFloatS,tmpFloatS;
//   PinM tp_iref,tp_cg;
//   Array[1..NumSites,1..MAXBOUND,1..MAXBOUND] of IntS NumBitFail;
//   BoolS save_printpass,save_scrnprint,done;
//   BoolS save_fldbugprint,dumptofile;
//   option vdd_pgmMode,vdd_iGMode;
//   FloatS vcg_step,iref_step;
//   BoolM do_once,savesites,activesites;
//   BoolM allsitefalse;
//   IntS imagenum;
//   IntS dlength,i,j,k,sdatalen,edatalen;
//   BoolM found_wbit,save_wbit;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint)  
//      {
//         cout << endl;
//         cout << "Bitmapping..." << endl;
//         cout << endl;
//      } 
//
//      vcg_step = vcg_inc;
//      if(vcg_start==vcg_stop)  
//         if(vcg_inc<1V)  
//            vcg_step = 1V;
//
//      iref_step = iref_inc;
//      if(iref_start==iref_stop)  
//         if(iref_inc<1A)  
//            iref_step = 1A;
//
//      vProgunit = 1V;
//      iProgunit = 1uA;
//      debugprint = TI_FlashDebug;
//      save_fldbugprint = TI_FlashDebug;
//      TI_FlashDebug = false;
//      save_printpass = TIPrintPass;
//      save_scrnprint = TIStdScreenPrint;
//      if(not debugprint)  
//      {
//         TIStdScreenPrint = false;
//         TIPrintPass = false;
//      } 
//      
//      tdelay = 10ms;
//      maxtime = GL_F021_MAXTIME;
//
//      tnum = (testnum&0xfffcffff)|0x00020000;  /*set esda bit*/
//      bankcount = (tnum&0x0070)>>4;
//      count = tnum&0x000F;
//      opertype = ((testnum&0x03000000) >>24) & 0x3;
//
//      dtastrb = (testnum&0x0000f000) >> 12;
//      if(dtastrb==0)  
//         invdtastrb = 0x00001000;
//      else if(dtastrb==1)  
//         invdtastrb = 0x00000000;
//      else if(dtastrb==2)  
//         invdtastrb = 0x00003000;
//      else
//         invdtastrb = 0x00002000;
//      tnum_fail = (tnum&0xffff0fff) | invdtastrb;
//         
//      switch(opertype) {
//        case OPER_TCR5  :  
//           tp_cg_ena   = true;
//           tp_iref_ena = false;
//           tp_cg       = FLTP1;
//           tmpstr1     = "TCR5_VCG";
//         break; 
//        case OPER_TCR6  :  
//           tp_cg_ena   = true;
//           tp_iref_ena = true;
//           tp_cg       = FLTP1;
//           tp_iref     = FLTP2;
//           tmpstr1     = "TCR6_VCGIREF";
//         break; 
//        case OPER_TCR39 :  
//           tp_iref     = FLTP1;
//           tp_cg       = FLTP2;
//           tp_iref_ena = true;
//           tp_cg_ena   = true;
//           tmpstr1     = "TCR39_VCGIREF";
//         break; 
//        case OPER_TCR38 :  
//           tp_iref     = FLTP1;
//           tp_iref_ena = true;
//           tp_cg_ena   = false;
//           tmpstr1     = "TCR38_IREF";
//         break; 
//      }   /* case */
//      
//       /*KChau - added to check shell vs. device specs*/
//       /*256KBytes with ECC:    max bits BANKSIZE = 256*1024*8*144/128*/
//       /*256KBytes with Parity: max bits BANKSIZE = 256*1024*8*132/128*/
//      if(pattype==BANKTYPE)  
//         exp_max_bits = F021_Flash.BANKSIZE[bankcount]*8;
//      else
//         exp_max_bits = F021_Flash.SECTSIZE[bankcount][count]*8;
//
//      if(F021_Flash.ECC_PARITY==1)  
//         exp_max_bits = trunc((exp_max_bits*(F021_Flash.DATAWIDTH+16)) / F021_Flash.DATAWIDTH);
//      else
//         exp_max_bits = trunc((exp_max_bits*(F021_Flash.DATAWIDTH+4)) / F021_Flash.DATAWIDTH);
//         
//      current_shell = "FlashShell";
//      if(GL_PREVIOUS_SHELL != current_shell)  
//         patternexecute(spareint1,f021_shell_loadpat);
//
//       /* find the max number of bits in a bank/sector */
//      if(dtastrb==0)  
//      {
//         vProg = 3V;
//         iProg = 10nA;
//      }
//      else
//      {
//         vProg = 0V;
//         iProg = 10nA;
//      } 
//
//      if(tp_iref_ena)  
//      {
//         STDSetVRange(tp_iref,vProg);
//         STDSetVI(tp_iref,vProg,iProg);
//      } 
//
//      if(tp_cg_ena)  
//      {
//         cg_vProg = 4.4V;
//         cg_iProg = 100mA;
//         STDSetVRange(tp_cg,cg_vProg);
//         STDSetVI(tp_cg,cg_vProg,cg_iProg);
//      } 
//
//      TIME.Wait(tdelay);
//      F021_RunTestNumber(tnum_fail,maxtime,tt_timer,tmp_results);
//
//      addr_loc = ADDR_PROG_TOT_PULSE;
//
//      Get_TLogSpace_TotPPulse(msb_val,lsb_val);
//   
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            max_bits = (msb_val[site]<<16)+lsb_val[site];
//            break;
//         } 
//
//      if(save_scrnprint)  
//         tistdscreenprint = true;
//      
//      if(logstr=="")  
//      {
//         twlogstr = tmpstr1;
//         writestring(tmpstr2,bankcount:1);
//         tmpstr2 = "_B" + tmpstr2;
//         if(pattype==SECTTYPE)  
//         {
//            writestring(tmpstr3,count:1);
//            tmpstr2 = tmpstr2 + "S";
//            tmpstr2 = tmpstr2 + tmpstr3;
//         } 
//         tmpstr3 = twlogstr + tmpstr2;
//      }
//      else
//      {
//         twlogstr = logstr;
//         tmpstr3  = twlogstr;
//      } 
//      tmpstr3 = tmpstr3 + "_";
//
//
//      if(tistdscreenprint and TI_FlashDebug)  
//      {
//         cout << endl;
//         cout << tmpstr3 << " max bits == " << max_bits:-10 << endl;
//         addr_loc = ADDR_RAM_ESDA;
//         
//         if(debugprint)  
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  readramaddress(site,0,0xff);
//                  readramaddress(site,addr_loc,addr_loc+(20*ADDR_RAM_INC));
//               } 
//      }       
//      
//      if(max_bits != exp_max_bits)  
//      {
//         if(tistdscreenprint and TI_FlashDebug)  
//         {
//            cout << "!!! ERROR: FLASH SIZE NOT MATCH IN SHELL VS. SPECS !!!" << endl;
//            cout << "EXPECT== " << exp_max_bits:-10 << " ACTUAL== " << max_bits:-10 << endl;
//         }
//         else if(TI_FlashDebug)  
//         {
//            cout << "!!! ERROR: FLASH SIZE NOT MATCH IN SHELL VS. SPECS !!!" << endl;
//            cout << "EXPECT== " << exp_max_bits:-10 << " ACTUAL== " << max_bits:-10 << endl;
//         } 
//      } 
//
//       /* Read and store bits in an array */
//      iref_vdd = 2.5V;
//      if(tp_iref_ena)  
//         STDSetVRange(tp_iref,iref_vdd);
//      
//      if(tp_cg_ena)  
//      {
//         if(vcg_start>vcg_stop)  
//            STDSetVRange(tp_cg,vcg_start);
//         else
//            STDSetVRange(tp_cg,vcg_stop);
//      } 
//
//      if(not debugprint)  
//         tistdscreenprint = false;
//   
//      do_once = false;
//      allsitefalse = false;
//      savesites = v_dev_active;
//      found_wbit = false;
//
//      if(GL_DO_GET_WORSTBIT)  
//      {
//         FL_WORSTBIT_IREF = 0uA;
//         FL_WORSTBIT_VCG = 0V;
//         FL_WORSTBIT_FADDR = 0;
//         FL_WORSTBIT_FCOUNT = 0;
//         for (i = 1;i <= 10;i++)
//            FL_WORSTBIT_FDATA[i] = 0;
//      } 
//   
//      done = false;
//      loop = 1;
//      iProg = iref_start;
//
//      REPEAT
//          /*abort if s key is pressed*/
//         if(TI_FlashDebug)  
//            if(Inkey(s))   done = true;
//
//         if(tp_iref_ena)  
//            TrealToStr(iProg,istr);
//         
//         counter=1;
//         for vProg = vcg_start to vcg_stop by vcg_step do
//         {
//            dumptofile = false;
//            activesites = false;
//            
//             /*abort if s key is pressed*/
//            if(TI_FlashDebug)  
//               if(Inkey(s))   break;
//
//            if(tp_iref_ena)  
//               STDSetVI(tp_iref,iref_vdd,iProg);
//            
//            if(tp_cg_ena)  
//               STDSetVI(tp_cg,vProg,cg_iProg);
//            
//            TIME.Wait(tdelay); 
//            F021_RunTestNumber(tnum,maxtime,tt_timer,tmp_results);
//            Get_TLogSpace_TotPPulse(msb_val,lsb_val);
//            
//            if(GL_DO_GET_WORSTBIT)  
//            {
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site] and (not found_wbit[site]))  
//                  {
//                     if(GL_DO_ESDA_WITH_SCRAM)  
//                        Get_Flash_ESDASpace_SCRAM;
//                     else
//                        F021_GetESDA_NonSCRAM(500,bankcount);
//                     break;
//                  } 
//            }                
//            
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  sumbit[site] = (msb_val[site]<<16)+lsb_val[site];
//                  NumBitFail[site][loop][counter] = sumbit[site];
//                  if((sumbit[site]>0) and (not do_once[site]))  
//                  {
//                     do_once[site] = true;
//                     activesites[site] = true;
//                     dumptofile = true;
//                  } 
//                  if(debugprint and tistdscreenprint)  
//                     cout << "Site " << site:-5 << " IProg==" << iProg:-6:3 << " VProg==" << vProg:-6:3 << 
//                             " FAILBITS== " << NumBitFail[site][loop][counter]:-16 << endl;
//
//                  if(GL_DO_GET_WORSTBIT)  
//                  {
//                     dlength = FL_SCRAM_CAPT_ARR[IND_DSIZE][site];
//                     switch(dlength) {
//                       case DSIZE144 :  
//                                     sdatalen = 1;
//                                     edatalen = 5;
//                                   break; 
//                       default:  
//                          sdatalen = 1;
//                          edatalen = 2;
//                        break; 
//                     }   /* case */
//
//                      /*failcount would be from 0 to some number if doing bcc0 & iref_start>iref_stop*/
//                     if(not found_wbit[site])  
//                     {
//                        if(sumbit[site] != 0)  
//                           save_wbit[site] = true;
//                        else
//                           save_wbit[site] = false;
//
//                        if(save_wbit[site])  
//                        {
//                           i = IND_STARTADDR;
//                           FL_WORSTBIT_FADDR[site] = (FL_SCRAM_CAPT_ARR[i][site]<<16) + FL_SCRAM_CAPT_ARR[i+1][site];
//                           i = i+2;
//                           k = sdatalen;
//                           for (j = sdatalen;j <= edatalen;j++)
//                           {
//                              FL_WORSTBIT_FCOUNT[site] = sumbit[site];
//                              FL_WORSTBIT_FDATA[k][site] = FL_SCRAM_CAPT_ARR[i][site];
//                              FL_WORSTBIT_FDATA[k+1][site] = FL_SCRAM_CAPT_ARR[i+1][site];
//                              i = i+2;
//                              k = k+2;
//                           } 
//                           FL_WORSTBIT_IREF[site] = iProg;
//                           FL_WORSTBIT_VCG[site] = vProg;
//                           
//                           if(((iref_start>iref_stop) and (sumbit[site]!=0)) or ((iref_start<iref_stop) and (sumbit[site]==0)))  
//                              found_wbit[site] = true;
//                        } 
//                     }   /*if dtastrb=0*/
//                  }   /*gl_do_get_worstbit*/
//               }   /*v_dev_active*/
//
//            if(tp_cg_ena)  
//               TRealToStr(vProg,vstr);
//
//            str1 = tmpstr3;
//            if(tp_cg_ena)  
//               str1 = str1 + vstr;
//            if(tp_iref_ena)  
//            {
//               if(tp_cg_ena)  
//                  str1 = str1 + "_";
//               str1 = str1 + istr;
//            } 
//            if(logena)  
//               TWPDLDataLogVariable(str1,sumbit,TWMinimumData);
//
//             /*output raw esda to file*/
//            if(dumptofile and GL_DUMP_RAWESDA_TOFILE)  
//            {
//               if(dtastrb==0)  
//                  imagenum = ESDA_IMG_BLK0 + bankcount;
//               else if(dtastrb==1)  
//                  imagenum = ESDA_IMG_BLK1 + bankcount;
//               else if(dtastrb==2)  
//                  imagenum = ESDA_IMG_ECHK + bankcount;
//               else
//                  imagenum = ESDA_IMG_OCHK + bankcount;
//                  
//               devsetholdstates(activesites);
//               if(not GL_DO_ESDA_WITH_SCRAM)  
//                  F021_GetESDA_NonSCRAM(imagenum,bankcount);
//               else
//                  Get_Flash_ESDASpace_SCRAM;
//               TL_DumpRawESDA_ToFile(imagenum,str1);
//               devsetholdstates(savesites);
//            } 
//            
//            counter = counter+1;
//            if(counter>MAXBOUND)  
//            {
//               if(tistdscreenprint)  
//                  cout << "*** Nunmber of samples exceed " << MAXBOUND:-10 << endl;
//               break;
//            } 
//         }   /*for vProg*/
//         
//         if(iref_start>iref_stop)  
//         {
//            if(iProg<==iref_stop)  
//               done = true;
//            else
//               iProg = iProg-iref_step;
//         }
//         else
//         {
//            if(iProg>==iref_stop)  
//               done = true;
//            else
//               iProg = iProg+iref_step;
//         } 
//     
//         loop = loop+1;
//         if(loop>MAXBOUND)  
//         {
//            if(tistdscreenprint)  
//               cout << "*** Nunmber of samples exceed " << MAXBOUND:-10 << endl;
//            break;
//         } 
//      UNTIL (done);  /*for iProg*/
//
//
//      if(tp_iref_ena)  
//      {
//         vProg = 0V;
//         iProg = 1mA;
//         STDSetVRange(tp_iref,vProg);
//         STDSetVI(tp_iref,vProg,iProg);
//      } 
//
//      if(tp_cg_ena)  
//      {
//         vProg = 0V;
//         iProg = 1mA;
//         STDSetVRange(tp_cg,vProg);
//         STDSetVI(tp_cg,vProg,iProg);
//      } 
//
//      tistdscreenprint = save_scrnprint;
//      tiprintpass = save_printpass;
//      TI_FlashDebug = save_fldbugprint;
//      
//       /* Display data as a histogram */
//      if(tistdscreenprint)  
//      {
//         cout << endl;
//         cout << tmpstr1 << " Bit Histogram " << endl;
//         PrintHeaderBool(GL_PLELL_FORMAT);
//         
//         done = false;
//         loop = 1;
//         iProg = iref_start;
//         REPEAT
//            if(tp_iref_ena)  
//               TrealToStr(iProg,istr);
//
//            counter=1;
//            for vProg = vcg_start to vcg_stop by vcg_step do
//            {
//               for (site = 1;site <= V_SITES;site++)
//                  if(v_dev_active[site])  
//                     sumbit[site] = NumBitFail[site][loop][counter];
//
//               if(tp_cg_ena)  
//                  TRealToStr(vProg,vstr);
//               str1 = tmpstr3;
//               if(tp_cg_ena)  
//                  str1 = str1 + vstr;
//               if(tp_iref_ena)  
//               {
//                  if(tp_cg_ena)  
//                     str1 = str1 + "_";
//                  str1 = str1 + istr;
//               } 
//               PrintResultInt(str1,testnum,sumbit,0,0,GL_PLELL_FORMAT);
//               
//               counter = counter+1;
//               if(counter>MAXBOUND)  
//                  break;
//            }   /*vProg*/
//            if(vcg_start != vcg_stop)  
//               cout << endl;
//
//            if(iref_start>iref_stop)  
//            {
//               if(iProg<==iref_stop)  
//                  done = true;
//               else
//                  iProg = iProg-iref_step;
//            }
//            else
//            {
//               if(iProg>==iref_stop)  
//                  done = true;
//               else
//                  iProg = iProg+iref_step;
//            } 
//            
//            loop = loop+1;
//            if(loop>MAXBOUND)  
//               break;
//         UNTIL (done);  /*iProg*/
//         cout << endl;
//         if(GL_DO_GET_WORSTBIT)  
//         {
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  cout << "Site" << site:-5 << " Found Worst Bit at IREF == " << FL_WORSTBIT_IREF[site] << "  VCG == " << FL_WORSTBIT_VCG[site] << endl;
//                  cout << FL_SCRAM_CAPT_ARR[IND_STARTADDR][site]:s_hex << "  " << FL_SCRAM_CAPT_ARR[IND_STARTADDR+1][site]:s_hex << endl;
//                  cout << "FADDR == " << FL_WORSTBIT_FADDR[site]:s_hex << "  FDATA == ";
//                  k = sdatalen;
//                  for (j = sdatalen;j <= edatalen;j++)
//                  {
//                     cout << FL_WORSTBIT_FDATA[k][site]:s_hex << "  " << FL_WORSTBIT_FDATA[k+1][site]:s_hex << "  ";
//                     k = k+2;
//                  } 
//                  cout << endl;
//               } 
//         }                   
//      }   /*if tistdscreenprint*/
//   }   /*if v_any_dev_active*/
//}   /* TL_BitHistogram*/
//      
// /*boost refarray to iref rd ~target*/
//void TL_Boost_RefArray()
//{
//   const IntS EVENNUM = 0; 
//   const IntS ODDNUM = 1; 
//   const IntS MAXCOUNT = 50; 
//
//   FloatS tdelay,tdelay2,maxtime,ttimer1,ttimer2;
//   BoolM savesites,logsites,activesites;
//   BoolM tmp_results,final_results,meas_results;
//   IntS site,bank,count,loop,testnum,minloop,maxloop;
//   IntS1D tnum_ipmos(2),tnum_ird(2);
//   IntS tnum_refarr;
//   IntS tcrnum,tcrnum_ipmos,tcrnum_ird,tcrnum_refarr;
//   TPModeType tcrmode,tcrmode_ipmos,tcrmode_ird,tcrmode_refarr;
//   FloatM meas_value,ers_pwtotal,iodd,ieven;
//   FloatS llim,ulim,llim_ird,ulim_ird;
//   FloatS ers_vstart,ers_vstop,ers_vinc,ers_volt,ers_pwidth;
//   FloatM ers_veg,tt_timer;
//   StringS str1,str2,str3,str4,str5;
//   PinM testpad;
//   BoolS done;
//   FloatM FloatSval;
//   TWunit unitval;
//    /*++++++++++++++++*/
//   procedure DoIMeas; /* didn"t match any chunk types, FIX */
//   
//      if(v_any_dev_active)  
//      {
//         F021_Set_TPADS(tcrnum,tcrmode);
//         F021_RunTestNumber_PMEX(testnum,maxtime,tmp_results);
//         TIME.Wait(tdelay);
//         F021_Meas_TPAD_PMEX(testpad,tcrnum,tcrmode,llim,ulim,meas_value,tmp_results);
//         F021_TurnOff_AllTPADS;
//         Disable(s_pmexit);
//      } 
//   } 
//    /*++++++++++++++++*/
//{
//   if(v_any_dev_active)  
//   {
//      maxtime = GL_F021_PARAM_MAXTIME;
//      tdelay  = 10ms;
//      tdelay2 = 2ms;
//
//      tcrnum_ird = 25;
//      tcrmode_ird = ReadMode;
//      tnum_ird[EVENNUM] = TNUM_BANK_IREF_READ_EVEN;
//      tnum_ird[ODDNUM]  = TNUM_BANK_IREF_READ_ODD;
//      llim_ird = Bank_Iref_Read_LLim+0.25uA;  /*Bank_Iref_Read_Target-(Bank_Iref_Read_Target*0.01);*/
//      ulim_ird = Bank_Iref_Read_ULim;  /*TCR.TP2_ULim[tcrnum_ird,tcrmode_ird];*/
//
//      tcrnum_refarr = 56;
//      tcrmode_refarr = ErsMode;
//      tnum_refarr = TNUM_BANK_REFARR_ERS;
//      ers_pwidth  = 50ms;
//      ers_vinc = 0.5V;
//      if(GL_DO_REFARR_ERS_ADAPTIVE)  
//      {
//         ers_vstart = RefArr_Ers_Adaptive_VStart;
//         ers_vstop  = RefArr_Ers_Adaptive_VStop;
//      }
//      else
//      {
//         ers_vstart = Bank_RefArr_VEG_Ers-(2*ers_vinc);
//         ers_vstop  = Bank_RefArr_VEG_Ers-ers_vinc;
//      } 
//
//      minloop = EVENNUM;
//      if(GL_BANKTYPE==FLEPBANK)  
//         maxloop = ODDNUM;
//      else
//         maxloop = EVENNUM;
//
//      savesites = v_dev_active;
//      final_results = v_dev_active;
//      
//      PrintHeaderParam(GL_PLELL_FORMAT);
//      timernstart(ttimer1);
//
//      str1 = "RefBoost";
//      
//      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//      {
//         logsites = v_dev_active;
//         activesites = v_dev_active;
//         meas_results = v_dev_active;
//         ers_pwtotal = 0ms;
//         ers_veg = 0V;
//
//         writestring(str2,bank:1);
//         str2 = "_B" + str2;
//         count = 0;
//         done = false;
//
//         ers_volt = ers_vstart;
//
//         while(not done) do
//         {
//            for (loop = minloop;loop <= maxloop;loop++)
//            {
//               tcrnum = tcrnum_ird;
//               tcrmode = tcrmode_ird;
//               llim = llim_ird;
//               ulim = ulim_ird;
//               testnum = tnum_ird[loop]+(bank<<4);
//               testpad = FLTP2;
//               DoIMeas;
//               writestring(str3,count:1);
//               if(loop==minloop)  
//               {
//                  str3 = "_Even_" + str3;
//                  ieven = meas_value;
//               }
//               else
//               {
//                  str3 = "_Odd_" + str3;
//                  iodd = meas_value;
//               } 
//               str4 = str1 + "_Ird";
//               str4 = str4 + str2;
//               str4 = str4 + str3;
//               PrintResultParam(str4,testnum,tmp_results,llim,ulim,meas_value,GL_PLELL_FORMAT);
//            }   /*for loop*/
//
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  if(GL_BANKTYPE==FLEPBANK)  
//                  {
//                     if((ieven[site]>llim) and (iodd[site]>llim))  
//                        activesites[site] = false;
//                  }
//                  else
//                  {
//                     if(ieven[site]>llim)  
//                        activesites[site] = false;
//                  } 
//               } 
//            
//            devsetholdstates(activesites);
//
//             /*apply ers pulse*/
//            if(v_any_dev_active)  
//            {
//               tcrnum = 128;
//               tcrmode = tcrmode_refarr;
//               CloneTCR_To_TCR128(tcrmode_refarr,tcrmode_refarr,tcrnum_refarr);
//               TCR.TP1_VRange[tcrnum][tcrmode] = ers_volt;
//               testnum = tnum_refarr+(bank<<4);
//               F021_TurnOff_AllTpads;
//               F021_RunTestNumber_PMEX(testnum,maxtime,tmp_results);
//               F021_Set_TPADS(tcrnum,tcrmode);
//               TIME.Wait(ers_pwidth);
//               F021_TurnOff_AllTpads;
//               Disable(s_pmexit);
//               count = count+1;
//               
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                  {
//                     ers_pwtotal[site] = ers_pwtotal[site]+ers_pwidth;
//                     ers_veg[site] = ers_volt;
//                  } 
//
//               if(ers_volt<ers_vstop)  
//                  ers_volt = ers_volt+ers_vinc;
//
//               str5 = str1 + str2;
//               str5 = str5 + "_VEG";
//               PrintResultParam(str5,testnum,tmp_results,10v,13v,ers_veg,GL_PLELL_FORMAT);
//               str5 = str1 + str2;
//               str5 = str5 + "_PW";
//               PrintResultParam(str5,testnum,tmp_results,0ms,1s,ers_pwtotal,GL_PLELL_FORMAT);
//            }   /*ers*/
//
//            if((not v_any_dev_active) or (count>MAXCOUNT))  
//               done = true;
//         }   /*while*/
//
//         devsetholdstates(savesites);
//
//         str4 = str1 + str2;
//         str5 = str4 + "_TOTPW";
//         TWTRealToRealMS(ers_pwtotal,realval,unitval);
//         TWPDLDataLogRealVariable(str5, unitval,realval,TWMinimumData);
//         
//         str5 = str4 + "_VEG";
//         TWTRealToRealMS(ers_veg,realval,unitval);
//         TWPDLDataLogRealVariable(str5, unitval,realval,TWMinimumData);
//         
//      }   /*bank*/
//
//      devsetholdstates(savesites);
//
//      ttimer1 = timernread(ttimer1);
//      tt_timer = ttimer1;
//      
//      str5 = str1 + "_TT";
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(str5, unitval,realval,TWMinimumData);
//
//      if(tistdscreenprint)  
//         cout << "TL_Boost_RefArr_TTT == " << ttimer1 << endl;
//   } 
//}   /* TL_Boost_RefArray */
//
//
 /*++++++++++ Flash Tools ++++++++++*/
   
void RAM_Clear_MailBox_Key()
{
   IntS addr_loc;
   IntM msw_data,lsw_data;
   BoolS bcd_format,hexvalue;

   if(tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ RAM_Clear_MailBox_Key +++++" << endl;

   bcd_format  = true;
   hexvalue    = true;
   addr_loc = ADDR_RAM_MAILBOX;
   
   msw_data = 0;  /*msword*/
   lsw_data = 0;  /*lsword*/
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
}   /* RAM_Clear_MailBox_Key */


FloatM DoIMeasure(const PinM &testpad, const IntS &tcrnum, 
                const TPModeType &tcrmode, const IntS &testnum, 
                const FloatS &maxtime, const FloatS &tdelay) 
{
   FloatM meas_val;
   
   F021_Set_TPADS(tcrnum,tcrmode);
#if $TP3_TO_TP5_PRESENT  
   STDDisconnect(FLTP3);
#endif
   F021_RunTestNumber_PMEX(testnum,maxtime);
   TIME.Wait(tdelay);
   meas_val = F021_Meas_TPAD_PMEX(testpad,tcrnum,tcrmode);
   F021_TurnOff_AllTPADS();
   
   return (meas_val);
}   /* DoIMeasure */

TMResultM F021_VHV_PG_CT_Trim_func(IntM &ret_ctval)
{
   const FloatS PGSTEP = 0.04V;
   const unsigned MAXITER = 40; 

   Sites new_active_sites;
   Sites savesites = ActiveSites;
   TMResultM final_results,tmp_results;
   TMResultM test_results = TM_NOTEST;
   IntS testnum,addr,addr_emu;
   IntS tcrnum;
   TPModeType tcrmode;
   StringS str1;
   FloatS ttimer1,maxtime,tdelay;
   FloatS llim_pre,ulim_pre;
   FloatS llim,ulim,target; 
   FloatS toler;
   PinM testpad;
   FloatM meas_val;
   IntM ctval,ersct,pgct,pre_pgct;
   IntM lsw_data,msw_data;
   BoolS bcd_format,hexvalue;
   BoolS logena; 
    /*++++++++++++++++++++*/

   if(tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ F021_VHV_PG_CT_Trim_func +++++" << endl;

   logena = true;  /*log to tw*/
   maxtime = GL_F021_PARAM_MAXTIME;
   tdelay = 10ms;
   
   tcrnum  = 115;
   tcrmode = ProgMode;
   testpad = FLTP1;
   testnum = TNUM_PUMP_VHVPROG;

   llim_pre = TCR.TP1_LLim[tcrnum][tcrmode];
   ulim_pre = TCR.TP1_ULim[tcrnum][tcrmode];

   target = VHV_Prog_Target;
   toler = 0.005;  /*1%*/
   llim = target-(target*toler);
   ulim = target+(target*toler);

    /*OTP template in RAM : pgct/ersct*/
   addr = ADDR_RAM_TEMPL_VHVE_PMT;
//   GetRamContentDec_16Bit("ramread_nburst_msw_Thrd",addr,pre_pgct);
//   GetRamContentDec_16Bit("ramread_nburst_lsw_Thrd",addr,ersct);   
   GetRamContentDec_16Bit("ramread_nburst_msw_v4p0_Thrd",addr,pre_pgct);
   GetRamContentDec_16Bit("ramread_nburst_lsw_v4p0_Thrd",addr,ersct);
   pgct = pre_pgct;
   ctval = pre_pgct;

   if(tistdscreenprint and TI_FlashDebug and tiprintpass)   
      ReadRamAddress(addr,addr+(4*ADDR_RAM_INC));
   
   bcd_format = true;
   hexvalue = true;
   lsw_data = ersct;

   TIME.StartTimer();

   if(ActiveSites.Begin().End())  
   {
      return (TM_NOTEST);
   }
      
   SearchMod ct_search;
   ct_search.SASearchBegin(FloatM(0.),FloatM(511.),FloatM(toler*target), FloatM(target), MAXITER);
   ct_search.SkipMinMax(true);

   IntS i = 0;
   while (ct_search.searchNotDone)
   {
      msw_data = MATH.LegacyRound(ct_search.xForceValueMS);
      WriteRamContentDec_32Bit(addr,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
      meas_val = DoIMeasure(testpad, tcrnum, tcrmode, testnum, maxtime, tdelay);
      
      // Dlog the trim code tried...but don't really care if it passes or don't send to TW
      str1 = "VHV_PG_CT_ITER_CODE_" + i;
      TIDlog.Value(msw_data, testpad, 0, 511, "", str1, UTL_VOID, UTL_VOID, false, TWMinimumData);
      // Dlog the value of the measure...send to TW if logena
      str1 = "VHV_PG_CT_ITER_" + i;
      TIDlog.Value(meas_val, testpad, llim_pre, ulim_pre, meas_val.GetUnits(), 
                                 str1, UTL_VOID, UTL_VOID, logena, TWMinimumData); 
      
      // put this at end of loop because it will disable sites
      // sites will be re-enabled by this routine when the search is done
      ct_search.SearchNext(meas_val);
   }

   // Round the final val just like we did when using it
   ctval = MATH.LegacyRound(ct_search.xForceValueMS);

   TIME.Wait(2ms);

    /*final check to see if w/in tolerance limit*/
   lsw_data = ersct;
   msw_data = ctval;
   WriteRamContentDec_32Bit(addr,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

#if $FL_USE_NEW_VHV_TEMPL_ADDR  
    /*emu bank*/
   addr_emu = ADDR_RAM_TEMPL_VHVE_PMT_EMU;
   lsw_data = ersct;
   msw_data = ctval;
   WriteRamContentDec_32Bit(addr_emu,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
#endif

   meas_val = DoIMeasure(testpad, tcrnum, tcrmode, testnum, maxtime, tdelay);

   str1 = "VHV_PG_CT_TRIM_SOL";
   tmp_results = TIDlog.Value(ctval, testpad, 0, 511, "", str1, UTL_VOID, UTL_VOID, true, TWMinimumData);
   
   str1 = "VHV_PG_CT_TRIM_NM";
   final_results = TIDlog.Value(meas_val, testpad, llim_pre, ulim_pre, meas_val.GetUnits(), str1,
                                UTL_VOID, UTL_VOID, true, TWMinimumData);

   test_results = DLOG.AccumulateResults(tmp_results, final_results);
   ret_ctval = ctval;

   if(tistdscreenprint and TI_FlashDebug and tiprintpass)   
#if $FL_USE_NEW_VHV_TEMPL_ADDR  
            ReadRamAddress(addr,addr_emu+(4*ADDR_RAM_INC));;
#else
            ReadRamAddress(addr,addr+(4*ADDR_RAM_INC));
#endif   

   ttimer1 = TIME.StopTimer();
   str1 = "VHV_PG_TRIM_TTT";
   TIDlog.Value(ttimer1, UTL_VOID, 0., UTL_VOID, "s", str1, UTL_VOID, UTL_VOID, logena, TWMinimumData);

   return(test_results);
   
}   /* F021_VHV_PG_CT_Trim_func */

TMResultM F021_VHV_ER_CT_Trim_func(IntM &ret_ctval)
{
   const FloatS PGSTEP = 0.04V;
   const unsigned MAXITER = 40; 
   const IntS CTOFFSET = 96;

   Sites new_active_sites;
   Sites savesites = ActiveSites;
   TMResultM final_results,tmp_results;
   TMResultM test_results = TM_NOTEST;
   IntS testnum,addr,addr_emu;
   IntS tcrnum, k;
   TPModeType tcrmode;
   StringS str1;
   FloatS ttimer1,maxtime,tdelay;
   FloatS llim_pre,ulim_pre;
   FloatS llim,ulim,target; 
   FloatS toler;
   PinM testpad;
   FloatM meas_val;
   IntM ctval,ersct,pgct,pre_pgct, pre_ersct;
   IntM lsw_data,msw_data;
   BoolS bcd_format,hexvalue;
   BoolS logena; 
    /*++++++++++++++++++++*/

   if(tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ F021_VHV_ER_CT_Trim_func +++++" << endl;

   logena = true;  /*log to tw*/
   maxtime = GL_F021_PARAM_MAXTIME;
   tdelay = 10ms;
   
   tcrnum  = 115;
   tcrmode = ErsMode;
   testpad = FLTP1;
   testnum = TNUM_PUMP_VHVERS;

   llim_pre = TCR.TP1_LLim[tcrnum][tcrmode];
   ulim_pre = TCR.TP1_ULim[tcrnum][tcrmode];

   target = VHV_Ers_Target;
   toler = 0.005;  /*1%*/
   llim = target-(target*toler);  // vlct uses ...(target*toler*0.5) with toler of 0.01, but SearchMod doesn't allow different
                                  // lower and upper tolerance limits...going to try to use the tighter toler for both
   ulim = target+(target*toler);

   addr = ADDR_RAM_TEMPL_VHVE_SM;
//   GetRamContentDec_16Bit("ramread_nburst_msw_Thrd", addr, VHV_ER_CT_STARTSAVED);
//   GetRamContentDec_16Bit("ramread_nburst_lsw_Thrd", addr, VHV_ER_CT_STEPSAVED);   
   GetRamContentDec_16Bit("ramread_nburst_msw_v4p0_Thrd", addr, VHV_ER_CT_STARTSAVED);
   GetRamContentDec_16Bit("ramread_nburst_lsw_v4p0_Thrd", addr, VHV_ER_CT_STEPSAVED);
   
#if $FL_USE_NEW_VHV_TEMPL_ADDR 
   addr = ADDR_RAM_TEMPL_VHVE_SM_EMU;
//   GetRamContentDec_16Bit("ramread_nburst_msw_Thrd", addr, VHV_ER_CT_STARTSAVED_EMU);
//   GetRamContentDec_16Bit("ramread_nburst_lsw_Thrd", addr, VHV_ER_CT_STEPSAVED_EMU);   
   GetRamContentDec_16Bit("ramread_nburst_msw_v4p0_Thrd", addr, VHV_ER_CT_STARTSAVED_EMU);
   GetRamContentDec_16Bit("ramread_nburst_lsw_v4p0_Thrd", addr, VHV_ER_CT_STEPSAVED_EMU);
#endif

    /*OTP template in RAM : pgct/ersct*/
   addr = ADDR_RAM_TEMPL_VHVE_PMT;
//   GetRamContentDec_16Bit("ramread_nburst_msw_Thrd",addr,pgct);
//   GetRamContentDec_16Bit("ramread_nburst_lsw_Thrd",addr,pre_ersct);   
   GetRamContentDec_16Bit("ramread_nburst_msw_v4p0_Thrd",addr,pgct);
   GetRamContentDec_16Bit("ramread_nburst_lsw_v4p0_Thrd",addr,pre_ersct);
   ersct = pre_ersct;
   ctval = pre_ersct;

   if(tistdscreenprint and TI_FlashDebug and tiprintpass)
   {
      k = ADDR_RAM_TEMPL_VHVE_SM;
      ReadRamAddress(k,k+(8*ADDR_RAM_INC));
   }
   
   bcd_format = true;
   hexvalue = true;
   msw_data = pgct;

   TIME.StartTimer();

   if(ActiveSites.Begin().End())  
   {
      return (TM_NOTEST);
   }
      
   SearchMod ct_search;
   ct_search.SASearchBegin(FloatM(0.),FloatM(511.),FloatM(toler*target), FloatM(target), MAXITER);
   ct_search.SkipMinMax(true);

   IntS i = 0;
   IntM temp_intm;
   while (ct_search.searchNotDone)
   {
#if $TV2_VHV_CT_SWIZZLE
      temp_intm = MATH.LegacyRound(ct_search.xForceValueMS);
      lsw_data = ((temp_intm & 0x01f) << 4) + ((temp_intm & 0x1e0) >> 5);
#else
      lsw_data = MATH.LegacyRound(ct_search.xForceValueMS);
#endif
      WriteRamContentDec_32Bit(addr,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
      meas_val = DoIMeasure(testpad, tcrnum, tcrmode, testnum, maxtime, tdelay);
      
      // Dlog the trim code tried...but don't really care if it passes or don't send to TW
      str1 = "VHV_ER_CT_ITER_CODE_" + i;
      TIDlog.Value(msw_data, testpad, 0, 511, "", str1, UTL_VOID, UTL_VOID, false, TWMinimumData);
      // Dlog the value of the measure...send to TW if logena
      str1 = "VHV_ER_CT_ITER_" + i;
      TIDlog.Value(meas_val, testpad, llim_pre, ulim_pre, meas_val.GetUnits(), 
                                 str1, UTL_VOID, UTL_VOID, logena, TWMinimumData); 
      
      
      if (tistdscreenprint and TI_FlashDebug and tiprintpass)
         ReadRamAddress(k, k+(8*ADDR_RAM_INC));
 
      
      // put this at end of loop because it will disable sites
      // sites will be re-enabled by this routine when the search is done
      ct_search.SearchNext(meas_val);
   }

   // Round the final val just like we did when using it
   ctval = MATH.LegacyRound(ct_search.xForceValueMS);

   TIME.Wait(2ms);

   VHV_ER_CT_STARTSAVED = ctval - CTOFFSET; /*for ~9V*/
   VHV_ER_CT_STOPSAVED = ctval;
   
   /*final check to see if w/in tolerance limit*/
#if $TV2_VHV_CT_SWIZZLE
   lsw_data = ((ctval & 0x01f) << 4) + ((ctval & 0x1e0) >> 5);
#else
   lsw_data = ctval;
#endif
   msw_data = pgct;
   WriteRamContentDec_32Bit(addr,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

#if $FL_USE_NEW_VHV_TEMPL_ADDR  
   addr_emu = ADDR_RAM_TEMPL_VHVE_PMT_EMU;
   WriteRamContentDec_32Bit(addr_emu,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
#endif

   meas_val = DoIMeasure(testpad, tcrnum, tcrmode, testnum, maxtime, tdelay);

   str1 = "VHV_ER_CT_SOL";
   tmp_results = TIDlog.Value(ctval, testpad, 0, 511, "", str1, UTL_VOID, UTL_VOID, true, TWMinimumData);
   
   str1 = "VHV_ER_CT_NM";
   final_results = TIDlog.Value(meas_val, testpad, llim_pre, ulim_pre, meas_val.GetUnits(), str1,
                                UTL_VOID, UTL_VOID, true, TWMinimumData);

   test_results = DLOG.AccumulateResults(tmp_results, final_results);
   ret_ctval = ctval;

   if(tistdscreenprint and TI_FlashDebug)   
   {
      IntS j = ADDR_RAM_TEMPL_VHVE_SM;
      k = ADDR_RAM_TEMPL_VHVPV_PMT_EMU;
#if $FL_USE_NEW_VHV_TEMPL_ADDR  
      ReadRamAddress(j,k+(8*ADDR_RAM_INC));;
#else
      ReadRamAddress(j,j+(8*ADDR_RAM_INC));
#endif   
   }

   ttimer1 = TIME.StopTimer();
   str1 = "VHV_ER_CT_TRIM_TTT";
   TIDlog.Value(ttimer1, UTL_VOID, 0., UTL_VOID, "s", str1, UTL_VOID, UTL_VOID, logena, TWMinimumData);

   return(test_results);
   
}   /* F021_VHV_PG_CT_Trim_func */

TMResultM F021_VHV_PV_CT_Trim_func(IntM &ret_ctval)
{
   const FloatS PGSTEP = 0.02V;
   const unsigned MAXITER = 30; 

   Sites new_active_sites;
   Sites savesites = ActiveSites;
   TMResultM final_results,tmp_results;
   TMResultM test_results = TM_NOTEST;
   IntS testnum,addr,addr_emu;
   IntS tcrnum;
   TPModeType tcrmode;
   StringS str1;
   FloatS ttimer1,maxtime,tdelay;
   FloatS llim_pre,ulim_pre;
   FloatS llim,ulim,target; 
   FloatS toler;
   PinM testpad;
   FloatM meas_val;
   IntM ctval,ersct,pgct,pre_pgct;
   IntM lsw_data,msw_data;
   BoolS bcd_format,hexvalue;
   BoolS logena; 
    /*++++++++++++++++++++*/

   if(tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ F021_VHV_PV_CT_Trim_func +++++" << endl;

   logena = true;  /*log to tw*/
   maxtime = GL_F021_PARAM_MAXTIME;
   tdelay = 10ms;
   
   tcrnum  = 115;
   tcrmode = PvfyMode;
   testpad = FLTP1;
   testnum = TNUM_PUMP_VHVPVFY;

   llim_pre = TCR.TP1_LLim[tcrnum][tcrmode];
   ulim_pre = TCR.TP1_ULim[tcrnum][tcrmode];

   target = VHV_Pvfy_Target;
   toler = 0.005;  /*1%*/
   llim = target-(target*toler);  // VLCT used a llim of ...(target*toler*0.5) w/ toler of 0.01...but 
                                  // search module does not allow different lower and upper tolerance
                                  // see if this is ok on DiamondX using tighter tolerance all around
   ulim = target+(target*toler);

    /*OTP template in RAM : pvfy/other*/
   addr = ADDR_RAM_TEMPL_VHVPV_PMT;
//   GetRamContentDec_16Bit("ramread_nburst_msw_Thrd",addr,pre_pgct);
//   GetRamContentDec_16Bit("ramread_nburst_lsw_Thrd",addr,ersct);   
   GetRamContentDec_16Bit("ramread_nburst_msw_v4p0_Thrd",addr,pre_pgct);
   GetRamContentDec_16Bit("ramread_nburst_lsw_v4p0_Thrd",addr,ersct);
   pgct = pre_pgct;
   ctval = pre_pgct;

   if(tistdscreenprint and TI_FlashDebug and tiprintpass)   
      ReadRamAddress(addr,addr+(4*ADDR_RAM_INC));
   
   VHV_OTHER_CT_TRIMSAVED = ersct;
   
   bcd_format = true;
   hexvalue = true;
   lsw_data = ersct;

   TIME.StartTimer();

   if(ActiveSites.Begin().End())  
   {
      return (TM_NOTEST);
   }
      
   SearchMod ct_search;
   ct_search.SASearchBegin(FloatM(0.),FloatM(511.),FloatM(toler*target), FloatM(target), MAXITER);
   ct_search.SkipMinMax(true);

   IntS i = 0;
   while (ct_search.searchNotDone)
   {
      msw_data = MATH.LegacyRound(ct_search.xForceValueMS);
      WriteRamContentDec_32Bit(addr,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
      meas_val = DoIMeasure(testpad, tcrnum, tcrmode, testnum, maxtime, tdelay);
      
      // Dlog the trim code tried...but don't really care if it passes or don't send to TW
      str1 = "VHV_PV_CT_ITER_CODE_" + i;
      TIDlog.Value(msw_data, testpad, 0, 511, "", str1, UTL_VOID, UTL_VOID, false, TWMinimumData);
      // Dlog the value of the measure...send to TW if logena
      str1 = "VHV_PV_CT_ITER_" + i;
      TIDlog.Value(meas_val, testpad, llim_pre, ulim_pre, meas_val.GetUnits(), 
                                 str1, UTL_VOID, UTL_VOID, logena, TWMinimumData); 
      
      // put this at end of loop because it will disable sites
      // sites will be re-enabled by this routine when the search is done
      ct_search.SearchNext(meas_val);
   }

   // Round the final val just like we did when using it
   ctval = MATH.LegacyRound(ct_search.xForceValueMS);

   TIME.Wait(2ms);

    /*final check to see if w/in tolerance limit*/
   lsw_data = ersct;
   msw_data = ctval;
   WriteRamContentDec_32Bit(addr,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

#if $FL_USE_NEW_VHV_TEMPL_ADDR  
    /*emu bank*/
   addr_emu = ADDR_RAM_TEMPL_VHVPV_PMT_EMU;
   WriteRamContentDec_32Bit(addr_emu,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
#endif

   meas_val = DoIMeasure(testpad, tcrnum, tcrmode, testnum, maxtime, tdelay);

   str1 = "VHV_PV_CT_TRIM_SOL";
   tmp_results = TIDlog.Value(ctval, testpad, 0, 511, "", str1, UTL_VOID, UTL_VOID, true, TWMinimumData);
   
   str1 = "VHV_PV_CT_TRIM_NM";
   final_results = TIDlog.Value(meas_val, testpad, llim_pre, ulim_pre, meas_val.GetUnits(), str1,
                                UTL_VOID, UTL_VOID, true, TWMinimumData);

   test_results = DLOG.AccumulateResults(tmp_results, final_results);
   ret_ctval = ctval;

   if(tistdscreenprint and TI_FlashDebug and tiprintpass)   
#if $FL_USE_NEW_VHV_TEMPL_ADDR  
            ReadRamAddress(addr-ADDR_RAM_INC,addr_emu+(3*ADDR_RAM_INC));;
#else
            ReadRamAddress(addr-ADDR_RAM_INC,addr+(3*ADDR_RAM_INC));
#endif   

   ttimer1 = TIME.StopTimer();
   str1 = "VHV_PV_TRIM_TTT";
   TIDlog.Value(ttimer1, UTL_VOID, 0., UTL_VOID, "s", str1, UTL_VOID, UTL_VOID, logena, TWMinimumData);

   return(test_results);
   
}   /* F021_VHV_PV_CT_Trim_func */

// /*modify shell OTP template pg/er/pv ct in RAM*/
void RAM_Upload_VHV_CT_TrimVal() {
   const IntS CTADDR = 0x3090; 
   const IntS CTADDR_START = 0x3080; 
   const IntS CTADDR_STOP = 0x3084; 

   IntS site,addr_loc,addr_emu;
   IntM msw_data,lsw_data;
   IntM tdata1,tdata2;
   BoolS bcd_format,hexvalue;

   if (tistdscreenprint)  
      cout << "+++++ RAM_Upload_VHV_CT_TrimVal +++++" << endl;

   bcd_format  = true;
   hexvalue    = true;
   addr_loc = ADDR_RAM_TEMPL_VHVE_PMT;
      
#if $TV2_VHV_CT_SWIZZLE  
   if (TITestType==MP1) {
      tdata1 = VHV_ER_CT_TRIMSAVED + 0x01f;
      tdata1 *= 0x10;
      tdata2 = VHV_ER_CT_TRIMSAVED + 0x1e0;
      tdata2 /= 0x20;
      lsw_data = tdata1 + tdata2;
   }
   else {
      lsw_data = VHV_ER_CT_TRIMSAVED;
   } 
#else
      lsw_data = VHV_ER_CT_TRIMSAVED;
#endif
      msw_data = VHV_PG_CT_TRIMSAVED;
      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
      
#if $FL_USE_NEW_VHV_TEMPL_ADDR  
   addr_emu = ADDR_RAM_TEMPL_VHVE_PMT_EMU;
   if (SelectedTITestType==MP1) {
      WriteRamContentDec_32Bit(addr_emu,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
   }
   else {
      lsw_data = VHV_ER_CT_TRIMSAVED_EMU;
      msw_data = VHV_PG_CT_TRIMSAVED_EMU;
      WriteRamContentDec_32Bit(addr_emu,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
   }       
#endif
      
   addr_loc = addr_loc+ADDR_RAM_INC;
   msw_data = VHV_PV_CT_TRIMSAVED;
   lsw_data = VHV_OTHER_CT_TRIMSAVED;
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

#if $FL_USE_NEW_VHV_TEMPL_ADDR  
   addr_emu = addr_emu+ADDR_RAM_INC;
   if (SelectedTITestType==MP1) {
      WriteRamContentDec_32Bit(addr_emu,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
   }
   else {
      msw_data = VHV_PV_CT_TRIMSAVED_EMU;
      lsw_data = VHV_OTHER_CT_TRIMSAVED_EMU;
      WriteRamContentDec_32Bit(addr_emu,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
   } 
#endif
      
   /*for SM reg*/
   addr_loc = ADDR_RAM_TEMPL_VHVE_SM;
      
#if $TV2_VHV_CT_SWIZZLE  
   if (SelectedTITestType==MP1) {
      tdata1 = VHV_ER_CT_STARTSAVED + 0x01f;
      tdata1 *= 0x10;
      tdata2 = VHV_ER_CT_STARTSAVED + 0x1e0;
      tdata2 /= 0x20;
      msw_data = tdata1 + tdata2;
   }
   else {
      msw_data = VHV_ER_CT_STARTSAVED;
   } 
#else
      msw_data = VHV_ER_CT_STARTSAVED;
#endif

   lsw_data = VHV_ER_CT_STEPSAVED;
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
      

#if $FL_USE_NEW_VHV_TEMPL_ADDR  
   addr_emu = ADDR_RAM_TEMPL_VHVE_SM_EMU;
   if (SelectedTITestType==MP1) {
      WriteRamContentDec_32Bit(addr_emu,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
   }
   else {
      lsw_data = VHV_ER_CT_STEPSAVED_EMU;
      msw_data = VHV_ER_CT_STARTSAVED_EMU;
      WriteRamContentDec_32Bit(addr_emu,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
   } 
#endif
      
   if(tistdscreenprint and TI_FlashDebug) {
      addr_loc = ADDR_RAM_TEMPL_VHVE_SM;
      addr_emu = ADDR_RAM_TEMPL_VHVPV_PMT_EMU;
      
#if $FL_USE_NEW_VHV_TEMPL_ADDR  
      ReadRamAddress(addr_loc,addr_emu+(8*ADDR_RAM_INC));;
#else
      ReadRamAddress(addr_loc,addr_loc+(8*ADDR_RAM_INC));
#endif
   }
}   // RAM_Upload_VHV_CT_TrimVal

//
// /*use for otp data pgm*/
void RAM_Upload_VHV_PMOS_EngOvride(IntS bank)
{
   const IntS MB_WRFLAG = 0x1234;    

   IntS site,addr_loc,ovrnumword;
   IntM msw_data,lsw_data;
   IntM tdata1,tdata2;
   IntM er_ct_start,er_ct_stop;
   BoolS bcd_format,hexvalue,debugprint;

//   if(v_any_dev_active)  
//   {
      if(tistdscreenprint and TI_FlashDebug)  
         cout << "+++++ RAM_Upload_VHV_PMOS_EngOvride +++++" << endl;

      bcd_format  = true;
      hexvalue    = true;
      addr_loc = ADDR_RAM_MAILBOX;

      ovrnumword = 0;
      
      if(GL_DO_VHV_CT_TRIM)  
         ovrnumword = 5;
      if(GL_DO_IREF_PMOS_TRIM)  
         ovrnumword = ovrnumword + 10;  /*not override CV*/

      ovrnumword = ovrnumword<<8;
      
      msw_data = MB_WRFLAG;  /*msword*/
      lsw_data = ovrnumword;  /*lsword*/
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

       /*vhv ct*/
      if(GL_DO_VHV_CT_TRIM)  
      {
         addr_loc = addr_loc+ADDR_RAM_INC;
         msw_data = OVRIND_VHV_ESTART_CT;
            
#if $FL_USE_NEW_VHV_TEMPL_ADDR  
         if(F021_Flash.EMUBANK[bank])  
            er_ct_start = VHV_ER_CT_STARTSAVED_EMU;
         else
            er_ct_start = VHV_ER_CT_STARTSAVED;
#else
         er_ct_start = VHV_ER_CT_STARTSAVED;
#endif            
         
#if $TV2_VHV_CT_SWIZZLE  
         ArrayAndIntegerValue(tdata1,er_ct_start,0x01f,v_sites);
         ArrayMultIntegerValue(tdata1,tdata1,0x10,v_sites);  /*<<4*/
         ArrayAndIntegerValue(tdata2,er_ct_start,0x1e0,v_sites);
         ArrayDivIntegerValue(tdata2,tdata2,0x20,v_sites);   /*>>5*/
         ArrayAddinteger(lsw_data,tdata1,tdata2,v_sites);
#else
         lsw_data = er_ct_start;
#endif
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

         addr_loc = addr_loc+ADDR_RAM_INC;
         msw_data = OVRIND_VHV_ESTEP;
#if $FL_USE_NEW_VHV_TEMPL_ADDR  
         if(F021_Flash.EMUBANK[bank])  
            lsw_data = VHV_ER_CT_STEPSAVED_EMU;
         else
            lsw_data = VHV_ER_CT_STEPSAVED;
#else         
         lsw_data = VHV_ER_CT_STEPSAVED;
#endif
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

         addr_loc = addr_loc+ADDR_RAM_INC;
         msw_data = OVRIND_VHV_PG_CT;
#if $FL_USE_NEW_VHV_TEMPL_ADDR  
         if(F021_Flash.EMUBANK[bank])  
            lsw_data = VHV_PG_CT_TRIMSAVED_EMU;
         else
            lsw_data = VHV_PG_CT_TRIMSAVED;
#else
         lsw_data = VHV_PG_CT_TRIMSAVED;
#endif
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
         
         addr_loc = addr_loc+ADDR_RAM_INC;
         msw_data = OVRIND_VHV_ER_CT;
#if $FL_USE_NEW_VHV_TEMPL_ADDR  
         if(F021_Flash.EMUBANK[bank])  
            er_ct_start = VHV_ER_CT_TRIMSAVED_EMU;
         else
            er_ct_start = VHV_ER_CT_TRIMSAVED;
#else
         er_ct_start = VHV_ER_CT_TRIMSAVED;
#endif
         
#if $TV2_VHV_CT_SWIZZLE  
         ArrayAndIntegerValue(tdata1,er_ct_start,0x01f,v_sites);
         ArrayMultIntegerValue(tdata1,tdata1,0x10,v_sites);  /*<<4*/
         ArrayAndIntegerValue(tdata2,er_ct_start,0x1e0,v_sites);
         ArrayDivIntegerValue(tdata2,tdata2,0x20,v_sites);   /*>>5*/
         ArrayAddinteger(lsw_data,tdata1,tdata2,v_sites);
#else
         lsw_data = er_ct_start;
#endif
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
         
         addr_loc = addr_loc+ADDR_RAM_INC;
         msw_data = OVRIND_VHV_PV_CT;
#if $FL_USE_NEW_VHV_TEMPL_ADDR  
         if(F021_Flash.EMUBANK[bank])  
            lsw_data = VHV_PV_CT_TRIMSAVED_EMU;
         else
            lsw_data = VHV_PV_CT_TRIMSAVED;
#else
         lsw_data = VHV_PV_CT_TRIMSAVED;
#endif
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
      }   /*GL_DO_VHV_CT_TRIM*/

      if(GL_DO_IREF_PMOS_TRIM)  
      {
         addr_loc = addr_loc+ADDR_RAM_INC;
         msw_data = OVRIND_PV_PMOS_EVEN_RAT;
         lsw_data = IPMOS_TRIMCODE_VAL[bank][0];  /*even*/
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

         addr_loc = addr_loc+ADDR_RAM_INC;
         msw_data = OVRIND_PV_PMOS_ODD_RAT;
         lsw_data = IPMOS_TRIMCODE_VAL[bank][1];  /*odd*/
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

         addr_loc = addr_loc+ADDR_RAM_INC;
         msw_data = OVRIND_EV_PMOS_EVEN_RAT;
         lsw_data = IPMOS_TRIMCODE_VAL[bank][0];  /*even*/
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

         addr_loc = addr_loc+ADDR_RAM_INC;
         msw_data = OVRIND_EV_PMOS_ODD_RAT;
         lsw_data = IPMOS_TRIMCODE_VAL[bank][1];  /*odd*/
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

          /*not override CV...
          addr_loc := addr_loc+ADDR_RAM_INC;
          ArraySetInteger(msw_data,OVRIND_CV_PMOS_EVEN_RAT);
          ArrayCopyInteger(lsw_data,IPMOS_TRIMCODE_VAL[bank,0],v_sites); {even*/
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

         addr_loc = addr_loc+ADDR_RAM_INC;
         msw_data = OVRIND_CV_PMOS_ODD_RAT;
         lsw_data = IPMOS_TRIMCODE_VAL[bank][1];  /*odd*/
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         ...}

         addr_loc = addr_loc+ADDR_RAM_INC;
         msw_data = OVRIND_RDM0_PMOS_EVEN_RAT;
         lsw_data = IPMOS_TRIMCODE_VAL[bank][0];  /*even*/
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

         addr_loc = addr_loc+ADDR_RAM_INC;
         msw_data = OVRIND_RDM0_PMOS_ODD_RAT;
         lsw_data = IPMOS_TRIMCODE_VAL[bank][1];  /*odd*/
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

         addr_loc = addr_loc+ADDR_RAM_INC;
         msw_data = OVRIND_RDM1_PMOS_EVEN_RAT;
         lsw_data = IPMOS_TRIMCODE_VAL[bank][0];  /*even*/
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

         addr_loc = addr_loc+ADDR_RAM_INC;
         msw_data = OVRIND_RDM1_PMOS_ODD_RAT;
         lsw_data = IPMOS_TRIMCODE_VAL[bank][1];  /*odd*/
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

         addr_loc = addr_loc+ADDR_RAM_INC;
         msw_data = OVRIND_RD_PMOS_EVEN_RAT;
         lsw_data = IPMOS_TRIMCODE_VAL[bank][0];  /*even*/
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

         addr_loc = addr_loc+ADDR_RAM_INC;
         msw_data = OVRIND_RD_PMOS_ODD_RAT;
         lsw_data = IPMOS_TRIMCODE_VAL[bank][1];  /*odd*/
         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
      } 

      debugprint = tiprintpass and TI_FlashDebug;
      if(tistdscreenprint and debugprint)  
      {
         addr_loc = ADDR_RAM_MAILBOX;
         cout << "RAM_Upload_VHV_PMOS_EngOvride Bank" << bank/*bank:-1*/ << endl;
         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
               ReadRamAddress(addr_loc,addr_loc+(18*ADDR_RAM_INC));
      } 
//   }   /*if v_any_active*/
}   /* RAM_Upload_VHV_PMOS_EngOvride */
//   
// /*msw_val=even bank, lsw_val=odd bank with even/odd row already formatted*/
//void RAM_Upload_PMOS_SoftTrim_Bank(IntS bank,
//                                        BoolS bnkeven_ena,
//                                        BoolS bnkodd_ena,
//                                        IntM msw_val,
//                                        IntM lsw_val)
//{
//   IntS site,addr_loc,trimenakey,i,j;
//   IntM msw_data,lsw_data,evena,odena;
//   BoolS bcd_format,hexvalue;
//   BoolS debugprint;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ RAM_Upload_PMOS_SoftTrim_Bank +++++" << endl;
//
//      bcd_format  = true;
//      hexvalue    = true;
//      addr_loc = ADDR_RAM_IPMOS_MAILBOX;
//      trimenakey  = 0xaa55;
//      
//      msw_data = trimenakey;  /*msword*/
//
//       /*KChau 09/01/10 - shell changes which combined "bank even row, bank odd row" field into single field*/
//       /*so don"t care if even/odd row. therefore, input param bnkeven_ena/bnkodd_ena are ignored*/
//      i = 1<<bank;
//      lsw_data = i;  /*lsword*/
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      switch(bank) {
//        case 0..1: addr_loc = addr_loc+ADDR_RAM_INC;
//        case 2..3: addr_loc = addr_loc+(2*ADDR_RAM_INC);
//        case 4..5: addr_loc = addr_loc+(3*ADDR_RAM_INC);
//        case 6..7: addr_loc = addr_loc+(4*ADDR_RAM_INC);
//        default:  
//           addr_loc = addr_loc+ADDR_RAM_INC;
//           if(tistdscreenprint)  
//        case cout << "*** ERROR : INVALID BANK ENTERED <<  MUST BE <== 7 ***" << endl;
//         break; 
//      }   /* case */
//
//      WriteRamContentDec_32Bit(addr_loc,lsw_val,hexvalue,msw_val,hexvalue,bcd_format);
//
//      debugprint = false;
//      if(tistdscreenprint and debugprint)  
//      {
//         addr_loc = ADDR_RAM_IPMOS_MAILBOX;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               readramaddress(site,addr_loc,addr_loc+(6*ADDR_RAM_INC));
//      } 
//   } 
//}   /* RAM_Upload_PMOS_SoftTrim_Bank */
//
//
//void RAM_Clear_PMOS_SoftTrim_Bank(IntS bank)
//{
//   IntS site,addr_loc,trimenakey,i,j;
//   IntM msw_data,lsw_data;
//   BoolS bcd_format,hexvalue;
//   BoolS debugprint;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ RAM_Clear_PMOS_SoftTrim_Bank +++++" << endl;
//
//      bcd_format  = true;
//      hexvalue    = true;
//      addr_loc = ADDR_RAM_IPMOS_MAILBOX;
//      trimenakey  = 0x0000;
//      
//      msw_data = trimenakey;  /*msword*/
//      lsw_data = 0;  /*lsword*/
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      switch(bank) {
//        case 0..1: addr_loc = addr_loc+ADDR_RAM_INC;
//        case 2..3: addr_loc = addr_loc+(2*ADDR_RAM_INC);
//        case 4..5: addr_loc = addr_loc+(3*ADDR_RAM_INC);
//        case 6..7: addr_loc = addr_loc+(4*ADDR_RAM_INC);
//        default: addr_loc = addr_loc+ADDR_RAM_INC;
//      }   /* case */
//
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      debugprint = false;
//      if(tistdscreenprint and debugprint)  
//      {
//         addr_loc = ADDR_RAM_IPMOS_MAILBOX;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               readramaddress(site,addr_loc,addr_loc+(6*ADDR_RAM_INC));
//      } 
//   } 
//}   /* RAM_Clear_PMOS_SoftTrim_Bank */
//
//
//void RAM_Clear_PMOS_SoftTrim()
//{
//   IntS site,addr_loc,trimenakey,i,j;
//   IntM msw_data,lsw_data;
//   BoolS bcd_format,hexvalue;
//   BoolS debugprint;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ RAM_Clear_PMOS_SoftTrim +++++" << endl;
//
//      bcd_format  = true;
//      hexvalue    = true;
//      addr_loc = ADDR_RAM_IPMOS_MAILBOX;
//      trimenakey  = 0x0000;
//      
//      msw_data = trimenakey;  /*msword*/
//      lsw_data = 0;  /*lsword*/
//
//      for (i = 1;i <= 5;i++)
//      {
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         addr_loc = addr_loc+ADDR_RAM_INC;
//      } 
//
//      debugprint = false;
//      if(tistdscreenprint and debugprint)  
//      {
//         addr_loc = ADDR_RAM_IPMOS_MAILBOX;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               readramaddress(site,addr_loc,addr_loc+(6*ADDR_RAM_INC));
//      } 
//   } 
//}   /* RAM_Clear_PMOS_SoftTrim */
//
//void GetTrimCode_On_EFStr()
//{
//   const IntS BANK_EF_LEN = 32; 
//   const IntS PUMP_EF_LEN = 30; 
//   const IntS EVN0INDX = 23; 
//   const IntS ODD0INDX = 4; 
//   const IntS IND_VBG_MSB = 2; 
//   const IntS IND_VBG_LSB = 7; 
//   const IntS IND_FOSC_MSB = 9; 
//   const IntS IND_FOSC_LSB = 14; 
//   const IntS IND_IREF_USB = 16; 
//   const IntS IND_IREF_LSB = 20; 
//   const IntS IND_IREF_MSB = 22; 
//   const IntS IND_VHVSLCT_MSB = 23; 
//   const IntS IND_VHVSLCT_LSB = 26; 
//   const IntS IND_VSA5CT_MSB = 27; 
//   const IntS IND_VSA5CT_LSB = 30; 
//
//   IntS site,count,length,i;
//   IntS trimdata,lowerbank;
//   IntM bankena;
//   StringS dummstr1,dummstr2,pumpstr;
//   StringS bit5_9_str,bit24_28_str;
//   BoolS highbank;
//   StringS str1,str2;
//
//   if(V_any_dev_active)  
//   {
//      if(tistdscreenprint)  
//         cout << "+++++ GetTrimcode_On_EFStr +++++" << endl;
//
//      bankena = 0;
//
//      if(F021_Flash.MAXBANK>3)  
//      {
//         lowerbank = F021_Flash.MAXBANK mod 4;
//         highbank = true;
//      }
//      else
//      {
//         lowerbank = F021_Flash.MAXBANK;
//         highbank = false;
//      } 
//
//       /*retrieve trim code*/
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            for (count = 0;count <= F021_Flash.MAXBANK;count++)
//               bankena[site] = bankena[site] + (0x1<<count);
//
//            dummstr1 = SaveFlashProgString[site];
//            length = len(dummstr1);
//
//             /*extract pump trim for espump*/
//            if((TITestType!=MP1) and (GL_PUMPTYPE==ESPUMP))  
//            {
//               pumpstr = mid(dummstr1,1,PUMP_EF_LEN);
//               str1 = mid(pumpstr,IND_VBG_MSB,(IND_VBG_LSB-IND_VBG_MSB)+1);
//               readstring("0b" + str1) + i;
//               MAINBG_TRIMSAVED[site] = i;
//               str1 = mid(pumpstr,IND_FOSC_MSB,(IND_FOSC_LSB-IND_FOSC_MSB)+1);
//               readstring("0b" + str1) + i;
//               FOSC_TRIMSAVED[site] = i;
//               str1 = mid(pumpstr,IND_IREF_USB,(IND_IREF_LSB-IND_IREF_USB)+1);
//               str2 = mid(pumpstr,IND_IREF_MSB,1);
//               str1 = str2 + str1;
//               readstring("0b" + str1) + i;
//               MAINIREF_TRIMSAVED[site] = i;
//               str1 = mid(pumpstr,IND_VHVSLCT_MSB,(IND_VHVSLCT_LSB-IND_VHVSLCT_MSB)+1);
//               readstring("0b" + str1) + i;
//               VHV_SLPCT_TRIMSAVED[site] = i;
//               str1 = mid(pumpstr,IND_VSA5CT_MSB,(IND_VSA5CT_LSB-IND_VSA5CT_MSB)+1);
//               readstring("0b" + str1) + i;
//               VSA5CT_TRIMSAVED[site] = i;
//               if(tistdscreenprint)  
//                  cout << "Site" << site:-5 << " MAINBG_TRIMSAVED == " << MAINBG_TRIMSAVED[site]:-5 << 
//                          " MAINIREF_TRIMSAVED == " << MAINIREF_TRIMSAVED[site]:-5 << 
//                          " FOSC_TRIMSAVED == " << FOSC_TRIMSAVED[site]:-5 << 
//                          " VHVSLPCT_TRIMSAVED == " << VHV_SLPCT_TRIMSAVED[site]:-5 << 
//                          " VSA5CT_TRIMSAVED == " << VSA5CT_TRIMSAVED[site]:-5 << endl;               
//            } 
//            
//             /*remove pump*/
//            dummstr1 = mid(dummstr1,(PUMP_EF_LEN+1),(length-PUMP_EF_LEN));
//
//            for (count = 0;count <= lowerbank;count++)
//            {
//               writestring(bit5_9_str,mid(dummstr1,(EVN0INDX+(count*BANK_EF_LEN)),5));
//               dummstr2 = (bit5_9_str); /*stringreverse*/
//               readstring("0b" + dummstr2) + trimdata;
//               IPMOS_TRIMCODE_VAL[count][0][site] = trimdata;  /*even*/
//               
//               writestring(bit24_28_str,mid(dummstr1,(ODD0INDX+(count*BANK_EF_LEN)),5));
//               dummstr2 = (bit24_28_str); /*stringreverse*/
//               readstring("0b" + dummstr2) + trimdata;
//               IPMOS_TRIMCODE_VAL[count][1][site] = trimdata;  /*odd*/
//
//               if(tistdscreenprint and TI_FlashDebug)  
//                  cout << "Site" << site:-5 << " Bank" << count:-5 << " TrimCode Even== " << IPMOS_TRIMCODE_VAL[count][0][site]:s_hex:-6 << 
//                          " Odd== " << IPMOS_TRIMCODE_VAL[count][1][site]:s_hex:-6 << endl;
//            }   /*for count*/
//
//            if(highbank)  
//               for (count = 4;count <= F021_Flash.MAXBANK;count++)
//               {
//                  writestring(bit5_9_str,mid(dummstr1,(EVN0INDX+(count*BANK_EF_LEN)),5));
//                  dummstr2 = (bit5_9_str); /*stringreverse*/
//                  readstring("0b" + dummstr2) + trimdata;
//                  IPMOS_TRIMCODE_VAL[count][0][site] = trimdata;  /*even*/
//                  
//                  writestring(bit24_28_str,mid(dummstr1,(ODD0INDX+(count*BANK_EF_LEN)),5));
//                  dummstr2 = (bit24_28_str); /*stringreverse*/
//                  readstring("0b" + dummstr2) + trimdata;
//                  IPMOS_TRIMCODE_VAL[count][1][site] = trimdata;  /*odd*/
//
//                  if(tistdscreenprint and TI_FlashDebug)  
//                     cout << "Site" << site:-5 << " Bank" << count:-5 << " TrimCode Even== " << IPMOS_TRIMCODE_VAL[count][0][site]:s_hex:-6 << 
//                             " Odd== " << IPMOS_TRIMCODE_VAL[count][1][site]:s_hex:-6 << endl;
//               }   /*for count*/
//
//         }   /*if v_dev_active*/
//
//       /*store to global vars*/
//      IPMOS_BANKENA_MSW = bankena;
//      IPMOS_BANKENA_LSW = bankena;
//      
//   }   /*if v_any_dev_active*/
//
//}   /* GetTrimCode_On_EFStr */
//
//
void RAM_Upload_PMOS_TrimCode() {
   IntS    site,addr_loc,trimenakey,bank,maxbk,i;
   IntM    msw_data,lsw_data,edata,odata;
   BoolS   bcd_format,hexvalue;
   BoolS   debugprint,logena,sbool1;
   StringS str1,str2,str3;
   StringM logstr;

   if(tistdscreenprint)  
      cout << "+++++ RAM_Upload_PMOS_TrimCode +++++" << endl;

   bcd_format  = true;
   hexvalue    = true;
   addr_loc = ADDR_RAM_IPMOS_MAILBOX;
   trimenakey  = 0xaa55;
   
   msw_data = trimenakey;  /*msword*/
   lsw_data = IPMOS_BANKENA_LSW;
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

   logena = false;  /*log trimcode str to tw*/
 
   if(logena) logstr = "";   // Null trimcode str

   maxbk = F021_Flash.MAXBANK;
   
   for ( bank = 0; bank <= maxbk; bank += 2 ) {
      addr_loc = addr_loc+ADDR_RAM_INC;
      edata = IPMOS_TRIMCODE_VAL[bank][0];  /*even*/
      edata *= 256;
      odata = IPMOS_TRIMCODE_VAL[bank][1];  /*odd*/
      msw_data = edata + odata;

      if( (bank == maxbk) and (bank % 2) == 0 )
         sbool1 = true;
      else
         sbool1 = false;

      if(sbool1)  
         lsw_data = 0; /*dummy*/
      else {
         edata = IPMOS_TRIMCODE_VAL[bank+1][0];  /*even*/
         edata *= 256;
         odata = IPMOS_TRIMCODE_VAL[bank+1][1];  /*odd*/
         lsw_data = edata + odata;
      } 
         
      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

      if(logena) {
         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
            IO.Print(str2, "0x%04x", msw_data);       
            if(bank!=0) {
               str2.Replace(str2.Find("0x"), 2, "");  /*remove 0x*/
            } 
            logstr += str2;
         }
         
         if(not sbool1) {
            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
               IO.Print(str2, "0x%04x", msw_data);
               str2.Replace(str2.Find("0x"), 2, "");
               logstr += str2;
            } 
         } 
      }
   }   

   if(logena) {
      str1 = "IPMOS_TRIMCODE_STR";
      TWPDLDataLogText(str1,logstr,TWMinimumData);
   } 

   debugprint = tiprintpass and TI_FlashDebug;
   if(tistdscreenprint and debugprint) {
      addr_loc = ADDR_RAM_IPMOS_MAILBOX;  
      ReadRamAddress(addr_loc,addr_loc+(6*ADDR_RAM_INC));
   }  
}   // RAM_Upload_PMOS_TrimCode

//
// /*pump efuse soft trim*/
// /*note: bg=upper 8bit, iref=lower 8bit @0xd6, vsa5ct=upper 8bit, slopect=lower 8bit @0xd8, fosc=upper 8bit @0xda*/
//void RAM_Upload_SoftTrim_All(IntS BGapVal,
//                                  IntS IRefVal,
//                                  IntS FOSCVal,
//                                  IntS VHVSLPVal,
//                                  IntS VSA5CTVal)
//{
//   IntS site,addr_loc,trimenakey,i;
//   IntM msw_data,lsw_data;
//   BoolS bcd_format,hexvalue;
//   BoolS debugprint;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ RAM_Upload_SoftTrim_All +++++" << endl;
//
//      bcd_format  = true;
//      hexvalue    = true;
//      addr_loc = ADDR_RAM_EFSOFTTRIM;
//      trimenakey  = 0xaa55;
//      
//      msw_data = trimenakey;  /*msword*/
//      i = (BGapVal<<8) + IRefVal;
//      lsw_data = i;  /*lsword*/
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      i = (VSA5CTVal<<8) + VHVSLPVal;
//      msw_data = i;
//      i = FOSCVal<<8;
//      lsw_data = i;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//
//      debugprint = false;
//      if(tistdscreenprint and debugprint)  
//      {
//         addr_loc = ADDR_RAM_EFSOFTTRIM;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               readramaddress(site,addr_loc,addr_loc+(3*ADDR_RAM_INC));
//      } 
//   } 
//}   /* RAM_Upload_SoftTrim_All */
//

void RAM_Upload_SoftTrim(const IntS &trimenakey,
                         const IntM &BGapVal,
                         const IntM &IRefVal,
                         const IntM &FOSCVal,
                         const IntM &VHVSLPVal,
                         const IntM &VSA5CTVal)
{
   IntS addr_loc;
   IntM msw_data,lsw_data;
   BoolS bcd_format,hexvalue;
   BoolS debugprint;

   if (tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ RAM_Upload_SoftTrim +++++" << endl;

   bcd_format  = true;
   hexvalue    = true;
   addr_loc = ADDR_RAM_EFSOFTTRIM;
   
   msw_data = trimenakey;  /*msword*/
   lsw_data = BGapVal << 8; /*lshift 8bit*/
   lsw_data += IRefVal;  /*lsword*/
   
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
   addr_loc = addr_loc+ADDR_RAM_INC;
   
   msw_data = VSA5CTVal << 8; /*lshift 8bit*/
   msw_data += VHVSLPVal;

   lsw_data = FOSCVal << 8; /*lshift 8bit */
   WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

   debugprint = false;
   if(tistdscreenprint and debugprint)  
   {
      addr_loc = ADDR_RAM_EFSOFTTRIM;
      ReadRamAddress(addr_loc,addr_loc+(3*ADDR_RAM_INC));
   } 
}   /* RAM_Upload_SoftTrim */


void RAM_Clear_SoftTrim_All()
{
   IntS addr_loc,trimenakey,i;
   IntM msw_data,lsw_data;
   BoolS bcd_format,hexvalue;
   BoolS debugprint;

   bcd_format  = true;
   hexvalue    = true;
   addr_loc = ADDR_RAM_EFSOFTTRIM;
   msw_data = 0;  /*msword*/
   lsw_data = 0;  /*lsword*/

   //for giggles and debug, read ram before we clear it
   // :TODO: Remove after initial RAM function debug!
   ReadRamAddress(addr_loc, addr_loc+(3*ADDR_RAM_INC));

   if(tistdscreenprint)  
      cout << "+++++ RAM_Clear_SoftTrim_All +++++" << endl;

   for (i = 0;i <= 1;i++)
   {
      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
      addr_loc = addr_loc+ADDR_RAM_INC;
   } 

   debugprint = true;
   if(tistdscreenprint and debugprint)  
   {
      addr_loc = ADDR_RAM_EFSOFTTRIM; 
      ReadRamAddress(addr_loc,addr_loc+(3*ADDR_RAM_INC));
   } 
}   /* RAM_Clear_SoftTrim_All */

TMResultM F021_Pump_Para_func(    IntS start_testnum,
                                 prepostcorner prepost_type,
                                 VCornerType vcorner_type,
                                 IntS TCRnum,
                                 TPModeType TCRMode)
{
   FloatS tdelay,maxtime;
   TMResultM final_results, rtest_results, tmp_results;
   IntS length;
   FloatS ttimer2_start, ttimerS;
   FloatM tt_timer;
   StringS test_name,tw_name, dlog_comment;
   StringS unitval;
   StringS fl_testname;
   IntS testnum,pattype;
   IntS tpnum,tpstart,tpstop,tpcount;
   prepostcorner prepost;
   PinM testpad,testpad2;
   FloatM meas_value;
   StringM site_cof_inst_str;
   BoolS done,once,ovride_lim,parmena;
   FloatS llim,ulim;
   VCornerType vcorner;
   Sites savesites, new_active_sites;
   int int_site;
   bool any_site_active = true;

   final_results = TM_NOTEST;

   parmena = false;
   vcorner = vcorner_type;
   
   tpstart = 0;
   tpstop  = 0;
   for (tpnum = GL_TPADMIN;tpnum <= GL_TPADMAX;tpnum++)
      if(PUMP_BANK_PARA_ENABLE[TCRnum][TCRMode][tpnum])  
      {
         if(!parmena)  
            parmena = true;
         if(tpstart==0)  
            tpstart = tpnum;
         tpstop = tpnum;
      } 
   if(tpstart==0)  
      tpstop = -1;

   if(parmena)  
   {
      if(tistdscreenprint and TI_FlashDebug)  
         IO.Print(IO.Stdout,"+++++ F021_Pump_Para_func +++++\n");

#if $TP3_TO_TP5_PRESENT  
      if(TCRnum==115) 
      {
         VI.Gate(FLTP3, VI_GATE_OFF_LOZ);
         VI.Disconnect(FLTP3);
      }
#endif
      
      maxtime = GL_F021_PARAM_MAXTIME;
      tdelay  = 10ms;
      testnum = start_testnum;
      
      TIME.StartTimer(); //ttimer1

      savesites = ActiveSites;

      prepost = prepost_type;

      once = false;

      for (tpnum = tpstart;tpnum <= tpstop;tpnum++)
      {
         if(PUMP_BANK_PARA_ENABLE[TCRnum][TCRMode][tpnum])  
         {
            ttimer2_start = TIME.GetTimer();
            
            fl_testname = PUMP_BANK_PARA_TESTNAME[TCRnum][TCRMode][tpnum][prepost][vcorner];
            length = fl_testname.Length();
            // strip off _Test
            test_name = fl_testname.Substring(0,length-5); // don't know why VLCT started at 2 must be something w/ their naming
         
   // :TODO: come back and do this, it's an OpVar...for now we'll say it's false and move on
//            if(TI_FlashCOFEna)  
//               F021_Init_COF_Inst_Str(site_cof_inst_str);

            if(!once)  
            {
               F021_Set_TPADS(TCRnum,TCRMode);
               rtest_results = F021_RunTestNumber_PMEX(testnum,maxtime);
               TIME.Wait(tdelay);
               if(TCRnum==0)  
                  TIME.Wait(2*tdelay);
               once = true;
            } 
            
            switch(tpnum) {
              case 1 :  
                     testpad = FLTP1;
                     llim = TCR.TP1_LLim[TCRnum][TCRMode];
                     ulim = TCR.TP1_ULim[TCRnum][TCRMode];
                   break; 
              case 2 :  
                     testpad = FLTP2;
                     llim = TCR.TP2_LLim[TCRnum][TCRMode];
                     ulim = TCR.TP2_ULim[TCRnum][TCRMode];
                   break; 
#if $TP3_TO_TP5_PRESENT  
              case 3 :  
                     testpad = FLTP3;
                     llim = TCR.TP3_LLim[TCRnum][TCRMode];
                     ulim = TCR.TP3_ULim[TCRnum][TCRMode];
                   break; 
              case 4 :  
                     testpad = FLTP4;
                     llim = TCR.TP4_LLim[TCRnum][TCRMode];
                     ulim = TCR.TP4_ULim[TCRnum][TCRMode];
                   break; 
              case 5 :  
                     testpad = FLTP5;
                     llim = TCR.TP5_LLim[TCRnum][TCRMode];
                     ulim = TCR.TP5_ULim[TCRnum][TCRMode];
                   break; 
#endif
#if $TADC_PRESENT  
              case 6 :  
                     testpad = P_TESTADC;
                     llim = TCR.TADC_LLim[TCRnum][TCRMode];
                     ulim = TCR.TADC_ULim[TCRnum][TCRMode];
                   break; 
#endif
            }   /*case tpnum*/

            TIME.Wait(tdelay);

            meas_value = F021_Meas_TPAD_PMEX(testpad,TCRnum,TCRMode);
         
             /*store/copy to global var vhv params*/
            if(TCRnum==0)  
            {
               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
               {
                  // site enum doesn't work like others, evidently, have
                  // to explicitly convert to int here to use as index
                  // remember, array starts at 0
                  int_site = int(*si);
                  TPAD_LEAK_VALUE[TCRMode][prepost][tpnum][*si] = meas_value[*si];
               }
            }
            else if(((TCRnum==115) || (TCRnum==120)) && (vcorner==VMN) && (testpad==FLTP1))  
               PUMP_PARA_VALUE.SetValue(TCRMode, prepost, meas_value);


            ttimerS = TIME.GetTimer() - ttimer2_start;
            tt_timer = ttimerS;
            
             /*log test time to TW*/
            tw_name = test_name + "_TT";
            unitval = "s";
            TWPDLDataLogRealVariable(tw_name, unitval, tt_timer,TWMinimumData);

            unitval = meas_value.GetUnits(); // V or A set during F021_Meas_TPAD_PMEX

            IO.Print(dlog_comment, "F021_Pump_Para_func testnum is 0x%x.\n", testnum);
            DLOG.Text(dlog_comment);
            
            // force a passing value in the simulator
            if (SYS.TesterSimulated())
               meas_value = ((ulim - llim) / 2.) + llim;
               
            tmp_results = TIDlog.Value(meas_value, testpad, llim, ulim, unitval, test_name, UTL_VOID, 
                                       UTL_VOID, true, TWMinimumData);
            
            final_results = DLOG.AccumulateResults(tmp_results, rtest_results);
            
             /*bin out on post meas/efuse trim only*/
            if((prepost == post) && (PUMP_BANK_PARA_BINOUT[TCRnum][TCRMode][tpnum]))
            {
               // if any site has failed
               if(final_results.AnyEqual(TM_FAIL))  
               {
               // :TODO: come back and fix this stuff
//                  F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
//                  if(TI_FlashCOFEna)  
//                  {
//                     tmpstr2 = '_' + tmpstr1;
//                     F021_Update_COF_Inst_Str(tmpstr2,site_cof_inst_str,tmp_results);
//                     F021_Save_COF_Info('',site_cof_inst_str,tmp_results);
//                  } 
               } 
               
               if(!RunAllTests && (!TI_FlashCOFEna))  
               {
                  new_active_sites = ActiveSites;
                  new_active_sites.DisableFailingSites(final_results == TM_PASS);
                  any_site_active = SetActiveSites(new_active_sites);
               }
            }
            
            if(tistdscreenprint)  
               cout << test_name << " TT : " << ttimerS << endl;
         }   /*if pump_para_enable*/

         if(!any_site_active) 
            break;

      }   /*for tpnum*/

      // want to turn on any sites that we turned off during the loop 
      // so that results get reported & tpads are turned off
      RunTime.SetActiveSites(savesites);
            
      F021_TurnOff_AllTPADS();

       /*devsetholdstates(savesites);*/

// :TODO: come back and fix this, skipped for now b/c debug 
// issue b/c we have to activate sites to turn off tpads...
// but here we don't want to do it if sites are off....hmmm...
// well, it is debug so I guess we could do for all.
//      if((!ActiveSites.Begin().End()) && TI_FlashDebug)  
//      {
//          /*check for valid tnum and re-binning any fail*/
//         Check_RAM_TNUM(testnum,tmp_results);
//      }   /*v_any_dev_active*/

      tt_timer = TIME.StopTimer();
      if(tistdscreenprint)  
      {
         IO.Print(IO.Stdout,"F021_Pump_Para_func TT : %e\n\n",tt_timer);
      } 
            
   }   /*if parmena*/

   return (final_results);
}   /*F021_Pump_Para_func*/

//BoolS F021_Bank_Para_func(    IntS start_testnum,
//                                 prepostcorner prepost_type,
//                                 VCornerType vcorner,
//                                 IntS TCRnum,
//                                 TPModeType TCRMode,
//                                 BoolM test_results)
//{
//   const IntS NONE_OPT = 0; 
//   const IntS EV_EMU_OPT = 1; 
//
//   FloatS tdelay,maxtime;
//   BoolM savesites,logsites,rtest_results;
//   BoolM tmp_results,final_results;
//   IntS site,bankcount;
//   IntS pattype,testnum;
//   IntS tpnum,tpstart,tpstop,tpcount;
//   FloatS ttimer1,ttimer2;
//   FloatM tt_timer;
//   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
//   FloatM FloatSval;
//   TWunit unitval;
//   StringS fl_testname;
//   prepostcorner prepost;
//   BoolS parmena,done,once,ovride_lim;
//   FloatS ovride_llim,ovride_ulim;
//   FloatS llim,ulim;
//   PinM testpad,cntrlpad;
//   FloatM meas_value;
//   FloatS tpad_force,cntrlpad_force;
//   BoolS x64soft;
//   StringM site_cof_inst_str;
//   BoolS binout_ena;
//   IntS special_opt;
//
//   parmena = false;
//   binout_ena = false;
//   prepost = prepost_type;
//
//   if((TCRNUM==25) and (TCRMode==EvfyMode))  
//      special_opt = EV_EMU_OPT;
//   else
//      special_opt = NONE_OPT;      
//
//   if(V_any_dev_active)  
//   {
//      tpstart = 0;
//      tpstop  = 0;
//      for (tpnum = GL_TPADMIN;tpnum <= GL_TPADMAX;tpnum++)
//         if(PUMP_BANK_PARA_ENABLE[TCRnum][TCRmode][tpnum])  
//         {
//            if(not parmena)  
//            {
//               fl_testname = PUMP_BANK_PARA_TESTNAME[TCRnum][TCRmode][tpnum][prepost][vcorner];
//               parmena = true;
//            } 
//            if(tpstart==0)  
//               tpstart = tpnum;
//            tpstop = tpnum;
//         } 
//      if(tpstart==0)  
//         tpstop  = -1;
//   } 
//
//   if(v_any_dev_active and parmena)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ F021_Bank_Para_func +++++" << endl;
//      
//      tdelay  = 10ms;
//      maxtime = GL_F021_PARAM_MAXTIME;
//
//      timernstart(ttimer1);      
//
//      savesites = V_dev_active;
//      tmp_results = V_dev_active;
//      final_results = V_dev_active;
//
//      writestring(tmpstr1,fl_testname);
//      writestring(tmpstr1,mid(tmpstr1,2,(len(tmpstr1)-6)));
//      
//      TestOpen(fl_testname);
//      
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//      
//      if(tistdscreenprint)  
//         PrintHeaderParam(GL_PLELL_FORMAT);
//
//      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//      {
//         logsites = v_dev_active;
//         rtest_results = V_dev_active;
//
//         testnum = start_testnum+(bankcount<<4);
//
//         F021_TurnOff_AllTpads;
//         F021_Set_TPADS(tcrnum,tcrmode);
//         F021_RunTestNumber_PMEX(testnum,maxtime,rtest_results);
//         TIME.Wait(tdelay);
//
//         for (tpnum = tpstart;tpnum <= tpstop;tpnum++)
//         {
//            if(PUMP_BANK_PARA_ENABLE[TCRnum][TCRmode][tpnum])  
//            {
//               switch(tpnum) {
//                 case 1 :  
//                        testpad = FLTP1;
//                        llim = TCR.TP1_LLim[TCRnum][TCRMode];
//                        ulim = TCR.TP1_ULim[TCRnum][TCRMode];
//                      break; 
//                 case 2 :  
//                        testpad = FLTP2;
//                        llim = TCR.TP2_LLim[TCRnum][TCRMode];
//                        ulim = TCR.TP2_ULim[TCRnum][TCRMode];
//                      break; 
//#if $TP3_TO_TP5_PRESENT  
//                 case 3 :  
//                        testpad = FLTP3;
//                        llim = TCR.TP3_LLim[TCRnum][TCRMode];
//                        ulim = TCR.TP3_ULim[TCRnum][TCRMode];
//                      break; 
//                 case 4 :  
//                        testpad = FLTP4;
//                        llim = TCR.TP4_LLim[TCRnum][TCRMode];
//                        ulim = TCR.TP4_ULim[TCRnum][TCRMode];
//                      break; 
//                 case 5 :  
//                        testpad = FLTP5;
//                        llim = TCR.TP5_LLim[TCRnum][TCRMode];
//                        ulim = TCR.TP5_ULim[TCRnum][TCRMode];
//                      break; 
//#endif
//#if $TADC_PRESENT  
//                 case 6 :  
//                        testpad = P_TADC;
//                        llim = TCR.TADC_LLim[TCRnum][TCRMode];
//                        ulim = TCR.TADC_ULim[TCRnum][TCRMode];
//                      break; 
//#endif
//               }   /*case tpnum*/
//
//                /*emulation bank has different limits*/
//               if((special_opt==EV_EMU_OPT) and F021_Flash.EMUBANK[bankcount])  
//               {
//                  llim = Bank_Iref_Evfy_LLim_EMU;
//                  ulim = Bank_Iref_Evfy_ULim_EMU;
//               } 
//            
//               discard(F021_Meas_TPAD_PMEX(testpad,tcrnum,tcrmode,
//                       llim,ulim,meas_value,tmp_results));
//
//               ArrayAndBoolean(tmp_results,tmp_results,rtest_results,v_sites);
//
//                /*store/copy to global var*/
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                     BANK_PARA_VALUE[bankcount][tcrnum][tcrmode][tpnum][prepost][vcorner][site] = meas_value[site];
//
//                /*log to TW*/
//               writestring(tmpstr2,bankcount:1);
//               tmpstr2 = "_B" + tmpstr2;  /*_B#*/
//               if(tpstart==tpstop)  
//                  tmpstr3 = tmpstr1 + tmpstr2;
//               else
//                  tmpstr3 = BANK_PARA_TWSTR[TCRnum][TCRMode][tpnum][prepost][vcorner] + tmpstr2;
//               
//               TWTRealToRealMS(meas_value,realval,unitval);
//               TWPDLDataLogRealVariable(tmpstr3,unitval,realval,TWMinimumData);
//
//               if(tistdscreenprint)  
//                  PrintResultParam(tmpstr3,testnum,tmp_results,llim,ulim,meas_value,GL_PLELL_FORMAT);
//            
//               if((prepost==post) and (PUMP_BANK_PARA_BINOUT[tcrnum][tcrmode][tpnum]))  
//               {
//                  ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//                  binout_ena = true;
//               
//                  if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//                  {
//                     F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
//                     if(TI_FlashCOFEna)  
//                        F021_Update_COF_Inst_Str(tmpstr3,site_cof_inst_str,tmp_results);
//                  } 
//                  
//                  if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//                     Devsetholdstates(final_results);
//               } 
//               
//               if(not v_any_dev_active)  
//                  break;
//            }   /*if PUMP_BANK_PARA_ENABLE*/
//
//            if(not v_any_dev_active)  
//               break;
//         }   /*for tpnum*/
//
//         Disable(s_pmexit);
//
//         Check_RAM_TNUM(testnum,tmp_results);
//         if(binout_ena)  
//            ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);            
//
//      }   /*for bankcount*/
//
//       /*restore all active sites*/
//      Devsetholdstates(savesites);
//
//      Disable(s_pmexit);
//      F021_TurnOff_AllTpads;
//
//      ResultsRecordActive(final_results, S_NULL);
//      TestClose;
//               
//      if(TI_FlashCOFEna)  
//         F021_Save_COF_Info("",site_cof_inst_str,final_results);
//      
//      ttimer1 = timernread(ttimer1);
//      tt_timer = ttimer1;
//      
//      tmpstr4 = tmpstr1 + "_TT";
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//      
//      if(tistdscreenprint)  
//      {
//         cout << "   TT " << ttimer1 << endl;
//         cout << endl;
//      } 
//      
//      if((prepost==post) and binout_ena)  
//         if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//            DevSetHoldStates(final_results);
//
//      test_results = final_results;
//   }   /*if v_any_dev_active and parmena*/
//   
//   F021_Bank_Para_func = V_any_dev_active;
//}   /* F021_Bank_Para_func */
//   
//
//BoolS F021_Bank_Para_MBox_func(    IntS start_testnum,
//                                      prepostcorner prepost_type,
//                                      VCornerType vcorner,
//                                      IntS TCRnum,
//                                      TPModeType TCRMode,
//                                      BoolM test_results)
//{
//   const IntS TCR_IPROG_DRV = 69; 
//   const IntS TCR_ISAMP_LOAD = 70; 
//   const IntS TCR_ISAMP_NLOAD = 71; 
//
//   FloatS tdelay,maxtime;
//   BoolM savesites,logsites,rtest_results;
//   BoolM tmp_results,final_results;
//   IntS site,bankcount;
//   IntS pattype,testnum;
//   IntS tpnum,tpstart,tpstop,tpcount;
//   FloatS ttimer1,ttimer2;
//   FloatM tt_timer;
//   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
//   StringS str1,str2,str3,str4;
//   FloatM FloatSval;
//   TWunit unitval;
//   StringS fl_testname;
//   prepostcorner prepost;
//   BoolS parmena,done,once,ovride_lim;
//   FloatS ovride_llim,ovride_ulim;
//   FloatS llim,ulim,tmpFloatS;
//   PinM testpad,cntrlpad;
//   FloatM meas_value;
//   FloatS tpad_force,cntrlpad_force;
//   BoolS x64soft;
//   StringM site_cof_inst_str;
//   BoolS binout_ena,logall;
//   IntS senampnum,tmpint;
//   IntM min_sampnum,max_sampnum;
//   FloatM min_value,max_value;
//   FloatS FloatSvalsite;
//   IntS loopmin,loopmax;
//
//   parmena = false;
//   binout_ena = false;
//   prepost = prepost_type;
//
//   if(V_any_dev_active)  
//   {
//      tpstart = 0;
//      tpstop  = 0;
//      for (tpnum = GL_TPADMIN;tpnum <= GL_TPADMAX;tpnum++)
//         if(PUMP_BANK_PARA_ENABLE[TCRnum][TCRmode][tpnum])  
//         {
//            if(not parmena)  
//            {
//               fl_testname = PUMP_BANK_PARA_TESTNAME[TCRnum][TCRmode][tpnum][prepost][vcorner];
//               parmena = true;
//            } 
//            if(tpstart==0)  
//               tpstart = tpnum;
//            tpstop = tpnum;
//         } 
//      if(tpstart==0)  
//         tpstop  = -1;
//   } 
//
//   if(v_any_dev_active and parmena)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ F021_Bank_Para_MBox_func +++++" << endl;
//      
//      tdelay  = 10ms;
//      maxtime = GL_F021_PARAM_MAXTIME;
//
//      timernstart(ttimer1);      
//
//      savesites = V_dev_active;
//      tmp_results = V_dev_active;
//      final_results = V_dev_active;
//
//      writestring(tmpstr1,fl_testname);
//      writestring(tmpstr1,mid(tmpstr1,2,(len(tmpstr1)-6)));
//      
//      TestOpen(fl_testname);
//
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//      
//      if(tistdscreenprint)  
//         PrintHeaderParam(GL_PLELL_FORMAT);
//
//      logall = false;
//      switch(tcrnum) {
//        case TCR_IPROG_DRV   : logall = GL_DO_TWLOGALL_IPROG_DRV;
//        case TCR_ISAMP_LOAD  : logall = GL_DO_TWLOGALL_ISA_LD;
//        case TCR_ISAMP_NLOAD : logall = GL_DO_TWLOGALL_ISA_NLD;
//      }   /* case */
//
//#if $FL_USE_AUTO_FLOW  
//      loopmin = 0;
//      loopmax = (F021_Flash.DATAWIDTH-1);
//#else
//      loopmin = 0;
//      loopmax = loopmin;
//#endif
//      
//      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//      {
//         logsites = v_dev_active;
//         rtest_results = V_dev_active;
//
//         min_value = 0uA;
//         max_value = 0uA;
//         min_sampnum = 0;
//         max_sampnum = 0;
//         once = false;
//
//         testnum = start_testnum+(bankcount<<4);
//
//         for (senampnum = loopmin;senampnum <= loopmax;senampnum++)
//         {
//            switch(tcrnum) {
//              case TCR_IPROG_DRV   :  
//                 MBox_Upload_IProg(senampnum);  /*datain mask*/
//               break; 
//              TCR_ISAMP_LOAD,
//              case TCR_ISAMP_NLOAD :  
//                 MBox_Upload_ISenAmp(senampnum);
//               break; 
//              default:  
//                 if(tistdscreenprint)  
//              case cout << "*** WARNING: Invalid TCR number entered !!!" << endl;
//               break; 
//            }   /* case */
//
//            F021_TurnOff_AllTpads;
//            F021_Set_TPADS(tcrnum,tcrmode);
//            F021_RunTestNumber_PMEX(testnum,maxtime,rtest_results);
//            TIME.Wait(tdelay);
//            
//            for (tpnum = tpstart;tpnum <= tpstop;tpnum++)
//            {
//               if(PUMP_BANK_PARA_ENABLE[TCRnum][TCRmode][tpnum])  
//               {
//                  switch(tpnum) {
//                    case 1 :  
//                           testpad = FLTP1;
//                           llim = TCR.TP1_LLim[TCRnum][TCRMode];
//                           ulim = TCR.TP1_ULim[TCRnum][TCRMode];
//                         break; 
//                    case 2 :  
//                           testpad = FLTP2;
//                           llim = TCR.TP2_LLim[TCRnum][TCRMode];
//                           ulim = TCR.TP2_ULim[TCRnum][TCRMode];
//                         break; 
//#if $TP3_TO_TP5_PRESENT  
//                    case 3 :  
//                           testpad = FLTP3;
//                           llim = TCR.TP3_LLim[TCRnum][TCRMode];
//                           ulim = TCR.TP3_ULim[TCRnum][TCRMode];
//                         break; 
//                    case 4 :  
//                           testpad = FLTP4;
//                           llim = TCR.TP4_LLim[TCRnum][TCRMode];
//                           ulim = TCR.TP4_ULim[TCRnum][TCRMode];
//                         break; 
//                    case 5 :  
//                           testpad = FLTP5;
//                           llim = TCR.TP5_LLim[TCRnum][TCRMode];
//                           ulim = TCR.TP5_ULim[TCRnum][TCRMode];
//                         break; 
//#endif
//#if $TADC_PRESENT  
//                    case 6 :  
//                           testpad = P_TADC;
//                           llim = TCR.TADC_LLim[TCRnum][TCRMode];
//                           ulim = TCR.TADC_ULim[TCRnum][TCRMode];
//                         break; 
//#endif
//                  }   /*case tpnum*/
//            
//                  discard(F021_Meas_TPAD_PMEX(testpad,tcrnum,tcrmode,
//                          llim,ulim,meas_value,tmp_results));
//                  
//                  ArrayAndBoolean(tmp_results,tmp_results,rtest_results,v_sites);
//
//                   /*store min/max meas_value and respective senampnumber*/
//                  if(not once)  
//                  {
//                     for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                        if(v_dev_active[site])  
//                        {
//                           min_value[site] = meas_value[site];
//                           max_value[site] = meas_value[site];
//                           min_sampnum[site] = senampnum;
//                           max_sampnum[site] = senampnum;
//                        } 
//                     once = true;
//                  }
//                  else
//                  {
//                     for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                        if(v_dev_active[site])  
//                        {
//                           if(min_value[site]>meas_value[site])  
//                           {
//                              min_value[site] = meas_value[site];
//                              min_sampnum[site] = senampnum;
//                           } 
//                           if(max_value[site]<meas_value[site])  
//                           {
//                              max_value[site] = meas_value[site];
//                              max_sampnum[site] = senampnum;
//                           } 
//                        } 
//                  } 
//                           
//                   /*log to TW*/
//                  writestring(tmpstr2,bankcount:1);
//                  tmpstr2 = "_B" + tmpstr2;  /*_B#*/
//                  if(tpstart==tpstop)  
//                     tmpstr3 = tmpstr1 + tmpstr2;
//                  else
//                     tmpstr3 = BANK_PARA_TWSTR[TCRnum][TCRMode][tpnum][prepost][vcorner] + tmpstr2;
//                  writestring(tmpstr2,senampnum:1);
//                  tmpstr2 = "_SA" + tmpstr2;
//                  tmpstr3 = tmpstr3 + tmpstr2;
//
//                  if(logall)  
//                  {
//                     TWTRealToRealMS(meas_value,realval,unitval);
//                     TWPDLDataLogRealVariable(tmpstr3,unitval,realval,TWMinimumData);
//                  } 
//                  
//                  if(tistdscreenprint)  
//                     PrintResultParam(tmpstr3,testnum,tmp_results,llim,ulim,meas_value,GL_PLELL_FORMAT);
//                  
//                  if((prepost==post) and (PUMP_BANK_PARA_BINOUT[tcrnum][tcrmode][tpnum]))  
//                  {
//                     ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//                     binout_ena = true;
//                     
//                     if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//                     {
//                        F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
//                        if(TI_FlashCOFEna)  
//                           F021_Update_COF_Inst_Str(tmpstr3,site_cof_inst_str,tmp_results);
//
//                         /*tw log min/max on failing site*/
//                        if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//                        {
//                           writestring(str2,bankcount:1);
//                           str1 = tmpstr1 + "_B";
//                           str1 = str1 + str2;
//                           for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                              if(v_dev_active[site] and (not tmp_results[site]))  
//                              {
//                                 str3 = str1 + "_SAMIN";
//                                 tmpint = min_sampnum[site];
//                                 TWPDLDatalogVariableSite(str3,tmpint,site,TWMinimumData);
//                                 str3 = str1 + "_MIN";
//                                 tmptreal = min_value[site];
//                                 TWTRealToReal(tmptreal,realvalsite,unitval);
//                                 TWPDLDatalogRealVariableSite(str3,unitval,realvalsite,site,TWMinimumData);
//                                 str3 = str1 + "_SAMAX";
//                                 tmpint = max_sampnum[site];
//                                 TWPDLDatalogVariableSite(str3,tmpint,site,TWMinimumData);
//                                 str3 = str1 + "_MAX";
//                                 tmptreal = max_value[site];
//                                 TWTRealToReal(tmptreal,realvalsite,unitval);
//                                 TWPDLDatalogRealVariableSite(str3,unitval,realvalsite,site,TWMinimumData);
//                              }   /*v_dev_active*/
//                        }   /*if not tiignorefail/ti_flashcofena*/
//                     }   /*if not arraycompare*/
//                     
//                     if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//                        Devsetholdstates(final_results);
//                  } 
//                  
//                  if(not v_any_dev_active)  
//                     break;
//               }   /*if PUMP_BANK_PARA_ENABLE*/
//               
//               if(not v_any_dev_active)  
//                  break;
//            }   /*for tpnum*/
//
//            Disable(s_pmexit);
//
//             /*uncomment out if wanna debug...
//             for site := 1 to v_sites do
//                if(v_dev_active[site] and (not tmp_results[site])) then
//                begin
//                   readramaddress(site,0,0xff);
//                   tmpint := ADDR_RAM_MAILBOX;
//                   readramaddress(site,tmpint,tmpint+(10*ADDR_RAM_INC));
//                end;*/
//            
//            Check_RAM_TNUM(testnum,tmp_results);
//            if(binout_ena)  
//               ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//
//         }   /*for senampnum*/
//
//          /*tw log min/max*/
//         if(v_any_dev_active)  
//         {
//            writestring(str2,bankcount:1);
//            str1 = tmpstr1 + "_B";
//            str1 = str1 + str2;
//            
//            str3 = str1 + "_SAMIN";
//            TWPDLDataLogVariable(str3,min_sampnum,TWMinimumData);
//            str3 = str1 + "_MIN";
//            TWTRealToRealMS(min_value,realval,unitval);
//            TWPDLDataLogRealVariable(str3,unitval,realval,TWMinimumData);
//            
//            str3 = str1 + "_SAMAX";
//            TWPDLDataLogVariable(str3,max_sampnum,TWMinimumData);
//            str3 = str1 + "_MAX";
//            TWTRealToRealMS(max_value,realval,unitval);
//            TWPDLDataLogRealVariable(str3,unitval,realval,TWMinimumData);
//         } 
//         
//      }   /*for bankcount*/
//
//       /*restore all active sites*/
//      Devsetholdstates(savesites);
//
//      Disable(s_pmexit);
//      F021_TurnOff_AllTpads;  /*F021_UnSet_TPADS(tcrnum);*/
//
//      ResultsRecordActive(final_results, S_NULL);
//      TestClose;
//               
//      if(TI_FlashCOFEna)  
//         F021_Save_COF_Info("",site_cof_inst_str,final_results);
//
//      ttimer1 = timernread(ttimer1);
//      tt_timer = ttimer1;
//      
//      tmpstr4 = tmpstr1 + "_TT";
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//      
//      if(tistdscreenprint)  
//      {
//         cout << "   TT " << ttimer1 << endl;
//         cout << endl;
//      } 
//      
//      if((prepost==post) and binout_ena)  
//         if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//            DevSetHoldStates(final_results);
//
//      test_results = final_results;
//   }   /*if v_any_dev_active and parmena*/
//   
//   F021_Bank_Para_MBox_func = V_any_dev_active;
//}   /* F021_Bank_Para_MBox_func */
//   
//
TMResultM Bool2TMRes ( BoolM TransThis )
{
   TMResultM Trans(TM_NOTEST);
   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
   {
       if(TransThis[*si]=true)  
           Trans[*si] = TM_PASS;
       else
          Trans[*si] = TM_FAIL;
   } 
   return Trans;
}
TMResultM F021_Flash_Leak_func(    IntS start_testnum,
                                  StringS tname,
                                  prepostcorner prepost_type,
                                  VCornerType vcorner,
                                  IntS TCRnum,
                                  TPModeType TCRMode)
//taken care of by return TMResultM   BoolM test_results)
{
   FloatS tdelay,maxtime;
   Sites new_active_sites,savesites,retestsites;
   BoolM logsites;
   TMResultM tm_results;
   BoolM tmp_results,final_results,rtest_results;
   IntS count,maxsector,tpnum;
   IntS bankcount,bankstart,bankstop;
   IntS blkcount,blkstart,blkstop;
   IntS site,pattype,testnum,length;
   FloatS ttimer1,ttimer2;
   FloatM tt_timer;
   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
   FloatM FloatSval;
//   TWunit unitval;
   StringS fl_testname;
   PinM testpad,cntrlpad;
   FloatS Llim,Ulim,Ulim_retest;
   FloatM meas_value,total_value;
   BoolS x64soft;
   StringM site_cof_inst_str;
   prepostcorner prepost;
   FloatM delta_val;
   FloatS delta_Ulimit;
   BoolS rampena,binout_ena,debugprint;
   FloatS rampstart,rampstop,iProg;
//don't need this for ramp_tpads.  it's not used in that function anyhow.
//   option pgmMode;
   IntS special_opt;
   TPModeType tmptcrmode;
   VCornerType tmpvcorner;
   BoolM disallsites;
   BoolS retest_ena;

   savesites = ActiveSites;
   new_active_sites = ActiveSites;
   retestsites=new_active_sites;
   
//   if(V_any_dev_active)  
   if (ActiveSites.GetPassingSites().AnyEqual(true))
   {
      if(tistdscreenprint and TI_FlashDebug)  
         cout << "+++++ F021_Flash_Leak_func +++++" << endl;

      tdelay  = 2ms;
      maxtime = GL_F021_PARAM_MAXTIME;  /*10ms;*/

      prepost = prepost_type;

      fl_testname = tname;
//writestring is a vlct function.
//      writestring(tmpstr1,fl_testname);
//      length = len(tmpstr1);
//      writestring(tmpstr1,mid(tmpstr1,2,length-6));
      tmpstr1 = tmpstr1.Substring(2,tmpstr1.Length()-6);

//No testopen in Unison
//      TestOpen(fl_testname);

//      timernstart(ttimer1);      
      TIME.StartTimer();

//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
      site_cof_inst_str="";
      
//      savesites = V_dev_active;
//      tmp_results = V_dev_active;
      final_results = TM_NOTEST;
//      final_results = V_dev_active;
      tmp_results = final_results;  

      binout_ena = false;
      rampena = false;
      retest_ena = false;

      //***** Begin Switch statement code *****
      if ((TCRnum>=7) | (TCRnum<=12))
         special_opt = 1;
      else if ((TCRnum==13) | (TCRnum>=15) | (TCRnum<=17))
      {
         special_opt = 3;
         if(TCRnum!=13)  
         {   
//            retestsites = GL_FLASH_RETEST; //BoolM GL_FLASH_RETEST
//            arrayandboolean(retestsites,retestsites,v_dev_active,v_sites);
            retestsites.DisableFailingSites(!GL_FLASH_RETEST); //disable sites that are not set to retest
            
//vlct function arraycompareboolean looks at v_sites elements of retestsites and disallsites & compares
//them element by element.  If all elements are the same, true is returned.  Otherwise false.  So this
//if boolean returns !true if there are all retestsites are false and !false if some retestsites are true.
//In other words, if there is at least one retest site, then do the retest_ena and ulim_retest assignment
//            disallsites = false;
//            if(not arraycompareboolean(retestsites,disallsites,v_sites))  
            if(SetActiveSites(retestsites))
            {   
               retest_ena = true;
               Ulim_retest = BLS_VBL_LEAK_Prog_ULim_Retest;
            }
         }
      }
      else if ((TCRnum==23) | (TCRnum==24))
         special_opt = 3;
      else
         special_opt = 0;
      //***** End Switch statement code *****

//switch doesn't work and anyhow this translation is jacked up
//      switch(TCRnum) {
//        case 7..12     : special_opt = 1;
//        case  13: case 15..17 : 
//         
//           special_opt = 3;
//           if(tcrnum!=13)  
//            
//              retestsites = GL_FLASH_RETEST;
//              arrayandboolean(retestsites,retestsites,v_dev_active,v_sites);
//              disallsites = false;
//              if(not arraycompareboolean(retestsites,disallsites,v_sites))  
//               
//                 retest_ena = true;
//                 ulim_retest = BLS_VBL_LEAK_Prog_ULim_Retest;
//               break; 
//            break; 
//         break; 
//        case  23: case 24 :  special_opt = 2;
//        default: special_opt = 0;
//      }   /* case */
      
      if((TCRnum==13))  
      {
         tpnum     = 2;
         testpad   = FLTP2;
         Llim      = TCR.TP2_LLim[TCRnum][TCRMode];
         Ulim      = TCR.TP2_ULim[TCRnum][TCRMode];
         rampstart = TCR.TP2_VCharLo[TCRnum][TCRMode];
         rampstop  = TCR.TP2_VCharHi[TCRnum][TCRMode];
         iProg     = 1.2*TCR.TP2_IRange[TCRnum][TCRMode];
// This is only sent to testpad ramp code, which doesn't use it.  Thus, commented out.
//         pgmMode   = S_VI_Mode;
      }
      else
      {
         tpnum     = 1;
         testpad   = FLTP1;
         Llim      = TCR.TP1_LLim[TCRnum][TCRMode];
         Ulim      = TCR.TP1_ULim[TCRnum][TCRMode];
         rampstart = TCR.TP1_VCharLo[TCRnum][TCRMode];
         rampstop  = TCR.TP1_VCharHi[TCRnum][TCRMode];
         iProg     = 1.2*TCR.TP1_IRange[TCRnum][TCRMode];
// This is only sent to testpad ramp code, which doesn't use it.  Thus, commented out.
//         pgmMode   = S_VI_Mode;
      } 
      //***** Begin Switch statement code *****
      if (((TCRnum>=7)&(TCRnum<=9))|(TCRnum==13)|((TCRnum>=15)&(TCRnum<=17))|(TCRnum==23)|((TCRnum>=58)&(TCRnum<=60)))
         pattype = BANKTYPE;
      else if (((TCRnum>=10)&(TCRnum<=12))|(TCRnum==14)|((TCRnum>=20)&(TCRnum<=22))|(TCRnum==24)|(TCRnum==37)|((TCRnum>=61)&(TCRnum<=63)))
         pattype = BLOCKTYPE;
      else pattype = SECTTYPE;
      //***** End Switch statement code *****
     
//      switch(TCRnum) {
//        7..9,      /*bank CG stress vhv*/
//        13,        /*bank EG/SL stress vsl*/
//        15..17,    /*bank BL all/even/odd stress vinh*/
//        23,        /*bank erase EG stress vhv ers eg*/
//        case 58..60 :   /*bank WL all/odd/even stress vread*/
//         
//           pattype = BANKTYPE;
//         break; 
//        
//        10..12,    /*block CG stress vhv*/
//        14,        /*block EG/SL stress vsl*/
//        20..22,    /*block BL all/even/odd stress vinh*/
//        24,        /*block erase EG stress vhv ers eg*/
//        37,        /*block BL stress selective vinh*/
//        case 61..63 :   /*block WL all/odd/even stress vread*/
//         
//           pattype = BLOCKTYPE;
//         break; 
//        
//        default:
//        
//           pattype = SECTTYPE;  /*dummy - use for tp1/tp2 pin lkg*/
//         break; 
//      }   /* case */
 
      
      if(tistdscreenprint)  
         PrintHeaderParam(GL_PLELL_FORMAT);
      
              
      if(pattype == MODTYPE)  
      {
          /*+++ Module operation +++*/
         final_results = false;
         if(tistdscreenprint)  
            cout << "+++ WARNING : Invalid Test Number Entered +++" << endl;
      }
      else
      {
         for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
         {
            if(pattype==BANKTYPE)  
            {
               blkstart = bankcount;
               blkstop  = bankcount;
            }
            else if(pattype==BLOCKTYPE)  
            {
               blkstart = 0;
               blkstop  = F021_Flash.MAXBLOCK[bankcount];
            }
            else
            {
               blkstart = 0;
               blkstop  = F021_Flash.MAXSECT[bankcount];
            } 

            testnum  = start_testnum+(bankcount<<4);

            for (count = blkstart;count <= blkstop;count++)
            {
               logsites = ActiveSites.GetPassingSites();
               rtest_results = logsites;
//               timernstart(ttimer2);
               ttimer2 = TIME.GetTimer();
               
               if(special_opt==3)  
                  F021_Set_TPADS(TCRnum,TCRMode);
               
               tm_results=F021_RunTestNumber_PMEX(testnum,maxtime);
               if (tm_results == TM_PASS) 
                  rtest_results = true; 
               else 
                  rtest_results = false;
               
               if(special_opt!=3)  
                  F021_Set_TPADS(TCRnum,TCRMode);
               
               TIME.Wait(tdelay);

//               discard(F021_Meas_TPAD_PMEX(testpad,TCRnum,TCRMode,
//                       Llim,Ulim,meas_value,tmp_results));
               meas_value = F021_Meas_TPAD_PMEX(testpad,TCRnum,TCRMode);

               if((special_opt>0) and (special_opt<3))  
               {
                  total_value = meas_value;
                  
                  if(special_opt==1)     /*cg lkg*/
                     tmptcrmode = CvfyMode;
                  else if(special_opt==2)    /*eg lkg*/
                     tmptcrmode = EvfyMode;

/*                  switch(vcorner) {
                    case  VMN: case VMNO: case VMNE :  tmpvcorner = VMN;
                    case  VNM: case VNMO: case VNME :  tmpvcorner = VNM;
                    case  VMX: case VMXO: case VMXE :  tmpvcorner = VMX;
                  } */  /* case */

                  debugprint = false;
//Unison is sited.  Don't need an iterator for this.
//                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                     if(v_dev_active[site])  
//                     {
                        if(special_opt==1)  
                           meas_value = meas_value-PUMP_LEAK_VALUE[tmptcrmode][tmpvcorner];
                        else
                           meas_value = PUMP_LEAK_VALUE[tmptcrmode][tmpvcorner]-meas_value;
                           
                        if((meas_value>=Llim) and (meas_value<=Ulim))  
                           tmp_results = true;
                        else
                           tmp_results = false;
                     for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
                     {
                        if(debugprint and tistdscreenprint)  
                        {
                           //cout << "Site " << site:-5 << " Total Meas==" << total_value[si]:-5:3 << endl;
                           IO.Flush(IO.Stdout);
                        }
                     } 
/*                   if(specail_opt==1)
                      meas_valu = meas_value-PUMP_LEAK_VALUE[tmptcrmode][tmpvcorner][site];
                   else
                      meas_value[site] = PUMP_LEAK_VALUE[tmptcrmode][tmpvcorner][site]-meas_value[site];
                      
                   if(meas_value[site]>=Llim) and (meas_value[site]<=Ulim))
                      tmp_results=true;
                   else
                      tmp_results=false;
                      
                   if(debugprint and tistdscreenprint)
                      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
                      {
                         cout<<"Site "<<setw(-5)<<si<<" Total Meas="<<setw(-5)<<setprecision(3)<<total_value[si]<<endl;
                      }
              */ }
               else if((special_opt==3) and (TCRnum!=13) and retest_ena)  
               {
//Unison is sited.  Don't need a site iterator for this
//                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                     if(v_dev_active[site] and retestsites[site])  
//                        if((meas_value[site]>==llim) and (meas_value[site]<==ulim_retest))  
//                        {
//                           tmp_results[site] = true;
//                              cout << "Site" << site:-5 << "retested w/ limits " << llim << "  " << ulim_retest << endl;
//                        } 
                  tmp_results = ((meas_value>=Llim) & (meas_value<=Ulim_retest));
                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
                     cout<<"Site"<<setw(-5)<<si<<"retested w/ limits"<<Llim<<"  "<<Ulim_retest<<endl;
               }   /*if special_opt*/

//               ArrayAndBoolean(tmp_results,tmp_results,rtest_results,v_sites);
                 tmp_results=tmp_results&rtest_results;
                 if(pattype==BANKTYPE)  
                 {
//  Unison is sited.  Don't need a site iterator here.
//                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                     if(v_dev_active[site])  
//                        BANK_PARA_VALUE[bankcount][tcrnum][tcrmode][tpnum][prepost][vcorner] = meas_value;
//This array isn't really used for too much.  Comment out for now
//                  BANK_PARA_VALUE[bankcount][TCRnum][TCRMode][tpnum][prepost][vcorner] = meas_value;
//               }
//               else
//               {
//  Unison is sited.  Don't need a site iterator here.
//                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                     if(v_dev_active[site])  
//This array isn't really used for too much.  Comment out for now
//                        BLOCK_PARA_VALUE[bankcount][count][tcrnum][tcrmode][tpnum][prepost][vcorner] = meas_value;
//This array isn't really used for too much.  Comment out for now
//                  BLOCK_PARA_VALUE[bankcount][count][TCRnum][TCRMode][tpnum][prepost][vcorner] = meas_value;
              } 

               ttimer1 = TIME.StopTimer();
               tt_timer = ttimer1;
               
                /*log to TW*/
//               writestring(tmpstr2,bankcount:1);
               if (bankcount==0) tmpstr2 = "0";
               else tmpstr2 = CONV.IntToString(bankcount);
               tmpstr2 = "_B" + tmpstr2;  /*_B#*/
               if(pattype!=BANKTYPE)  
               {
//                  writestring(tmpstr3,count:1);
                  if (count==0) tmpstr3 = "0";
                  else tmpstr3 = CONV.IntToString(count);                  
                  if(pattype==BLOCKTYPE)  
                     tmpstr3 = "BLK" + tmpstr3;
                  else
                     tmpstr3 = "S" + tmpstr3;
                  tmpstr2 = tmpstr2 + tmpstr3;
               } 
               tmpstr3 = tmpstr1 + tmpstr2;  /*now has xx_B#*/
               tmpstr4 = tmpstr3 + "_TT";
//               TWTRealToRealMS(tt_timer,realval,unitval);
               TWPDLDataLogRealVariable(tmpstr4, tt_timer.GetUnits(),tt_timer,TWMinimumData);
               
               tmpstr4 = tmpstr3;
//               TWTRealToRealMS(meas_value,realval,unitval);
               TWPDLDataLogRealVariable(tmpstr4, meas_value.GetUnits(),meas_value,TWMinimumData);

               if(special_opt!=0)  
               {
                  tmpstr4 = tmpstr4 + "_WPUMP";
//                  TWTRealToRealMS(total_value,realval,unitval);
                  TWPDLDataLogRealVariable(tmpstr4, total_value.GetUnits(),total_value,TWMinimumData);
               } 
               
//               if(tistdscreenprint)  
//                  PrintResultParam(tmpstr3,testnum,tmp_results,Llim,Ulim,meas_value,GL_PLELL_FORMAT);
               
               if((prepost==post) and (PUMP_BANK_PARA_BINOUT[TCRnum][TCRMode][tpnum]))  
               {
//                  ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
                  final_results = final_results & tmp_results;
                  binout_ena = true;
                  
                   /*log failed test to tw*/
/*                  if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
                  {
                     F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
                     
                     if(TI_FlashCOFEna)  
                        F021_Update_COF_Inst_Str(tmpstr2,site_cof_inst_str,tmp_results);
                  } */
               } 

               if(rampena)  
//                  F021_Ramp_TPAD(testpad,rampstop,rampstart,iProg,pgmMode);
                  F021_Ramp_TPAD(testpad,rampstop,rampstart,iProg);

               F021_TurnOff_AllTPADS();
               TIME.Wait(tdelay);
//               Disable(s_pmexit);

//               Check_RAM_TNUM(testnum,tmp_results);
               if(binout_ena)  
//                  ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
                  final_results = final_results & tmp_results;
//               F021_RunTestNumber(TNUM_ALWAYS_PASS,1s,spare_mstreal1,spare_msbool1);
               
               testnum = testnum+1;  /*increment blk#*/
               
//               if((not TIIgnoreFail) and (not TI_FlashCOFEna) and
//                  ((prepost==post) and (PUMP_BANK_PARA_BINOUT[tcrnum][tcrmode][tpnum])))  
//                  Devsetholdstates(final_results);
               
//               if(not v_any_dev_active) 
               if(!(ActiveSites.GetPassingSites().AnyEqual(true))) 
                  break;
            }   /*for count*/
//            if(not v_any_dev_active)  
            if(!(ActiveSites.GetPassingSites().AnyEqual(true))) 
               break;
         }   /*for bankcount*/
      }    /*+++ End of Bank operation +++*/

       /*restore all active sites*/
//      Devsetholdstates(savesites);

//      ResultsRecordActive(final_results, S_NULL);
//      TestClose;

//      test_results = final_results;
      
//      if(TI_FlashCOFEna)  
//         F021_Save_COF_Info(tmpstr1,site_cof_inst_str,final_results);
      
//      ttimer1 = timernread(ttimer1);
       ttimer1 = TIME.GetTimer();
      tt_timer = ttimer1;

      tmpstr4 = tmpstr1 + "_TTT";
//      TWTRealToRealMS(tt_timer,realval,unitval); //do not need to move tt_timer to realval in Unison
      TWPDLDataLogRealVariable(tmpstr4, tt_timer.GetUnits(),tt_timer,TWMinimumData);

      if(tistdscreenprint)  
      {
         cout << endl;
         cout << endl;
/*         if(pattype==MODTYPE)  
            cout << "MODULE LEAKAGE START TEST NUMBER " << 
                  start_testnum:s_hex:10 << "  : ")
         else
            cout << "BANK/BLOCK LEAKAGE START TEST NUMBER " << 
                  start_testnum:s_hex:10 << "  : ";
         cout << "   TT " << ttimer1 << endl;
         cout << endl;
      */}         /*if tistdscreenprint*/

      F021_TurnOff_AllTPADS();

 //     if(prepost == post)  
//         if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//            DevSetHoldStates(final_results);
//            
   } /*if v_any_dev_active*/

//   F021_Flash_Leak_func = V_any_dev_active;
   return(Bool2TMRes ( final_results ));
}   /* F021_Flash_Leak_func */

   
TMResultM F021_Stress_func(IntS start_testnum, StringS tname, IntS TCRnum, TPModeType TCRMode) { 

   FloatS tdelay,maxtime,stresstime;
   BoolM savesites,logsites,activesites;
   IntS count,maxsector,tpnum;
   IntS bankcount,bankstart,bankstop;
   IntS blkcount,blkstart,blkstop;
   TMResultM tmp_results, test_results;
   TMResultM rtest_results, final_results;
   BoolM allfalse;
   IntS site,pattype,testnum,length;
   IntS opertype;
   FloatS ttimer1,ttimer2;
   FloatM tt_timer;
   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
   FloatM FloatSval;
   StringS unitval;
   StringS fl_testname;
   IntS shifbit;
   PinM testpad;
   FloatS vstress;
   StringM site_cof_inst_str;
   IntS target_bits,stress_bits;
   IntS special_opt;
   FloatS rampstart,rampstop;
   FloatS iProg,vdds_iProg,vdds_vProg;
//   Option pgmMode,vdds_pgmMode,vdds_iGMode;
   BoolS supena,rampup,ramp3vfl;
   FloatS vRange,vProg;

   if(tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ F021_Stress_func +++++" << endl;

   rampup = true;

   switch (TCRnum) {
     case 23  : special_opt = 1;
     case 52  : special_opt = 3;
     case 58  : special_opt = 2;
     case 86  : special_opt = 5;   // vhv stress
     case 128 : special_opt = 4;   // external ers using tcr23
     default  : special_opt = 0;
   }
             
   if (special_opt!=0) {
      // special case1 -- EGFG stress using bank ers stress tcr23, need ramp tpad
      // special case2 -- read disturb stress using wls tcr58, need ramp tpad & vdds
      testpad     = FLTP1;
//      pgmMode     = S_VI_Mode;
      rampstart   = TCR.TP1_VCharLo[TCRnum][TCRMode];
      rampstop    = TCR.TP1_VCharHi[TCRnum][TCRMode];
      iProg       = TCR.TP1_IRange[TCRnum][TCRMode];
      tdelay      = 10us;

      if (special_opt==2) {
         tmpstr2 = "FL_PUMP_SUPPLY_NAME";
         if(tmpstr2!="VDD3VFL") {
            ramp3vfl = false;
         }
         else {
            ramp3vfl = true;
//            STDGetVI(FL_PUMP_SUPPLY_NAME,vdds_vProg,vdds_iProg);
         } 
      }   // special_opt=2
   }   // if special_opt

   tmpstr1 = tname;
   tname.Replace(tname.Find("_Test"), 5, "");   // remove _Test
   fl_testname = tname;
   
   TIME.StartTimer();     

//   if (TI_FlashCOFEna)  
//      F021_Init_COF_Inst_Str(site_cof_inst_str);

//   savesites = V_dev_active;
//   tmp_results = V_dev_active;
//   final_results = V_dev_active;

   testnum = start_testnum;
   target_bits = (testnum & 0x00000f00) >>8;
   stress_bits = (testnum & 0x00f00000) >>20;

   switch(target_bits) {
     case TARGET_BANK : pattype = BANKTYPE;
     case TARGET_SECT : pattype = SECTTYPE;
     case TARGET_OTP  : pattype = OTPTYPE;
     default:     pattype = MODTYPE;
   } 

   stresstime = 0s;
   
   for (tpnum = GL_TPADMIN; tpnum <= GL_TPADMAX; tpnum++) {
      supena = false;
      switch (tpnum) {
        case 1 :  
           if (TCR.TP1_Ena[TCRnum])  
              vstress = TCR.TP1_VRange[TCRnum][TCRMode];
           tmpstr3 = "TP1";
           if (stresstime==0s)  
              stresstime = TCR.TP1_FTime[TCRnum][TCRMode];
           supena = true;
           break; 
        case 2 :  
           if (TCR.TP2_Ena[TCRnum])  
              vstress = TCR.TP2_VRange[TCRnum][TCRMode];
              tmpstr3 = "TP2";
              if (stresstime==0s)  
                 stresstime = TCR.TP2_FTime[TCRnum][TCRMode];
              supena = true;
              break; 
#if $TP3_TO_TP5_PRESENT  
        case 3 :  
           if (TCR.TP3_Ena[TCRnum])  
              vstress = TCR.TP3_VRange[TCRnum][TCRMode];
           tmpstr3 = "TP3";
           if (stresstime==0s)  
              stresstime = TCR.TP3_FTime[TCRnum][TCRMode];
           supena = true;
           break; 
        case 4 :  
           if (TCR.TP4_Ena[TCRnum])       
              vstress = TCR.TP4_VRange[TCRnum][TCRMode];
           tmpstr3 = "TP4";
           if (stresstime==0s)  
              stresstime = TCR.TP4_FTime[TCRnum][TCRMode];
           supena = true;
           break; 
        case 5 :  
           if (TCR.TP5_Ena[TCRnum])  
              vstress = TCR.TP5_VRange[TCRnum][TCRMode];
           tmpstr3 = "TP5";
           if (stresstime==0s)  
              stresstime = TCR.TP5_FTime[TCRnum][TCRMode];
           supena = true;
           break; 
#endif
      }   // case

      if (tistdscreenprint and supena)  
         cout << setw(4) << tmpstr3 << "== " << vstress << "  ";
   }   // for tpnum

   if (tistdscreenprint) {
      cout << "Stress Time == " << stresstime << endl;
      cout << endl;
//      PrintHeaderBool(GL_PLELL_FORMAT);
   }   // if tistdscreenprint
      
   if (pattype == MODTYPE) {
      // +++ Module operation +++
      final_results = TM_NOTEST;
      if (tistdscreenprint)  
         cout << "+++ WARNING : Invalid Test Number Entered +++" << endl;
   }
   else {
      // ++++++++ Bank operation ++++++++
      maxtime = GL_F021_PARAM_MAXTIME;

      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++) {
         if ((pattype==BANKTYPE) or (pattype==OTPTYPE)) {
            blkstart = bankcount;
            blkstop  = bankcount;
         }
         else if(pattype==BLOCKTYPE) {
            blkstart = 0;
            blkstop  = F021_Flash.MAXBLOCK[bankcount];
         }
         else {
            blkstart = 0;
            blkstop  = F021_Flash.MAXSECT[bankcount];
         } 

         testnum = start_testnum+(bankcount<<4);

         for (count = blkstart;count <= blkstop;count++) {
//          logsites = v_dev_active;
//          tmp_results = v_dev_active;
//          rtest_results = v_dev_active;
            ttimer2 = TIME.GetTimer();

            F021_TurnOff_AllTPADS();

            if ((special_opt==2) and ramp3vfl) {
//               STDSetVI(FL_PUMP_SUPPLY_NAME,rampstop,vdds_iProg);
               if (tistdscreenprint and TI_FlashDebug) {
                  tmpstr2 = "FL_PUMP_SUPPLY_NAME";
                  cout << "Pump Supply " << tmpstr2 << " @ " << rampstop << endl;
               } 
            } 

            rtest_results = F021_RunTestNumber_PMEX(testnum,maxtime);

            if (special_opt==4) {
               vRange = 15V;
               // KChau 04/21/10 - using 12.5v as default
               vProg = VHV_Ers_Target - 500mV;
//               STDSetVRange(testpad,vRange);
//               STDSetVI(testpad,vProg,iProg);
               TIME.Wait(stresstime);
//               STDSetVI(testpad,0V,iProg);
               if (tistdscreenprint and TI_FlashDebug)  
                  cout << " EG @ " << vProg << endl;
            }
            else if (special_opt==5) {
               F021_Set_TPADS (TCRnum,TCRMode);
               TIME.Wait(stresstime);
            }                  
            else {
               F021_Set_TPADS_ByOrder(TCRnum,TCRMode,rampup);
               TIME.Wait(stresstime);
               F021_Set_TPADS_ByOrder(TCRnum,TCRMode,not(rampup));
            } 

            F021_TurnOff_AllTPADS();

            if ((special_opt==2) and ramp3vfl)  
//               STDSetVI(FL_PUMP_SUPPLY_NAME,vdds_vProg,vdds_iProg);

//          Disable(s_pmexit);
            tmp_results = Check_RAM_TNUM(testnum);

            // KChau - added so not to bin out on rddist2 stress test
            if (not ((TCRnum==58) and (TCRMode==PvfyMode))) {
               DLOG.AccumulateResults(tmp_results,rtest_results);
               DLOG.AccumulateResults(final_results,rtest_results);
            } 
            
//            F021_RunTestNumber(tnum_always_pass,1s,spare_mstreal1,spare_msbool1);

            ttimer2 = TIME.GetTimer();
            tt_timer = ttimer2;

            // log to TW
            tmpstr2 = "_B";  // _B#
            //  tmpstr2 = CONV.IntToString(bankcount);  // Bug IntToStr can't convert zero (SPR142812)
            if ( bankcount == 0 ) tmpstr2 = "0";
            else                  tmpstr2 = CONV.IntToString(bankcount);

            if (pattype==BLOCKTYPE) {
               tmpstr3 = "BLK";
               //  tmpstr3 = CONV.IntToString(count);  // Bug IntToStr can't convert zero (SPR142812)
               if ( count == 0 ) tmpstr3 = "0";
               else              tmpstr3 = CONV.IntToString(count);
               tmpstr2 += tmpstr3;
            } 
            tmpstr3 = tmpstr1 + tmpstr2;  /*now has xx_B#*/
            tmpstr4 = tmpstr3 + "_TT";
//          TWTRealToRealMS(tt_timer,realval,unitval);
//          TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
         
//             PrintResultBool(tmpstr3,testnum,tmp_results,GL_PLELL_FORMAT);
            if (tistdscreenprint)  
               cout << tmpstr3 << testnum << tmp_results << endl;
            
            // log failed test to tw
            // KChau 12/21/07 - determine if any site is failing to log to TW.
//          if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//          {
//             F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
//             
//             if(TI_FlashCOFEna)  
//                F021_Update_COF_Inst_Str(tmpstr2,site_cof_inst_str,tmp_results);
//          } 
            
            testnum = testnum+1;
            
//          if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//             Devsetholdstates(final_results);
            
//          if(not v_any_dev_active)  
               break;
         }   // for count

         // run once only for vhv stress*/
         if(special_opt == 5)  
            break;
         
      }   // for bankcount
   }    // +++ End of Bank operation +++

   // restore all active sites
// Devsetholdstates(savesites);

// ResultsRecordActive(final_results, S_NULL);
// TestClose;

   test_results = final_results;
   
   if (TI_FlashCOFEna)  
      ;
//      F021_Save_COF_Info(tmpstr1,site_cof_inst_str,final_results);

   if ((special_opt==2) and ramp3vfl)
      ;
//      STDSetVI(FL_PUMP_SUPPLY_NAME,vdds_vProg,vdds_iProg);
   
   F021_TurnOff_AllTPADS();
//   F021_RunTestNumber(tnum_always_pass,1s,spare_mstreal1,spare_msbool1);
   
   ttimer1 = TIME.GetTimer();
   tt_timer = ttimer1;

   tmpstr4 = tmpstr1 + "_TTT";
// TWTRealToRealMS(tt_timer,realval,unitval);
// TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);

   if (tistdscreenprint)  {
      // PrintHeaderBool(GL_PLELL_FORMAT);
      //PrintResultBool(tmpstr1,start_testnum,final_results,GL_PLELL_FORMAT);
      cout << tmpstr1 << start_testnum << final_results << endl;
      cout << "   TT " << ttimer1 << endl;
      cout << endl;
   }   // if tistdscreenprint
   
//   if ((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//      DevSetHoldStates(final_results);

   return(final_results);
}   // F021_Stress_func

#if 0
TMResultM F021_RefArr_Erase_func(    StringS tname,
                                     BoolS adaptiveEna)
{
   const IntS TCR56 = 56; 
   const IntS TCR40 = 40; 
   const IntS EVENNUM = 0; 
   const IntS ODDNUM = 1; 

//   FloatS tdelay,maxtime;
//   BoolM savesites,logsites,rtest_results;
//   BoolM tmp_results,final_results;
//   BoolM meas_results,activestates,sitetorestore;
//   IntS site,bankcount;
//   IntS pattype,testnum;
//   FloatS ttimer1,ttimer2;
//   FloatM tt_timer;
//   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4,vstr;
//   FloatM FloatSval;
//   TWunit unitval;
//   StringS fl_testname;
//   prepostcorner prepost;
//   BoolS parmena,done,once,ovride_lim;
//   FloatS ovride_llim,ovride_ulim;
//   PinM testpad,cntrlpad;
//   FloatS tpad_force,cntrlpad_force;
//   BoolS x64soft;
//   StringM site_cof_inst_str;
//   TPModeType tcrmode_refarr,tcrmode_ipmos;
//   TPModeType tcrmode_ipmos_pre;
//   IntS tnum_refarr,tcrnum_refarr;
//   IntS tcrnum_ipmos,loop;
//   IntS1D tnum_ipmos(2);
//   FloatS llim,ulim,llim_pre,ulim_pre;
//   FloatM meas_value,ipmos_even,ipmos_odd;
//   FloatM ieven_fn,iodd_fn,ieven_odd_avg;
//   FloatM1D ieven_pre(8),iodd_pre(8);
//   FloatS ers_pwmax,ers_pwidth;
//   FloatS vstart,vstop,vinc,vProg,iavg_toler;
//   FloatM ers_pwtotal;
//   IntS ers_cntmin,ers_cntmax,ers_loop;
//   BoolM retestsites,allsitefalse;
//   BoolS bool1,bool2;
//   BoolM1D bankdone(8);
//   IntS minloop,maxloop;

   if(tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ F021_RefArr_Erase_func +++++" << endl;
   
   maxtime = GL_F021_BANK_MAXTIME;
   tdelay  = 10ms;
   any_site_active = true;
   retest = true; // will be and-ed later

   tcrnum_ipmos  = TCR40;
   tcrmode_ipmos = EvfyMode;
   tnum_ipmos[0] = TNUM_BANK_IPMOS_READ_EVEN;
   tnum_ipmos[1] = TNUM_BANK_IPMOS_READ_ODD;
   testpad = FLTP2;
    /*pre-ers*/
   tcrmode_ipmos_pre = ProgMode;  /*actual mode is evfy*/
   llim_pre = TCR.TP2_LLim[TCRnum_ipmos][TCRMode_ipmos_pre];   /*-135ua*/
   ulim_pre = TCR.TP2_ULim[TCRnum_ipmos][TCRMode_ipmos_pre];   /*5ua*/

   ers_cntmin = 1;
   tcrnum_refarr  = TCR56;
   tnum_refarr    = TNUM_BANK_REFARR_ERS;

    /*post-ers*/
   if(not adaptiveEna)  
   {
      llim = Bank_IPMOS_ErsPst_LLim;   /*-126ua*/
      ulim = Bank_IPMOS_ErsPst_ULim;   /*-85ua*/
      ers_pwmax  = Bank_RefArr_VEG_Ers_PWidth;
      ers_pwidth = ers_pwmax;
      ers_cntmax = ers_cntmin;
      vstart     = Bank_RefArr_VEG_Ers;
      vstop      = vstart;
      vinc       = 1V;
      tcrmode_refarr = ErsMode;
   }
   else
   {
      iavg_toler = 10uA;
      llim = Bank_IPMOS_ErsPst_LLim;   /*-126ua*/
      ulim = IPMOS_Adaptive_Target+iavg_toler;    /*-46ua=-56ua+10ua*/
      ers_pwidth = RefArr_Ers_Adaptive_RESOL;  /*per step resol*/
      ers_pwmax  = RefArr_Ers_Adaptive_PWIDTH;
      ers_cntmax = trunc(ers_pwmax/ers_pwidth);
      vstart     = RefArr_Ers_Adaptive_Vstart;
      vstop      = RefArr_Ers_Adaptive_Vstop;
      vinc       = 1V;
      tcrmode_refarr = EvfyMode;
   } 
   
   for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;++bankcount)
      bankdone[bankcount] = true;

   minloop = EVENNUM;
   if(GL_BANKTYPE==FLEPBANK)  
      maxloop = ODDNUM;
   else
      maxloop = EVENNUM;

   TIME.StartTimer();      

   savesites = ActiveSites;
   final_results = TM_NOTEST;
   allsitefalse = false;

   fl_testname = tname;
   tmpstr1 = fl_testname.Substring(1, fl_testname.Length()-6);

// :TODO: Implement below   
//   if(TI_FlashCOFEna)  
//      F021_Init_COF_Inst_Str(site_cof_inst_str);
   
    /*--- read ipmos evfy even/odd Pre ers ---*/
   for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;++bankcount)
   {
      logsites = ActiveSites;     
      rtest_results = TM_NOTEST;
      meas_results = TM_NOTEST; 
      tmp_results = TM_NOTEST;

      ieven_pre[bankcount] = 0uA;
      iodd_pre[bankcount] = 0uA;

      tmpstr2 = "_B" + bankcount;
      tmpstr4 = "IPMOS_Rd";
      for (loop = minloop;loop <= maxloop;++loop)
      {
         testnum = tnum_ipmos[loop]+(bankcount<<4);
         F021_Set_TPADS(tcrnum_ipmos,tcrmode_ipmos_pre);
         rtest_results = F021_RunTestNumber_PMEX(testnum,maxtime);
         TIME.Wait(tdelay);
         meas_value = F021_Meas_TPAD_PMEX(testpad,tcrnum_ipmos,tcrmode_ipmos_pre);
         F021_TurnOff_AllTPADS();

         if(loop==0)  
         {
            tmpstr3 = tmpstr4 + "_NME_Pre";
            ieven_pre[bankcount] = meas_value;
         }
         else
         {
            tmpstr3 = tmpstr4 + "_NMO_Pre";
            iodd_pre[bankcount] = meas_value;
         } 
         
         tmpstr3 = tmpstr3 + tmpstr2;
         meas_results = TIDlog.Value(meas_value, testpad, llim_pre, ulim_pre, meas_value.GetUnits(), 
                      tmpstr3, UTL_VOID, UTL_VOID, true, TWMinimumData);
         
         /*bin out if pattern/tnum fail exec or out of limits*/
         tmp_results = DLOG.AccumulateResults(meas_results, rtest_results);
         final_results = tmp_results;
      
// :TODO: Need to implement fail logging
//         if(tmp_results.AnyEqual(TM_FAIL))  
//         {
//            F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
//            if(TI_FlashCOFEna)  
//               F021_Update_COF_Inst_Str(tmpstr3,site_cof_inst_str,tmp_results);
//         } 
      }   /*for loop*/

       /*check if already erased w/in limits, i.e. retested unit*/
      if(adaptiveEna)  
      {
         if(GL_BANKTYPE==FLEPBANK)  
            ieven_odd_avg = (ieven_pre[bankcount]+iodd_pre[bankcount])*0.5;
         else
            ieven_odd_avg = ieven_pre[bankcount];
         bankdone[bankcount] = ieven_odd_avg.LessOrEqual(ulim);
      }
      else
      {
          /*apply pulse regardless*/
         bankdone[bankcount] = false;
      } 
      retest &= bankdone[bankcount];

       /*disable site failing tnum exec*/
      if((!RunAllTests) and (!TI_FlashCOFEna))  
      {
         new_active_sites = ActiveSites;
         new_active_sites.DisableFailingSites(final_results.Equal(TM_PASS));
         if (!(any_site_active = SetActiveSites(new_active_sites)))
            break;
      }
   }   /*for bankcount*/

   // make sure we have a passing site
   if (any_site_active)
   {
       /*disable retested site*/
      new_active_sites = ActiveSites;
      new_active_sites.DisableFailingSites(!retest);
      if (tistdscreenprint)
      {
         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
            cout << "Site " << *si << " RefArray Already Erased w/in limit " << ulim << "  So Disable" << endl;
      }
      any_site_active = SetActiveSites(new_active_sites);
   
       /*+++ start erase pulse*/
      if(any_site_active)  
      {
          /*log target to tw*/
         if(adaptiveEna)  
            meas_value = IPMOS_Adaptive_Target;
         else
            meas_value = Bank_IPMOS_Prog_Target;
            
         tmpstr3 = tmpstr1 + "_TGET";
         TWPDLDataLogRealVariable(tmpstr3,meas_value.GetUnits(),meas_value,TWMinimumData);

         erase_sites = ActiveSites;

         if(tistdscreenprint)  
         {
            cout << endl;
            cout << tmpstr1 << " PWidth == " << ers_pwidth << "  max Pulse == " << ers_cntmax << 
                    " StartV == " << vstart << " StopV == " << vstop << endl;
            cout << endl;
         } 
         
         for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;++bankcount)
         {
            start_time2 = TIME.GetTimer();

            tmpstr2 = "_B" + bankcount;

            new_active_sites = ActiveSites;
            new_active_sites.DisableFailingSites(!bankdone[bankcount]);

             /*+++++ ERS +++++*/
            if(SetActiveSites(new_active_sites))  
            {
               logsites = ActiveSites;       /*use for re-enable site & log if anyfail*/
               ers_pwtotal = 0ms;

               if(adaptiveEna)  
                  CloneTCR_To_TCR128(tcrmode_refarr,tcrmode_refarr,tcrnum_refarr);

               for (FloatS vProg = vstart; vProg <= vstop; VProg += vinc)
               {
                  vstr = "_" + vProg;

                  if(adaptiveEna)  
                     TCR.TP1_VRange[tcrnum_refarr][tcrmode_refarr] = vProg;

                  for (ers_loop = ers_cntmin; ers_loop <= ers_cntmax; ++ers_loop)
                  {
                      /*--- apply ers pulse ---*/
                     testnum = tnum_refarr+(bankcount<<4);
                     F021_TurnOff_AllTpads();
                     rtest_results = F021_RunTestNumber_PMEX(testnum,maxtime);
                     F021_Set_TPADS(tcrnum_refarr,tcrmode_refarr);
                     TIME.Wait(ers_pwidth);
                     F021_TurnOff_AllTpads();
                     tmp_results = Check_RAM_TNUM(testnum);

//:HERE:
                      /*tally up total applied pwidth*/
                     for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
                        if(v_dev_active[site])  
                        {
                           ers_pwtotal[site] = ers_pwtotal[site] + ers_pwidth;
                           if((not rtest_results[site]) or (not tmp_results[site]))  
                              final_results[site] = false;
                        } 
                     
                      /*--- read ipmos evfy even/odd ---*/
                     writestring(tmpstr4,ers_loop:1);
                     tmpstr4 = "_PLS" + tmpstr4;
                     tmpstr4 = tmpstr2 + tmpstr4;   /*_B#_PLS#*/
                     tmpstr4 = tmpstr4 + vstr;
                     
                     for (loop = minloop;loop <= maxloop;loop++)
                     {
                        testnum = tnum_ipmos[loop]+(bankcount<<4);
                        F021_Set_TPADS(tcrnum_ipmos,tcrmode_ipmos);
                        F021_RunTestNumber_PMEX(testnum,maxtime,rtest_results);
                        TIME.Wait(tdelay);
                        discard(F021_Meas_TPAD_PMEX(testpad,tcrnum_ipmos,tcrmode_ipmos,
                                llim,ulim,meas_value,meas_results));  /*note: don"t want to fail meas_value here*/
                        F021_TurnOff_AllTpads;
                        Disable(s_pmexit);
                        Check_RAM_TNUM(testnum,tmp_results);

                        for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
                           if(v_dev_active[site])  
                              if((not rtest_results[site]) or (not tmp_results[site]))  
                                 final_results[site] = false;
                        
                        if(loop==0)  
                        {
                           ipmos_even = meas_value;
                           tmpstr3 = tmpstr1 + "_IEVEN";
                        }
                        else
                        {
                           ipmos_odd = meas_value;
                           tmpstr3 = tmpstr1 + "_IODD";
                        } 
                        
                         /*tw log ipmos value*/
                        tmpstr3 = tmpstr3 + tmpstr4;
                        TWTRealToRealMS(meas_value,realval,unitval);
                        TWPDLDataLogRealVariable(tmpstr3,unitval,realval,TWMinimumData);
                        
                        PrintResultParam(tmpstr3,testnum,meas_results,llim,ulim,meas_value,GL_PLELL_FORMAT);
                     }   /*for loop*/
                     
                      /*--- check even/odd against target/limits ---*/
                     for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
                        if(v_dev_active[site])  
                        {
                           if(adaptiveEna)  
                           {
                              if(GL_BANKTYPE==FLEPBANK)  
                                 ieven_odd_avg[site] = (ipmos_even[site]+ipmos_odd[site])*0.5;
                              else
                                 ieven_odd_avg[site] = ipmos_even[site];
                              if(ieven_odd_avg[site]<==ulim)  
                              {
                                 bool1 = true;
                                 bool2 = true;
                              }
                              else
                              {
                                 bool1 = false;
                                 bool2 = false;
                              } 
                           }
                           else
                           {
                              if(ipmos_even[site] <== ulim)  
                                 bool1 = true;
                              else
                                 bool1 = false;

                              if(GL_BANKTYPE==FLEPBANK)  
                              {
                                 if(ipmos_odd[site] <== ulim)  
                                    bool2 = true;
                                 else
                                    bool2 = false;
                              }
                              else
                              {
                                 bool2 = true;
                                 ipmos_odd[site] = ipmos_even[site];
                              } 
                           } 
                           
                           if(bool1 and bool2)  
                           {
                              activestates[site] = false;  /*done erasing*/
                              ieven_fn[site] = ipmos_even[site];
                              iodd_fn[site]  = ipmos_odd[site];
                              tt_timer[site] = timernread(ttimer2);
                              if(tistdscreenprint)  
                                 cout << "Site " << site:-5 << " Done Erasing so dis-able" << endl;
                           } 
                     
                            /*reached max ers but failed iref*/
                           if((ers_loop==ers_cntmax) and (vProg==vstop))  
                              if(activestates[site])  
                              {
                                 final_results[site] = false;
                                 activestates[site] = false;
                                 ieven_fn[site] = ipmos_even[site];
                                 iodd_fn[site]  = ipmos_odd[site];
                                 tt_timer[site] = timernread(ttimer2);
                                 if(tistdscreenprint)  
                                    cout << "Site " << site:-5 << " Reached Max pulse but Failed Erasing" << endl;
                              } 
                        }   /*if v_dev_active*/
               
                      /*disable site done erasing*/
                     devsetholdstates(activestates);
                     
                     if(not v_any_dev_active)  
                        break;
                  }   /*for ers_loop*/

                  if(not v_any_dev_active)  
                     break;
               }   /*for vProg*/
               
               if(adaptiveEna)  
                  RestoreTCR_Fr_TCR128(tcrmode_refarr,tcrmode_refarr,tcrnum_refarr);
               
               devsetholdstates(logsites);
                  
                /*tw log total ers pulsewidth applied*/
               tmpstr3 = tmpstr1 + "_TOTPW";
               tmpstr3 = tmpstr3 + tmpstr2;
               TWTRealToRealMS(ers_pwtotal,realval,unitval);
               TWPDLDataLogRealVariable(tmpstr3, unitval,realval,TWMinimumData);
               
               tmpstr3 = tmpstr1 + tmpstr2;
               tmpstr3 = tmpstr3 + "_TT";
               TWTRealToRealMS(tt_timer,realval,unitval);
               TWPDLDataLogRealVariable(tmpstr3, unitval,realval,TWMinimumData);
               
               tmpstr3 = tmpstr1 + tmpstr2;
               tmpstr3 = tmpstr3 + "_IEVEN";
               TWTRealToRealMS(ieven_fn,realval,unitval);
               TWPDLDataLogRealVariable(tmpstr3, unitval,realval,TWMinimumData);

               if(GL_BANKTYPE==FLEPBANK)  
               {
                  tmpstr3 = tmpstr1 + tmpstr2;
                  tmpstr3 = tmpstr3 + "_IODD";
                  TWTRealToRealMS(iodd_fn,realval,unitval);
                  TWPDLDataLogRealVariable(tmpstr3, unitval,realval,TWMinimumData);
               } 
               
                /*store/copy to global var*/
                /*if(ers_loop = ers_cntmax) then
                 for site := 1 to v_sites do
                 if(v_dev_active[site]) then
                 BANK_IREFARR_VALUE[bankcount,loop,tcrmode_ipmos,prepost,vcorner,site] := meas_value[site];
                 */
         
               if(not ArrayCompareBoolean(logsites,final_results,v_sites))  
               {
                  tmpstr3 = tmpstr1 + tmpstr2;
                  F021_Log_FailPat_To_TW(tmpstr3,final_results,fl_testname);
                  if(TI_FlashCOFEna)  
                     F021_Update_COF_Inst_Str(tmpstr3,site_cof_inst_str,final_results);
               } 

                /*update so won"t re-enable or continue testing next bank if failed*/
               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
                  if(v_dev_active[site] and (not final_results[site]))  
                     if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
                        sitetorestore[site] = false;
               
               if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
                  Devsetholdstates(final_results);

            }   /*if v_any_dev_active*/
             /*+++++ ERS +++++*/            
            if(ArrayCompareBoolean(sitetorestore,allsitefalse,v_sites))  
               break;
               
            RunTime.SetActiveSites(erase_sites); // need to reactivate sites before loop since disabling on done of bankcount
         }   /*for bankcount*/
      }   /*if v_any_dev_active*/ // retest sites
   } /* if any_site_active -- for if we had a passing site */
   
    /*restore all active sites*/
   // we know there will be sites, so can use the RunTime version
   RunTime.SetActiveSites(savesites);

   ResultsRecordActive(final_results, S_NULL);
   TestClose;

   Disable(s_pmexit);
            
   if(TI_FlashCOFEna)  
      F021_Save_COF_Info("",site_cof_inst_str,final_results);
   
   tt_timer = TIME.StopTimer();
   
   tmpstr4 = tmpstr1 + "_TT";
   TWTRealToRealMS(tt_timer,realval,unitval);
   TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);

   F021_TurnOff_AllTpads;
   
   if(tistdscreenprint)  
   {
      PrintHeaderBool(GL_PLELL_FORMAT);
      PrintResultBool(tmpstr1,tnum_refarr,final_results,GL_PLELL_FORMAT);
      cout << "   TT " << ttimer1 << endl;
      cout << endl;
   } 
   
   if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
      DevSetHoldStates(final_results);
   
   test_results = final_results;
   
   return (final_results);
}   /* F021_RefArr_Erase_func */
#endif
void MeasInternalVT(    IntS       testnum,
                        FloatS     test_llim,
                        FloatS     test_ulim,
                        TMResultM  ret_results,
                        FloatM     ret_values) {
   BoolM savestates;
   TMResultM results;
   BoolM activestates,savesites;
   FloatS ttimer1,maxtime,tdelay;
   FloatS llimit,ulimit;
   FloatM values;
   IntS site,count,tcrnum,tnum,bank;
   TPModeType tcrmode;
   PinM tsupply;
   IntM msw_faddr,lsw_faddr;
   IntM msw_fdata,lsw_fdata;
   IntM msw_fdata1,lsw_fdata1;
   IntM ovr_slpct;
   BoolS do_bcc;
   StringS str1,str2;

   str1 = CONV.FloatToString(test_ulim);
   
   if (str1.Find("A") >= 0) {
      str2 = "MeasInternalBCC";
      do_bcc = true;
   }
   else {
      str2 = "MeasInternalVT";
      do_bcc = false;
   } 
   
   if (tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ " << str2 << " +++++" << endl;
   
   tdelay = 10ms;
   maxtime = GL_F021_BANK_VT_MAXTIME;
   llimit = test_llim;
   ulimit = test_ulim;
   tnum = testnum;

   if (not (do_bcc)) {
      values = 0V;
      tcrnum = 72;
      tcrmode = ReadMode;
      tsupply = FLTP1;
      if (GL_PUMPTYPE==ESPUMP) {
         ovr_slpct = 0xF;
         RAM_Upload_SoftTrim(0xAA55,MAINBG_TRIMSAVED,MAINIREF_TRIMSAVED,FOSC_TRIMSAVED,ovr_slpct,VSA5CT_TRIMSAVED);
      } 
   }
   else {
      values = 0uA;
      tcrnum = 25;
      tcrmode = ErsMode;
      tsupply = FLTP2;
   } 

   if (GL_DO_BCCVT_RCODE_ENA)
      MBox_Upload_RCODE_PSA(GL_DO_BCCVT_RCODE_BANK,Random);

   TIME.StartTimer();
   F021_TurnOff_AllTPADS();
   F021_Set_TPADS(tcrnum,tcrmode);
   results = F021_RunTestNumber_PMEX(tnum,maxtime);
   TIME.Wait(tdelay);
   values = F021_Meas_TPAD_PMEX(tsupply,tcrnum,tcrmode);
   F021_TurnOff_AllTPADS();

   ret_values = values;
   ret_results = results;

//   if (GL_DO_ESDA_WITH_SCRAM)
//      Get_Flash_TestLogSpace_SCRAM;

   if ((not (do_bcc)) and (GL_PUMPTYPE==ESPUMP))
      RAM_Clear_SoftTrim_All();

   if (GL_DO_CHARZ_SAMP_ACCY and GL_DO_SAVE_SAMP_ACCY_DATA) {
      bank = (tnum & 0x000000F0) >>4;
      count = (tnum & 0x0000000F);
      Get_TLogSpace_FailAddr(msw_faddr,lsw_faddr);
      Get_TLogSpace_FailData(msw_fdata,lsw_fdata);      // port0
      Get_TLogSpace_MeasFreq(msw_fdata1,lsw_fdata1);  // port1

      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
      {
         FL_SAMP_ACCY_VT.SetValue(bank,count,values[*si]);
         FL_SAMP_ACCY_VT_FADDR_MSW.SetValue(bank,count,msw_faddr[*si]);
         FL_SAMP_ACCY_VT_FADDR_LSW.SetValue(bank,count,lsw_faddr[*si]);
         FL_SAMP_ACCY_VT_FDATA_MSW.SetValue(bank,count,msw_fdata[*si]);
         FL_SAMP_ACCY_VT_FDATA_LSW.SetValue(bank,count,lsw_fdata[*si]);
         FL_SAMP_ACCY_VT_FDATA1_MSW.SetValue(bank,count,msw_fdata1[*si]);
         FL_SAMP_ACCY_VT_FDATA1_LSW.SetValue(bank,count,lsw_fdata1[*si]);
         
         if(tistdscreenprint and TI_FlashDebug) {
            cout << "Site" << *si << " FL_SAMP_ACCY_VT[" << bank <<"][" << count << "] == " << values[*si] << endl;
            cout << " FL_SAMP_ACCY_VT_FADDR MSW/LSW == " << hex << msw_faddr[*si] << " " << lsw_faddr[*si] << endl;
            cout << " FL_SAMP_ACCY_VT_FDATA MSW/LSW == " << msw_fdata[*si] << " " << lsw_fdata[*si] << endl;
            cout << " FL_SAMP_ACCY_VT_FDATA1 MSW/LSW == " << msw_fdata1[*si] << " " << lsw_fdata1[*si] << endl;
         }     
      }
   }   // do_save_samp_accy
   
   if(tistdscreenprint and TI_FlashDebug)  
      cout << str2 << " TNUM : " << hex << tnum << "  TT " << TIME.GetTimer() << endl; 
}   // MeasInternalVT

// RunTNUM_BIDI_Init removed from function F021_Vt_BinSearch_TTR below
void RunTNUM_BIDI_Init( IntS testnumber, TMResultM ret_results) {

   TMResultM final_results;
   IntS pmstop,site;
   FloatS tdelay1;

   pmstop = 1;
   tdelay1 = 10ms;
//   final_results = v_dev_active;
   F021_SetTestNum(testnumber);
//   Enable(S_PMEXIT);
//   PMEXSetDelay(S_PFlags,pmstop);

//   PatternExecute(spareint1,f021_shell_exepat);
   DIGITAL.ExecutePattern("f021_shell_exepat");
   ret_results = final_results;
//   ArrayAndBoolean(final_results,final_results,v_pf_status,v_sites);

//   DCConnect(NPORRST,S_High,S_Ldoff);
//   DCConnect(F021_DONEPIN,S_High,S_ldoff);  /*strobe hi*/
//   DCConnect(F021_NDONEPIN,S_Low,S_ldoff);  /*strobe low*/
//   DCConnect(F021_PASSPIN,s_High,s_ldoff);  /*strobe hi*/

   if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
   {
      cout << "RunTNUM_BIDI_Init LOAD  ";
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      {
//         if(v_dev_active[site])  
//         {
//            if(final_results[site])  
//               cout << "  /  ");
//            else
//               cout << "  X  ";
//         }
//         else
//            cout << "  X  ";
//      }   /*for site*/
      cout << endl;
   } 
   
//   if((not TIIgnoreFail) and (not TI_FlashCOFEna))
//      DevSetHoldStates(final_results);   /*de-activate failing site*/
}   // RunTNUM_BIDI_Init

// Poll_VCTRL removed from function F021_Vt_BinSearch_TTR below
void Poll_VCTRL(BoolS VctrlHi, TMResultM ret_results, FloatS maxtimeout ) {

   BoolM donesites;
   TMResultM poll_results,final_results;
   FloatS tdelay1,maxpolltime,polltimer;
   BoolS result;
   FloatM ttimer;
//   option poll_opt;
   IntS site;

   tdelay1  = 2ms;
//   final_results = v_dev_active;
   donesites = false;

   if(VctrlHi) {
//      poll_opt = S_High;
      maxpolltime = 500ms;
   }
   else {
//      poll_opt = S_Low;
      maxpolltime = maxtimeout;
   } 


//   DCConnect(F021_VCTRLPIN,poll_opt,S_ldoff);
   TIME.Wait(tdelay1);
   result = false;
//   timernstart(polltimer);
   TIME.StartTimer();

//   while ((not result) and (TIME.GetTimer() < maxpolltime)) {
//      VoltageCompareOpt(S_DATA);
//      CompareGet(F021_VCTRLPIN);
//      poll_results = v_pf_status;
//      result = ArrayCompareBoolean(poll_results,v_dev_active,v_sites);
        
      
       /*record time for done site*/
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
//         if ( poll_results[si*] and (not donesites[si*]) ) {
//            ttimer[si*] = timernread(polltimer);
//            ttimer[si*] = TIME.GetTimer();
//            donesites[si*] = true;
//         }
//      }
//      TIME.Wait(tdelay1);
//   }   // while

//   ArrayAndBoolean(final_results,final_results,poll_results,v_sites);
   DLOG.AccumulateResults(final_results, poll_results);
   ret_results = final_results;
   
    /*record time for time-out site*/
//   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
//      if ( (not donesites[si*]) ) {
////         ttimer[si*] = timernread(polltimer);
//         ttimer[si*] = TIME.GetTimer();
//         donesites[si*] = true;
//      }
//   }

   TIME.Wait(tdelay1);

   if (tistdscreenprint and TI_FlashDebug and tiprintpass) {
      if ( VctrlHi )  
         cout << setw(9) << " " << setw(10) << "VCTRL (1)";
      else
         cout << setw(9) << " " << setw(10) << "VCTRL (0)" << endl;
         
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) { 
//         cout << "Site" << setw(5) << site << "  " << setw(10) << poll_results[si*] << "  PollTime : " << ttimer[si*];
//         cout << "  Results : " << final_results[si*] << endl;
//      }      
   }   /*screenprint*/

//   if((not tiignorefail) and (not TI_FlashCOFEna))  
//      DevSetHoldStates(final_results);   /*de-activate failing site*/
}   // Poll_VCTRL 

// Poll_PFDONE removed from function F021_Vt_BinSearch_TTR below
void Poll_PFDONE(IntS testnumber, TMResultM ret_results, FloatS maxtimeout) {

   TMResultM done_results,ndone_results;
   TMResultM pass_results,final_results, tmp_results;
   BoolM donesites;
   FloatS tdelay1,maxtimer,ttimer1;
   TMResultM result;
   FloatM ttimer;
//   option poll_opt;
   IntS site,tnumlo,tnumhi;
   IntS addr_loc,addr_loc2;
   IntM value1,value2,value3,value4;

//   timernstart(ttimer1);
   TIME.StartTimer();
   tdelay1  = 2ms;
//   final_results = v_dev_active;
   donesites = false;
 /*
    DCConnect(NPORRST,S_High,S_Ldoff);
    DCConnect(F021_DONEPIN,S_High,S_ldoff); {strobe hi*/
//   DCConnect(F021_NDONEPIN,S_Low,S_ldoff);  /*strobe low*/
//   DCConnect(F021_PASSPIN,s_High,s_ldoff);  /*strobe hi*/
         
   TIME.Wait(tdelay1);
//   result = false;
//   timernstart(maxtimer);
   TIME.StartTimer();


//   while((not result) and (TIME.GetTimer()<maxtimeout))
   while( (TIME.GetTimer()<maxtimeout) ) {
      TIME.Wait(tdelay1);
//      VoltageCompareOpt(S_DATA);
//      CompareGet(F021_DONEPIN);
//      done_results = v_pf_status;
//      CompareGet(F021_NDONEPIN);
//      ndone_results = v_pf_status;
//      ArrayAndBoolean(tmp_results,done_results,ndone_results,v_sites);
      tmp_results = DLOG.AccumulateResults(done_results,ndone_results);
      result = tmp_results;
//      result = ArrayCompareBoolean(tmp_results,v_dev_active,v_sites);
         
       /*record time for done site*/
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
//         if (tmp_results[si*] and (not donesites[si*])) {
           //   ttimer[si*] = timernread(maxtimer);
//            ttimer[si*] = TIME.GetTimer();
//            donesites[site] = true;
//         }
//      }
   }   /*while*/

//   CompareGet(F021_PASSPIN);
//   pass_results = v_pf_status;
      
    /*record time for time-out site*/
//   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
//      if ((not donesites[si*])) {
////         ttimer[site] = timernread(maxtimer);
//         ttimer[si*] = TIME.GetTimer();
//         donesites[si*] = true;
//      }
//   }

   if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
   {
      cout << "        " << setw(10) << "DONE (1)  " << setw(10) << "NDONE (0)  " << "PASS (1)" << endl; 
      cout << "Site " << setw(2) << site << "  " << setw(10) << done_results;
      cout << "  " << setw(10) << ndone_results << "  " << pass_results << endl;
   } 

   DLOG.AccumulateResults(final_results,tmp_results);
   DLOG.AccumulateResults(final_results,pass_results);
   ret_results = final_results;

//   if(tistdscreenprint and TI_FlashDebug) {
//      cout << "Poll_PFDONE " << setw(12) << hex << testnumber;
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
//         if (final_results[si*]) cout << "  /  ");
//         else                   cout << "  X  ";
//      }
//      cout << "  TT " << ttimer1 << endl;
//   } 

   // if((not tiignorefail) and (not TI_FlashCOFEna)) then
   //      DevSetHoldStates(final_results);  {de-activate failing site}
}   // Poll_PFDONE

// Set_VSTAT removed from function F021_Vt_BinSearch_TTR below
void Set_VSTAT (BoolS VstatHi) {

   FloatS vdds_vProg,vdds_iProg;
   FloatS tdelay1,iclamp,vrng;
   IntS site;

//   if(VstatHi)
//      DCConnect(F021_VSTATPIN,s_high,s_ldoff);
//   else
//      DCConnect(F021_VSTATPIN,s_low,s_ldoff);

//   VoltageCompareOpt(S_DATA);

   if (tistdscreenprint and TI_FlashDebug and tiprintpass)  
      if (VstatHi)  
         cout << "Set VSTAT High";
      else
         cout << "Set VSTAT Low" << endl;
}   /* Set_VSTAT */

// Set_TPAD removed from function F021_Vt_BinSearch_TTR below
void Set_TPAD(BoolS sameness, FloatM values, FloatS prevvalue, FloatS previref, FloatS iclamp,
              PinM tp_iref, PinM tp_cg, FloatS vrngiref, FloatM irefarray ) {

   IntS opertype, site;
   BoolM logsites;

//   logsites = v_dev_active;

   if (not sameness) {
   if (tistdscreenprint and TI_FlashDebug and tiprintpass)  
      cout << "Set_TPAD" << endl;
      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
         if (opertype != OPER_TCR5) {
            STDSetVI(tp_iref,prevvalue,irefarray[*si],VI_FORCE_V,VI_MEASURE_I,vrngiref );
         } 
         STDSetVI(tp_cg,values[*si],iclamp,VI_FORCE_V,VI_MEASURE_I,vrngiref);
         
//         devsetholdstate(site,false);
         if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
            cout << "Site" << setw(5) << *si << " TPAD @ " << values[*si] << endl;
            
//         devsetholdstates(logsites);
      }
   }
   else {
      if (opertype!=OPER_TCR5) {
         STDSetVI(tp_iref,vrngiref,previref, VI_FORCE_V,VI_MEASURE_I,vrngiref);
      } 
      STDSetVI(tp_cg,prevvalue,iclamp, VI_FORCE_V,VI_MEASURE_I,vrngiref);
      
      if (tistdscreenprint and TI_FlashDebug and tiprintpass)  
         cout << "Set_TPAD @ " << prevvalue << endl;
   }
}   // Set_TPAD

void CheckTNUM_DisPMEX (IntS testnumber, TMResultM final_results) {
   IntS site,tnumlo,tnumhi;
   IntS addr_loc,addr_loc2;
   IntM value1,value2,value3,value4;

//   SupplySet(SHR_UPMUS,0V,10nA);
//   DCConnect(F021_VSTATPIN,vstat_dbit,vstat_config);
//   Disable(s_pmexit);

   tnumhi = ((testnumber & IntS(0xffff0000))>>16) & IntS(0x0000ffff);
   tnumlo = testnumber&0x0000ffff;
//   if(GL_DO_ESDA_WITH_SCRAM)  
//      Get_Flash_TestLogSpace_SCRAM();         
   Get_TLogSpace_TNUM(value2,value1);
   Get_TLogSpace_PFBin(value3);
   value4 = value3 & 0xff00;
//   ArrayAndIntegerValue(value4,value3,0xff00,v_sites);
   
//   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
//      if ( final_results[*si])  
//         if ((value1[*si]!=tnumlo) or (value2[*si]!=tnumhi) or (value4[*si]!=0xaa00))  
//            final_results[*si] = false;
//   }         
   
   if(tistdscreenprint and TI_FlashDebug) {
      // Get_TLogSpace_PFBin(value3);
      addr_loc2 = ADDR_PF_BIN;
      addr_loc  = ADDR_TEST_INFO;
      cout << "RAM Loc (PF/Tnum) @ " << hex << (addr_loc2) << " / " << hex << (addr_loc) << "  ==  " << endl;
      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) { 
          cout << "Site " << setw(5) << *si << hex << value3[*si] << " ";
          cout << hex << value2[*si] << "  " << setw(8) << hex << value1[*si] << endl;
      }           
   } 
}   // CheckTNUM_DisPMEX
         

// Returned value if no converge:
// both passed : return 99v, both failed : return 0v
void F021_Vt_BinSearch_TTR( IntS   testnum,
                            FloatM vstart,
                            FloatM vstop,
                            FloatS vresolution,
                            FloatM irefarr,
                            FloatS maxtime,
                            FloatM ret_timer,
                            FloatM ret_values) {

   
   TMResultM results;
   BoolM savestates;
   BoolM activestates,savesites;
   TMResultM min_results;
   TMResultM max_results;
   TMResultM mid_results;
   FloatM vpass, vfail, vmid;
   IntS site,opertype,tnumdta,i;
   FloatS ttimer1;
   FloatM tt_timer,irefarray;
   FloatS iclamp;
   FloatS tdelay;
   BoolS debugprint;
   BoolS save_printpass;
   BoolS save_scrnprint;
   FloatS maxtimeout;
   FloatS prevstart,prevstop;
   BoolS sameness,firstcnt;
   FloatS previref,vrngiref;
   PinM tp_iref,tp_cg;
   BoolS savesupdelay;
//   option vdd_pgmMode,vdd_iGMode;
   FloatS vdd_iProg;
   FloatS vrangemax;
//   option vstat_dbit,vstat_config;
   BoolS vstat_drv,vstat_load;
   BoolS vstat_pmu,vstat_upmu;
   BoolS vstat_stmask;
   IntS testnumber,redbit,otpbit;
   BoolS pbistena,redena;
   FloatM vdefault;

   if(tistdscreenprint and TI_FlashDebug)  
      cout << "Binary Search Vt TTR ..." << endl;
   
   debugprint = TI_FlashDebug and tiprintpass;
   save_printpass = tiprintpass;
   save_scrnprint = tistdscreenprint;

   if(not debugprint) {
      tistdscreenprint = false;
      tiprintpass = false;
   } 
   
   iclamp = 100mA;
   tdelay = 5ms ; // 2ms
   maxtimeout = maxtime;

   irefarray = irefarr;

   vrngiref  = 2.5V;
   vrangemax = 0V;
   sameness = true;
   firstcnt = true;
   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
      if (vstart[*si]>vrangemax) vrangemax = vstart[*si];
      
      if (vstop[*si]>vrangemax) vrangemax = vstop[*si];

      if (firstcnt) {
         prevstart = vstart[*si];
         prevstop  = vstop[*si];
         previref  = irefarray[*si];
         firstcnt  = false;
      }
      else if ((vstart[*si]!=prevstart) or (vstop[*si]!=prevstop) or (irefarray[*si]!=previref)) {
         sameness = false;
         // break;
      }
   }

   // pbist tnum type
   if ((testnum & IntS(0xf0000000)) == IntS(0xB0000000)) {
      if ((testnum & IntS(0x000f0000)) == 0x00030000)  
         opertype = OPER_TCR6;
      else
         opertype = OPER_TCR5;
         
      pbistena = true;
      redena = false;
   }
   else {
      opertype = ((testnum&0x03000000) >>24) & 0x3;
      redbit = testnum&TNUM_REDUNDENA;
      otpbit = (testnum&0x00000f00)>>8;
      
      if ((redbit==TNUM_REDUNDENA) or (otpbit==0x4) or (otpbit==0x5))  
         redena = true;
         
      pbistena = false;
   } 

   switch (opertype) {
     case OPER_TCR5  :  
        tp_cg   = FLTP1;
        break; 
     case OPER_TCR6  :  
        tp_iref = FLTP2;
        tp_cg   = FLTP1;
        break; 
     case OPER_TCR39 :  
        tp_iref = FLTP1;
        tp_cg   = FLTP2;
        break; 
   } 
   
   if (TI_FlashDebug and save_scrnprint) {
      tistdscreenprint = true;
      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
         switch(opertype) {
           case OPER_TCR5 :  
              cout << "Site " << setw(5) << *si << " TP1(CG) @ " << iclamp << endl;
              break; 
           case OPER_TCR6 :  
              cout << "Site " << setw(5) << *si << " TP1(CG) @ " << iclamp;
              cout << "  TP2(Iref) @ " << vrngiref << " " << irefarray[*si] << endl;
              break; 
           case OPER_TCR39 :  
              cout << "Site " << setw(5) << site << " TP2(CG) @ " << iclamp;
              cout << "  TP1(Iref) @ " << vrngiref << " " << irefarray[*si] << endl;
              break; 
         }   // case
      }
      if (not debugprint)  
         tistdscreenprint = false;
   } 
                 
   TIME.StartTimer();
   
   min_results = TM_NOTEST;
   max_results = TM_NOTEST;
   vmid = 0V;
   vpass = 0V;
   vfail = 0V;

//   savestates = v_dev_active;
//   activestates = v_dev_active;

//   savesupdelay = v_no_supplyset_delay;
//   v_no_supplyset_delay = true;

   if (opertype != OPER_TCR5)
      VI.SetMeasureVRange(tp_iref,vrngiref);
//      STDSetVRange(tp_iref,vrngiref);

   VI.SetMeasureVRange(tp_cg,vrangemax);
//   STDSetVRange(tp_cg,vrangemax);
      
   if (GL_DO_BCCVT_RCODE_ENA and (opertype==OPER_TCR6))  
      MBox_Upload_RCODE_PSA_VRD_CT(GL_DO_BCCVT_RCODE_BANK,Random,0xF);
   else if (GL_DO_BCCVT_RCODE_ENA and (opertype!=OPER_TCR6))  
      MBox_Upload_RCODE_PSA(GL_DO_BCCVT_RCODE_BANK,Random);
   else if (opertype==OPER_TCR6)  
      TL_EngOvride_VRD_CT(0xF);   // KChau 11/16/10 - override VRD CT
   
   if (not GL_DO_VT_USING_BIDI) {
      Set_TPAD(sameness, vstart, prevstart, previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
      TIME.Wait(tdelay);
      F021_RunTestNumber(testnum,maxtime,tt_timer);
   }
   else {
//      DCconnectGet(F021_VSTATPIN,vstat_dbit,vstat_config,vstat_drv,vstat_load,vstat_pmu,vstat_upmu,vstat_stmask);
//      savesites = v_dev_active;
      vdefault = 1.8V;
      testnumber = testnum;
      F021_TurnOff_AllTPADS();
      Set_TPAD(sameness, vdefault, 1.8V, previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
      RunTNUM_BIDI_Init(testnumber,min_results);
      Set_VSTAT(false);  // set vstat lo
      Poll_VCTRL(true, results, maxtimeout);  // poll hi
      DLOG.AccumulateResults(min_results, results);
//      ArrayAndBoolean(min_results,min_results,results,v_sites);
      Set_TPAD(sameness, vstart, prevstart, previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
      TIME.Wait(tdelay);
      Set_VSTAT(true);  // set vstat hi
      Poll_VCTRL(false, results, maxtimeout);  // poll lo
      DLOG.AccumulateResults(min_results, results);
//      ArrayAndBoolean(min_results,min_results,results,v_sites);
      Set_TPAD(sameness, vdefault, 1.8V, previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
      Set_VSTAT(false);  // set vstat lo
      
      if ((not pbistena) and redena) {
         Poll_VCTRL(true, results, maxtimeout);  // poll hi
         DLOG.AccumulateResults(min_results, results);
//         ArrayAndBoolean(min_results,min_results,results,v_sites);
         Set_TPAD(sameness, vstart, prevstart, previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
         TIME.Wait(tdelay);
         Set_VSTAT(true);  // set vstat hi
         Poll_VCTRL(false, results, maxtimeout);  // poll lo
         DLOG.AccumulateResults(min_results, results);
//         ArrayAndBoolean(min_results,min_results,results,v_sites);
         Set_TPAD(sameness, vdefault, 1.8V, previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
         Set_VSTAT(false);  // set vstat lo
      } 
      Poll_PFDONE(testnumber, results, maxtimeout);
      DLOG.AccumulateResults(min_results, results);
//      ArrayAndBoolean(min_results,min_results,results,v_sites);
//      devsetholdstates(savesites);
      CheckTNUM_DisPMEX(testnum, results);
   } 

   if (tistdscreenprint and debugprint) {
      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
         if(min_results[*si])  
            cout << "Site " << setw(3) << *si << "  passed @ " << vstart[*si];
         else
            cout << "Site " << setw(3) << *si << "  failed @ " << vstart[*si] << endl;
      }
   } 

   if(GL_DO_BCCVT_RCODE_ENA and (opertype==OPER_TCR6))  
      MBox_Upload_RCODE_PSA_VRD_CT(GL_DO_BCCVT_RCODE_BANK,Random,0xF);
   else if(GL_DO_BCCVT_RCODE_ENA and (opertype!=OPER_TCR6))  
      MBox_Upload_RCODE_PSA(GL_DO_BCCVT_RCODE_BANK,Random);
   else if(opertype==OPER_TCR6)  
      TL_EngOvride_VRD_CT(0xF);   /*KChau 11/16/10 - override VRD CT*/
   
   if (not GL_DO_VT_USING_BIDI) {
      Set_TPAD(sameness, vstop, prevstop, previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
      TIME.Wait(tdelay);
      max_results = F021_RunTestNumber(testnum,maxtime,tt_timer);
   }
   else {
      Set_TPAD(sameness, vdefault, 1.8V, previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
      RunTNUM_BIDI_Init(testnumber,max_results);
      Set_VSTAT(false);  // set vstat lo
      Poll_VCTRL(true,results,maxtimeout);  // poll hi
//      ArrayAndBoolean(max_results,max_results,results,v_sites);
      DLOG.AccumulateResults(max_results,results);
      Set_TPAD(sameness,vstop,prevstop,previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
      TIME.Wait(tdelay);
      Set_VSTAT(true);  // set vstat hi
      Poll_VCTRL(false,results,maxtimeout);  // poll lo
//      ArrayAndBoolean(max_results,max_results,results,v_sites);
      DLOG.AccumulateResults(max_results,results);
      Set_TPAD(sameness,vdefault,1.8V,previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
      Set_VSTAT(false);  // set vstat lo
      
      if ((not pbistena) and redena) {
         Poll_VCTRL(true,results,maxtimeout);  // poll hi
//         ArrayAndBoolean(max_results,max_results,results,v_sites);
         DLOG.AccumulateResults(max_results,results);
         Set_TPAD(sameness,vstop,prevstop,previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
         TIME.Wait(tdelay);
         Set_VSTAT(true);  // set vstat hi
         Poll_VCTRL(false,results,maxtimeout);  // poll lo
//         ArrayAndBoolean(max_results,max_results,results,v_sites);
         DLOG.AccumulateResults(max_results,results);
         Set_TPAD(sameness,vdefault,1.8V,previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
         Set_VSTAT(false);  // set vstat lo
      }
      
      Poll_PFDONE(testnum,results,maxtimeout);
//      ArrayAndBoolean(max_results,max_results,results,v_sites);
      DLOG.AccumulateResults(max_results,results);
//      devsetholdstates(savesites);
      CheckTNUM_DisPMEX(testnum, results);
   } 

   if(tistdscreenprint and debugprint) {
      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
         if (activestates[*si])  
            if (max_results[*si])  
               cout << "Site " << setw(3) << "  passed @ " << vstop[*si];
            else
               cout << "Site " << setw(3) << "  failed @ " << vstop[*si] << endl;
      } 
   } 

   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
      if ((min_results[*si] and max_results[*si]) or
         ((not min_results[*si]) and (not max_results[*si]))) {
         ret_timer[*si] = TIME.GetTimer();
         
         if (min_results[*si] and max_results[*si]) {
            vpass[*si] = 99V;   /*default invalid value if both passed*/
            if (save_scrnprint) {
               tistdscreenprint=true;
               cout << "Site " << setw(3) << *si << " Passing both voltages. " << 
                       vstart[*si] << "  " << vstop[*si] << "  not converged!!!";
               cout << "  DISABLED " << endl;
            } 
         }
         else {
            if (save_scrnprint) {
               tistdscreenprint=true;
               cout << "Site " << setw(3) << *si << " Failing both voltages. " << 
                       vstart[*si] << "  " << vstop[*si] << "  not converged!!!";
               cout << "  DISABLED " << endl;
            } 
         } 

         if (save_scrnprint and (not debugprint))  
            tistdscreenprint=false;

//         activestates[site] = false;
//         devsetholdstate(site,false);  /*disable site*/
      }
      else {
         if (min_results[*si]) { 
            vpass[*si] = vstart[*si];
            vfail[*si] = vstop[*si];
         }
         else { 
            vpass[*si] = vstop[*si];
            vfail[*si] = vstart[*si];
         } 
         vmid[*si] = (vpass[*si]+vfail[*si])/2;
      } 
   }   /*for site*/

   sameness = false;
   
   if (GL_DO_BCCVT_RCODE_ENA and (opertype==OPER_TCR6))  
      MBox_Upload_RCODE_PSA_VRD_CT(GL_DO_BCCVT_RCODE_BANK,Random,0xF);
   else if (GL_DO_BCCVT_RCODE_ENA and (opertype!=OPER_TCR6))  
      MBox_Upload_RCODE_PSA(GL_DO_BCCVT_RCODE_BANK,Random);
   else if (opertype==OPER_TCR6)  
      TL_EngOvride_VRD_CT(0xF);   /*KChau 11/16/10 - override VRD CT*/

   if (not GL_DO_VT_USING_BIDI) {
      Set_TPAD(sameness,vmid,prevstart,previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
      TIME.Wait(tdelay);
      F021_RunTestNumber(testnum,maxtime,tt_timer);
   }
   else {
//      savesites = v_dev_active;
      Set_TPAD(sameness,vdefault,1.8V,previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
      RunTNUM_BIDI_Init(testnumber,mid_results);
      Set_VSTAT(false);  /*set vstat lo*/
      Poll_VCTRL(true,results,maxtimeout);  /*poll hi*/
      DLOG.AccumulateResults(mid_results,results);
//      ArrayAndBoolean(mid_results,mid_results,results,v_sites);
      Set_TPAD(sameness,vmid,prevstart,previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
      TIME.Wait(tdelay);
      Set_VSTAT(true);  /*set vstat hi*/
      Poll_VCTRL(false,results,maxtimeout);  /*poll lo*/
      DLOG.AccumulateResults(mid_results,results);
//      ArrayAndBoolean(mid_results,mid_results,results,v_sites);
      Set_TPAD(sameness,vdefault,1.8V,previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
      Set_VSTAT(false);  /*set vstat lo*/
     
      if ((not pbistena) and redena) {
         Poll_VCTRL(true,results,maxtimeout);  /*poll hi*/
         DLOG.AccumulateResults(mid_results,results);
//         ArrayAndBoolean(mid_results,mid_results,results,v_sites);
         Set_TPAD(sameness,vmid,prevstart,previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
         TIME.Wait(tdelay);
         Set_VSTAT(true);  /*set vstat hi*/
         Poll_VCTRL(false,results,maxtimeout);  /*poll lo*/
         DLOG.AccumulateResults(mid_results,results);
//         ArrayAndBoolean(mid_results,mid_results,results,v_sites);
         Set_TPAD(sameness,vdefault,1.8V,previref, iclamp, tp_iref, tp_cg, vrngiref, irefarray);
         Set_VSTAT(false);  /*set vstat lo*/
      } 
      Poll_PFDONE(testnum,results,maxtimeout);
      DLOG.AccumulateResults(mid_results,results);
//      ArrayAndBoolean(mid_results,mid_results,results,v_sites);
//      devsetholdstates(savesites);
      CheckTNUM_DisPMEX(testnum,mid_results);
   } 
  
   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
      if (mid_results[*si]) {
         vpass[*si] = vmid[*si];
         if (tistdscreenprint and debugprint)  
            cout << "Site " << setw(3) << "  passed @ " << vmid[*si] << endl;
      }
      else {
         vfail[*si] = vmid[*si];
         if (tistdscreenprint and debugprint)  
            cout << "Site " << setw(3) << "  failed @ " << vmid[*si] << endl;
      } 

      /*continue searching*/
      if ( MATH.Abs(vpass[*si]-vfail[*si]) > vresolution)  
         vmid[*si] = (vpass[*si]+vfail[*si])/2;
      else {  /*done searching*/
         ret_timer[*si] = TIME.GetTimer();
         activestates[*si] = false;
      } 
    }   /*for site*/

//      devsetholdstates(activestates);

    /*re-activate all incoming sites*/
//   devsetholdstates(savestates);
   ret_values = vpass;

   F021_TurnOff_AllTPADS();
   TIME.Wait(tdelay);

   tiprintpass = save_printpass;
   tistdscreenprint = save_scrnprint;
//   v_no_supplyset_delay = savesupdelay;

   if (tistdscreenprint and TI_FlashDebug and tiprintpass)  {
      // writeln(tiwindow);
      cout << "F021_Vt_BinSearch TTR :  " << endl;
      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
         if(savestates[*si])  
            cout << "site " << setw(5) << *si << "  " << vpass[*si] << "  " << endl;
         /*else
            write(tiwindow,"  X  ","  ");*/
      cout << "TT == " << TIME.GetTimer() << endl;
   } 
}   // F021_Vt_BinSearch_TTR

TMResultM F021_VT_Delta_func( IntS    pattype,
                              vttype  vt_type,
                              StringS tname,
                              BoolS   dlogonly) {
                           
   FloatS tdelay;
   BoolM savesites;
   TMResultM tmp_results;
   TMResultM final_results;
   TMResultM test_results;
   IntS site,opertype,special_opt;
   IntS testnum,bankcount,count;
   IntS blkstart,blkstop;
   FloatS ttimer1,ttimer2;
   FloatM tt_timer;
   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
   FloatM FloatSval;
//   TWunit unitval;
   StringS fl_testname;
   prepostcorner hitype,lotype;
   FloatM vt_values;
   FloatS Llimit,Ulimit,ULimit_Median;
   IntS shiftbit,length;
   FloatS vstart,vstop,vres;
   BoolM logsites;
   BoolS ersstr_ena,datalogonly;
   StringM site_cof_inst_str;
   BoolS atleast_onesite;
   IntS tnum_esda,imgnum,setbitesda,tcrnum;
   FloatM vt_values_esda;
   vttype previoustype;
   BoolS same_vttype,do_ena_red;
   FloatS1D sorted_vt_delta(5),tmp_delta(5);
   FloatM vt_val1,vt_val2,max_vt_med;
   FloatM median_values;
   FloatS1D vt_delta(2);
   
   // Declaring the BIG arrays local
   FloatM BANK_VT_DELTA_VALUE[8][16][25];

   if (tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ F021_VT_Delta_func +++++" << endl;

   // default to false on all vt_type. if ersstvt0 search
   // then set it later w/in that vt_type so not to disable site
   ersstr_ena = false;

   tmpstr1 = tname;
   tmpstr1.Replace(tmpstr1.Find("_Test"), 5, "");   // remove _Test   
   fl_testname = tname;

   TIME.StartTimer();      

   if (tistdscreenprint)  
      PrintHeaderParam(GL_PLELL_FORMAT);
   
//   TestOpen(fl_testname);

   if (TI_FlashCOFEna)
      ;
//      F021_Init_COF_Inst_Str(site_cof_inst_str);

//   savesites = V_dev_active;
   tmp_results = TM_NOTEST;
   final_results = TM_NOTEST;

   switch (vt_type) {
      case  CHKVT0DRL:
      case RCODEVT0:
         hitype = pre;
         lotype = post;
         break;  
      case  CHKVT1:
      case CHKVT1DRL:
      case REVTUNVT1:
      case PGMFFVT1:
      case PUNTHRUVT1:
      case FGWLVT1:
      case TUNOXTSMCVT1:
      case TUNOXVT1:
      case THINOXVT1:
      case RCODEVT1:
        hitype = post;
        lotype = pre;
        break;
     default:
        hitype = post;
        lotype = pre;
        break; 
   }   // case
            
   datalogonly = dlogonly;
   
   switch(vt_type) {
      // added special option so not to disable site for dr
      case CHKVT0DRL: special_opt = 3; break;
      case CHKVT1DRL: special_opt = 4; break;
      default:        special_opt = 0; break; 
   }  // case
 
   if(pattype==OTPTYPE) {
      Llimit = OtpVT.LDELTA[vt_type];
      Ulimit = OtpVT.UDELTA[vt_type];
      previoustype = OtpVT.PREVTYPE[vt_type];
      tcrnum = OtpVT.TCRNUM[vt_type][post];
      do_ena_red = false;
   }
   else {
      Llimit = MainVT.LDELTA[vt_type];
      Ulimit = MainVT.UDELTA[vt_type];
      previoustype = MainVT.PREVTYPE[vt_type];
      tcrnum = MainVT.TCRNUM[vt_type][post];
      do_ena_red = MainVT.ENARED[vt_type][post];
   } 

   if (previoustype == vt_type)  
      same_vttype = true;
   else
      same_vttype = false;
   
   if (TI_FlashESDAEna) {
      switch (tcrnum) {
        case  5: tnum_esda =  TNUM_TCR5; break;
        case  6: tnum_esda =  TNUM_TCR6; break;
        case 38: tnum_esda = TNUM_TCR38; break;
        default: tnum_esda = TNUM_TCR39; break;
      }   // case
      
      if (pattype==OTPTYPE) {
         tnum_esda = tnum_esda+OtpVT.IRATIO[vt_type][post]+OtpVT.RDOPTION[vt_type][post]+OtpVT.TDATA[vt_type];
      }
      else {
         tnum_esda = tnum_esda + MainVT.IRATIO[vt_type][post] + MainVT.TDATA[vt_type] + MainVT.RDOPTION[vt_type][post];
         if(MainVT.MEMCFG[vt_type]==SECTTYPE)  
            tnum_esda = tnum_esda + TNUM_TARGET_SECT;
         else if(MainVT.MEMCFG[vt_type]==BLOCKTYPE)  
            tnum_esda = tnum_esda + TNUM_TARGET_BLOCK;
         else if(MainVT.MEMCFG[vt_type]==QUADTYPE)  
            tnum_esda = tnum_esda + TNUM_TARGET_QUAD;
            
         if(do_ena_red)  
            tnum_esda = tnum_esda+TNUM_REDUNDENA;
      } 
      
      FLEsda.Tnum    = tnum_esda;
      FLEsda.Pattype = pattype;
      FLEsda.VT_type = vt_type;
      FLEsda.TCRNum  = tcrnum;
      FLEsda.TCRMode = ReadMode;
      FLEsda.UseBcc  = false;
      FLEsda.PPCorner = post;
   }  // ti_flashesdaena
   
   if (pattype == MODTYPE) {
      // +++ Module operation +++
      final_results = TM_FAIL;
      if (tistdscreenprint)  
         cout << "+++ WARNING : Invalid MemType Entered +++" << endl;
   }
   else {  // -- bank/otp/blk/sect --
      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++) {
         if ((pattype==BANKTYPE) or (pattype==OTPTYPE)) {
            blkstart = bankcount;
            blkstop  = bankcount;
            if ((pattype==OTPTYPE) and (vt_type==CHKVT0DRL)) {
               Llimit = DRLVT0_LDELTA[bankcount];
               Ulimit = DRLVT0_UDELTA[bankcount];
            } 
         }
         else if (pattype==BLOCKTYPE) {
            blkstart = 0;
            blkstop  = F021_Flash.MAXBLOCK[bankcount];
         }
         else if (pattype==QUADTYPE) {
            blkstart = 0;
            blkstop  = FL_MAX_QUADRANT;
            if (vt_type==CHKVT0DRL) {
               Llimit = DRLVT0_LDELTA[bankcount];
               Ulimit = DRLVT0_UDELTA[bankcount];
            } 
         }
         else {
            blkstart = 0;
            blkstop  = F021_Flash.MAXSECT[bankcount];
         } 

         if (     (SelectedTITestType==PreBurnIn) and (vt_type==RCODEVT0)
              and (not (F021_RunCode.DO_RUNCODE_VT0_ENA[TNI][bankcount]))) {
            if (tistdscreenprint) {
               cout << "Bank " << setw(3) << bankcount << vt_type;
               cout << " is configured as Disable !!" << endl;
            }
         }
         else {
            for (count = blkstart;count <= blkstop;count++) {
//               logsites = v_dev_active;
               tmp_results = TM_NOTEST;
               vt_values = 0V;
                
               if (pattype==OTPTYPE) {
                  if (same_vttype)  
                     vt_values = OTP_VT_VALUE[count][vt_type][hitype]-
                                      OTP_VT_VALUE[count][vt_type][lotype];
                  else
                     vt_values = OTP_VT_VALUE[count][vt_type][post]-
                                      OTP_VT_VALUE[count][previoustype][post];
                     
                  OTP_VT_DELTA_VALUE.SetValue(count,vt_type,vt_values);
               }
               
               else if (pattype==BANKTYPE) {
                  if (same_vttype)  
                     vt_values = BANK_VT_VALUE[bankcount][0][vt_type][hitype]-
                                      BANK_VT_VALUE[bankcount][0][vt_type][lotype];
                  else
                     vt_values = BANK_VT_VALUE[bankcount][0][vt_type][post]-
                                      BANK_VT_VALUE[bankcount][0][previoustype][post];
                     
                  BANK_VT_DELTA_VALUE[bankcount][0][vt_type] = vt_values;
               }
               else {
                  if (same_vttype)  
                     vt_values = BANK_VT_VALUE[bankcount][count][vt_type][hitype]-
                                      BANK_VT_VALUE[bankcount][count][vt_type][lotype];
                  else
                     vt_values = BANK_VT_VALUE[bankcount][count][vt_type][post]-
                                      BANK_VT_VALUE[bankcount][count][previoustype][post];
                     
                  BANK_VT_DELTA_VALUE[bankcount][count][vt_type] = vt_values;
               } 
               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
                  if ((vt_values[*si]<=Llimit) or (vt_values[*si]>=Ulimit)) {
                     tmp_results[*si] = TM_FAIL;

                     if ((not tmp_results[*si]) and (not datalogonly)) {
                        if(special_opt==3)  
                           GL_VT0DRL_RESULT[*si] = false;
                        if(special_opt==4)  
                           GL_VT1DRL_RESULT[*si] = false;
                     } 
                  }   // if LL/ULimit
               }   // For sites
               DLOG.AccumulateResults(final_results,tmp_results);

               // log to TW
//               tmpstr2 = CONV.IntToString(bankcount);  // Bug IntToStr can't convert zero (SPR142812)
               if ( bankcount == 0 ) tmpstr2 = "0";
               else                  tmpstr2 = CONV.IntToString(bankcount);
               tmpstr2 += "_B";  /*_B#*/

               if ((pattype==BLOCKTYPE) or (pattype==SECTTYPE) or (pattype==QUADTYPE)) {
//                tmpstr3 = CONV.IntToString(count);  // Bug IntToStr can't convert zero (SPR142812)
                  if ( count == 0 ) tmpstr3 = "0";
                  else              tmpstr3 = CONV.IntToString(count); 
                 
                  if (pattype==BLOCKTYPE)  
                     tmpstr3 = "BLK" + tmpstr3;
                  else if (pattype==QUADTYPE)  
                     tmpstr3 = "Q" + tmpstr3;
                  else
                     tmpstr3 = "S" + tmpstr3;
                     
                  tmpstr2 = tmpstr2 + tmpstr3;
               } 
               
               tmpstr3 = tmpstr1 + tmpstr2;  // now has PGMx_B#
               tmpstr4 = tmpstr3;
//               TWTRealToRealMS(vt_values,realval,unitval);
//               TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
         
               if (tistdscreenprint)  
//                  PrintResultParam(tmpstr3,0,tmp_results,LLimit,ULimit,vt_values,GL_PLELL_FORMAT);
                  cout << tmpstr3 << tmp_results << Llimit << Ulimit << vt_values << endl;
               
               // KChau 01/31/08 - added so not to log for erase stress test*/
               if (not ersstr_ena)  
//                  if(not ArrayCompareBoolean(logsites,tmp_results,v_sites)) {
                     if(not datalogonly) {
                        ;
//                        F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
                     
                        if(TI_FlashESDAEna) {
                           if((pattype==BANKTYPE) or (pattype==OTPTYPE))  
                              SetFlashESDAVars(tmp_results,bankcount,bankcount);
                           else
                              SetFlashESDAVars(tmp_results,bankcount,count);
                        } 
                     } 

                     if(TI_FlashCOFEna)
                        ;
//                        F021_Update_COF_Inst_Str(tmpstr2,site_cof_inst_str,tmp_results);
//                  } 

                /*not to disable failing site w/ ersstrvt0 type to get all banks vt*/
//               if ((not tiignorefail) and (not ersstr_ena) and
//                   (not TI_FlashCOFEna) and (not datalogonly) and (special_opt==0)) 
//                  Devsetholdstates(final_results);
               
//               if(not v_any_dev_active)  
//                  break;
            }   /*for count*/
         }   /*not VT0_DIS*/

          /*+++ Median or delta-delta +++*/
         if ((vt_type==CHKVT0DRL) and (pattype==QUADTYPE)) {
            tmp_results = TM_NOTEST;
//            logsites = v_dev_active;
            ULimit_Median = DRLVT0_Median_ULimit[bankcount];
            median_values = 1V;
            vt_val1 = 0V;
            vt_val2 = 0V;
            max_vt_med = 0V;
            
            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
               for (count = blkstart; count <= blkstop; count++)
                  tmp_delta[count] = MATH.Abs(BANK_VT_DELTA_VALUE[bankcount][count][vt_type][*si]);
               
//               ArraySortTreal(sorted_vt_delta,tmp_delta,4,s_ascending);
               median_values[*si] = (sorted_vt_delta[1]+sorted_vt_delta[2])/2;
               vt_delta[0] = MATH.Abs(sorted_vt_delta[0]-median_values[*si]);
               vt_delta[1] = MATH.Abs(sorted_vt_delta[3]-median_values[*si]);

               if((vt_delta[0] > ULimit_Median) or (vt_delta[1] > ULimit_Median))  
                  tmp_results[*si] = TM_FAIL;

               vt_val1[*si] = vt_delta[0];
               vt_val2[*si] = vt_delta[1];

               if (vt_delta[0]>=vt_delta[1])  
                  max_vt_med[*si] = vt_delta[0];
               else
                  max_vt_med[*si] = vt_delta[1];
            }  // for site

            DLOG.AccumulateResults(final_results,tmp_results);

//            tmpstr2 = CONV.IntToString(bankcount);  // Bug IntToStr can't convert zero (SPR142812)
            if ( bankcount == 0 ) tmpstr2 = "0";
            else                  tmpstr2 = CONV.IntToString(bankcount);
            tmpstr2 = "_B" + tmpstr2;
            tmpstr2 = tmpstr1 + tmpstr2;
            
            tmpstr3 = tmpstr2 + "_MEDIAN";
//            TWTRealToRealMS(median_values,realval,unitval);
//            TWPDLDataLogRealVariable(tmpstr3, unitval,realval,TWMinimumData);
//            PrintResultParam(tmpstr3,0,tmp_results,LLimit,ULimit,median_values,GL_PLELL_FORMAT);
              cout << tmpstr3 << "   " << tmp_results << "   " << Llimit;
              cout << "   " << Ulimit << "   " << median_values << endl;
//            if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//            {
//               if(not datalogonly)  
//                  F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
//            } 

            tmpstr3 = tmpstr2 + "_DLT0";
//            TWTRealToRealMS(vt_val1,realval,unitval);
//            TWPDLDataLogRealVariable(tmpstr3, unitval,realval,TWMinimumData);
//            PrintResultParam(tmpstr3,0,tmp_results,0v,ULimit_Median,vt_val1,GL_PLELL_FORMAT);
            cout << tmpstr3 << "   " << tmp_results << "   " << ULimit_Median << "   " << vt_val1 << endl;
            
            tmpstr3 = tmpstr2 + "_DLT3";
//            TWTRealToRealMS(vt_val2,realval,unitval);
//            TWPDLDataLogRealVariable(tmpstr3, unitval,realval,TWMinimumData);
//            PrintResultParam(tmpstr3,0,tmp_results,0v,ULimit_Median,vt_val2,GL_PLELL_FORMAT);
            cout << tmpstr3 << "   " << tmp_results << "   " << ULimit_Median << "   " << vt_val2 << endl;
            
            tmpstr3 = tmpstr2 + "_MAX";
//            TWTRealToRealMS(max_vt_med,realval,unitval);
//            TWPDLDataLogRealVariable(tmpstr3, unitval,realval,TWMinimumData);
//            PrintResultParam(tmpstr3,0,tmp_results,0v,ULimit_Median,max_vt_med,GL_PLELL_FORMAT);
            cout << tmpstr3 << "   " << tmp_results << "   " << ULimit_Median << "   " << max_vt_med << endl;
         }   /*Median*/
         
      }   /*for bankcount*/
   }   /*-- bank/otp/blk/sect --*/

    /*restore all active sites*/
//   Devsetholdstates(savesites);

    /*binning all vt_type except ersstrvt0*/
   if ((not ersstr_ena) and (not datalogonly))  
//      ResultsRecordActive(final_results, S_NULL);
      ;
   else
//      ResultsRecordActive(savesites, S_NULL);
      ;
      
//   TestClose;

   test_results = final_results;
   
   if (TI_FlashCOFEna)
      ;
//      F021_Save_COF_Info(tmpstr1,site_cof_inst_str,final_results);
   
//   ttimer1 = timernread(ttimer1);
   tt_timer = TIME.GetTimer();

   tmpstr4 = tmpstr1 + "_TTT";
//   TWTRealToRealMS(tt_timer,realval,unitval);
//   TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);

   if (tistdscreenprint) {
       /*PrintHeaderBool(GL_PLELL_FORMAT);*/
//      PrintResultBool(tmpstr1,0,final_results,GL_PLELL_FORMAT);
      cout << tmpstr1 << final_results << endl;
      cout << "   TT " << ttimer1 << endl;
      cout << endl;
   }         /*if tistdscreenprint*/

    /*not to disable site when doing ersstr*/
//   if ((not tiignorefail) and (not ersstr_ena) and (not TI_FlashCOFEna)
//      and (not datalogonly) and (special_opt==0))
//      DevSetHoldStates(final_results);
            
   return(final_results);
//   F021_VT_Delta_func = V_any_dev_active;
}   /*F021_VT_Delta_func*/
//   

// Save_FailInfo_To_SAMP_ACCY moved out of F021_BCC_BinSearch_TTR below
//BoolM Save_FailInfo_To_SAMP_ACCY(IntS testnum, TMResultM test_results, FloatM ivalues) {
//
//   IntS i,bank,count;
//   IntM msw_faddr,lsw_faddr;
//   IntM msw_fdata,lsw_fdata;
//   IntM msw_fdata1,lsw_fdata1;
//
//   bank = (testnum&0x000000F0) >>4;
//   count = (testnum&0x0000000F);
//   Get_TLogSpace_FAILADDR(msw_faddr,lsw_faddr);
//   Get_TLogSpace_FAILDATA(msw_fdata,lsw_fdata);    // port0
//   Get_TLogSpace_MeasFreq(msw_fdata1,lsw_fdata1);  // port1
//   for (i = 1;i <= v_sites;i++) {
//      FL_SAMP_ACCY_VT[bank][count][i] = ivalues[i];
//      FL_SAMP_ACCY_VT_FADDR_MSW[bank][count][i] = msw_faddr[i];
//      FL_SAMP_ACCY_VT_FADDR_LSW[bank][count][i] = lsw_faddr[i];
//      FL_SAMP_ACCY_VT_FDATA_MSW[bank][count][i] = msw_fdata[i];
//      FL_SAMP_ACCY_VT_FDATA_LSW[bank][count][i] = lsw_fdata[i];
//      FL_SAMP_ACCY_VT_FDATA1_MSW[bank][count][i] = msw_fdata1[i];
//      FL_SAMP_ACCY_VT_FDATA1_LSW[bank][count][i] = lsw_fdata1[i];
//      if(tistdscreenprint and TI_FlashDebug)  
//      {
//         cout << "Site" << i:-5 << " FL_SAMP_ACCY_VT["][bank:-2]["][ "][count:-2]["] == " << ivalues[i] << endl;
//         cout << " ":-9 << " FL_SAMP_ACCY_VT_FADDR MSW/LSW == " << msw_faddr[i]:s_hex:-7 << " " << lsw_faddr[i]:s_hex:-7 << endl;
//         cout << " ":-9 << " FL_SAMP_ACCY_VT_FDATA MSW/LSW == " << msw_fdata[i]:s_hex:-7 << " " << lsw_fdata[i]:s_hex:-7 << endl;
//         cout << " ":-9 << " FL_SAMP_ACCY_VT_FDATA1 MSW/LSW == " << msw_fdata1[site]:s_hex:-7 << " " << lsw_fdata1[i]:s_hex:-7 << endl;
//      }
//   }
//}   // Save_FailInfo_To_SAMP_ACCY
   
// Returned value if no converge:
// both passed : return 1ua, both failed : return 0ua
void F021_BCC_BinSearch_TTR (    IntS   testnum,
                                 FloatM Istart,
                                 FloatM Istop,
                                 FloatS Iresolution,
                                 FloatM VforceArr,
                                 FloatS maxtime,
                                 FloatM ret_timer,
                                 FloatM ret_values) {
                                 
   enum OperatorType { OPER_TCR6 = 0x1, OPER_TCR39 = 0x2, OPER_TCR38 = 0x3 };
   
//   const IntS OPER_TCR6 = 0x1; 
//   const IntS OPER_TCR39 = 0x2; 
//   const IntS OPER_TCR38 = 0x3; 

   BoolM savestates,activestates,logsites;
   BoolM min_results,max_results;
   BoolM mid_results;
   FloatM Ipass,Ifail,Imid;
   FloatM vforce;
   IntS site,opertype,tdata;
   FloatM tt_timer;
   FloatM cg_irange,cg_vrange;
   BoolS debugprint,savesupdelay;
   BoolS save_printpass,save_scrnprint;
   FloatS maxtimeout,tdelay,ttimer1;
   FloatM prevstart,prevstop,vProg;
   BoolS sameness,firstcnt,tg_ena;
   PinM tsupply,tp_cg;
//   option vdd_pgmMode,vdd_iGMode;
   FloatS vdd_iProg;

   if(tistdscreenprint and TI_FlashDebug)  
      cout << "Binary Search BCC TTR ..." << endl;
   
   debugprint = TI_FlashDebug and tiprintpass;
   save_printpass = tiprintpass;
   save_scrnprint = tistdscreenprint;
//   savesupdelay = v_no_supplyset_delay;

   if(not debugprint) {
      tistdscreenprint = false;
      tiprintpass = false;
   } 


   // pbist tnum type
   if ( (testnum & IntS(0xf0000000)) == IntS(0xB0000000) ) {
      if ( IntS((testnum & 0x000f0000)) == IntS(0x00050000) )  
         opertype = OPER_TCR38;
      else
         opertype = OPER_TCR6;
   }
   else
      opertype = ((testnum&0x03000000) >>24) & 0x3;

   switch (opertype) {
     case OPER_TCR6  :  
        tsupply = FLTP2;
        tp_cg   = FLTP1;
        tg_ena  = true;
        break; 
     case OPER_TCR38 :  
        tsupply = FLTP1;
        tg_ena  = false;
        break; 
     case OPER_TCR39 :  
        tsupply = FLTP1;
        tp_cg   = FLTP2;
        tg_ena  = true;
        break; 
   }   // case

    /*tdata := ((testnum&0x0000f000) >>12) & 0xf;*/

   cg_irange = 100mA;

//   timernstart(ttimer1);
   TIME.StartTimer();
   
   tdelay = 5ms;  /*50ms;*/
   maxtimeout = maxtime;

   sameness = true;
   firstcnt = true;


   if (firstcnt) {
      prevstart = Istart;
      prevstop  = Istop;
      firstcnt  = false;
   }
   else if ((Istart !=prevstart) or (Istop !=prevstop)) {
      sameness = false;
   }

   min_results = false;
   max_results = false;
   Imid = 0uA;
   Ipass = 0uA;
   Ifail = 0uA;

//   savestates = v_dev_active;
//   activestates = v_dev_active;
//   logsites = v_dev_active;

//   v_no_supplyset_delay = true;

   if(tg_ena) {
      cg_vrange = VforceArr;
//      STDSetVRange(tp_cg,cg_vrange);
//      STDSetVI(tp_cg,cg_vrange,cg_irange);
   } 

   vProg = 2.5V;  // iref vrng
//   STDSetVRange(tsupply,vProg);
   
   if(TI_FlashDebug and save_scrnprint)  
   {
      tistdscreenprint = true;
      switch(opertype) {
        case OPER_TCR6  :  
           cout << "TP1(CG) @ " << cg_vrange << " " << cg_irange << "  TP2(Iref) @ " << vProg << endl;
           break; 
        case OPER_TCR38 :  
           cout << "TP1(Iref) @ " << vProg << endl;
           break; 
        case OPER_TCR39 :  
           cout << "TP2(CG) @ " << cg_vrange << " " << cg_irange << "  TP1(Iref) @ " << vProg << endl;
            break; 
      }   // case
      if(not debugprint)  
         tistdscreenprint = false;
   } 

   if(not sameness) {
      ;
//      STDSetVI(tsupply,vProg,Istart);
   }
   else {
      ;
//      STDSetVI(tsupply,vProg,prevstart);
   } 
      
   TIME.Wait(tdelay);
   if(GL_DO_BCCVT_RCODE_ENA)  
      MBox_Upload_RCODE_PSA(GL_DO_BCCVT_RCODE_BANK,Random);
      
   F021_RunTestNumber(testnum,maxtime,tt_timer);

//   if(tistdscreenprint and debugprint)  
//   {
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(activestates[site])  
//            if(min_results[site])  
//               cout << "Site " << site:3 << "  passed @ " << Istart[site]);
//            else
//               cout << "Site " << site:3 << "  failed @ " << Istart[site] << endl;
//   } 

//   if(GL_DO_CHARZ_SAMP_ACCY and GL_DO_SAVE_SAMP_ACCY_DATA)  
//      if(not arraycompareboolean(logsites,min_results,v_sites))  
//          Save_FailInfo_To_SAMP_ACCY(min_results,Istart);

   if (not sameness) {
      ;
//      STDSetVI(tsupply,vProg,Istop[site]);
   }
   else {
      ;
//      STDSetVI(tsupply,vProg,prevstop);
   } 
      
   TIME.Wait(tdelay);
   if(GL_DO_BCCVT_RCODE_ENA)  
      MBox_Upload_RCODE_PSA(GL_DO_BCCVT_RCODE_BANK,Random);
   F021_RunTestNumber(testnum,maxtime,tt_timer);

//   if(tistdscreenprint and debugprint)  
//   {
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(activestates[site])  
//            if(max_results[site])  
//               cout << "Site " << site:3 << "  passed @ " << Istop[site]);
//            else
//               cout << "Site " << site:3 << "  failed @ " << Istop[site] << endl;
//   } 
   
//   if(GL_DO_CHARZ_SAMP_ACCY and GL_DO_SAVE_SAMP_ACCY_DATA)  
//      if(not arraycompareboolean(logsites,max_results,v_sites))  
//         Save_FailInfo_To_SAMP_ACCY(max_results,Istop);

//   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//   {
//      if v_dev_active[site]  
//      {
//         if((min_results[site] and max_results[site]) or
//            ((not min_results[site]) and (not max_results[site])))  
//         {
//            ret_timer[site] = timernread(ttimer1);
//            
//            if(min_results[site] and max_results[site])  
//            {
//                /*if(tdata=0) then
//                   Ipass[site] := 5ua
//                else*/
//                  Ipass[site] = 1uA;   /*default invalid value if both passed*/
//               if(save_scrnprint)  
//               {
//                  tistdscreenprint=true;
//                  cout << "Site " << site:3 << " Passing both Currents. " << 
//                          Istart[site] << "  " << Istop[site] << "  not converged!!!";
//                  cout << "  DISABLED " << endl;
//               } 
//            }
//            else
//            {
//               if(save_scrnprint)  
//               {
//                  tistdscreenprint=true;
//                  cout << "Site " << site:3 << " Failing both Currents. " << 
//                          Istart[site] << "  " << Istop[site] << "  not converged!!!";
//                  cout << "  DISABLED " << endl;
//               } 
//            } 
//
//            if(save_scrnprint and (not debugprint))  
//               tistdscreenprint=false;
//
//            activestates[site] = false;
//            devsetholdstate(site,false);  /*disable site*/
//         }
//         else
//         {
//            if(min_results[site])  
//            { 
//               Ipass[site] = Istart[site];
//               Ifail[site] = Istop[site];
//            }
//            else
//            { 
//               Ipass[site] = Istop[site];
//               Ifail[site] = Istart[site];
//            } 
//            Imid[site] = (Ipass[site]+Ifail[site])/2;
//         } 
//      }   /*if v_dev_active*/
//   }   /*for site*/

//   while(v_any_dev_active) do
//   {
//      logsites = v_dev_active;
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      {
//         if(activestates[site])  
//         {
//            STDSetVI(tsupply,vProg,Imid[site]);
//            devsetholdstate(site,false);
//         }   /*activestates*/
//      }   /*for site*/
//
//      devsetholdstates(activestates);
//      TIME.Wait(tdelay);
//      if(GL_DO_BCCVT_RCODE_ENA)  
//         MBox_Upload_RCODE_PSA(GL_DO_BCCVT_RCODE_BANK,Random);
//      F021_RunTestNumber(testnum,maxtime,tt_timer,mid_results);
//
//      if(GL_DO_CHARZ_SAMP_ACCY and GL_DO_SAVE_SAMP_ACCY_DATA)  
//         if(not arraycompareboolean(logsites,mid_results,v_sites))  
//            Save_FailInfo_To_SAMP_ACCY(mid_results,Imid);
//
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      {
//         if(activestates[site])  
//         {
//            if(mid_results[site])  
//            {
//               Ipass[site] = Imid[site];
//               if(tistdscreenprint and debugprint)  
//                  cout << "Site " << site:3 << "  passed @ " << Imid[site] << endl;
//            }
//            else
//            {
//               Ifail[site] = Imid[site];
//               if(tistdscreenprint and debugprint)  
//                  cout << "Site " << site:3 << "  failed @ " << Imid[site] << endl;
//            } 
//
//             /*continue searching*/
//            if(abs(Ipass[site]-Ifail[site])>Iresolution)  
//               Imid[site] = (Ipass[site]+Ifail[site])/2;
//            else
//            {  /*done searching*/
//               ret_timer[site] = timernread(ttimer1);
//               activestates[site] = false;
//            } 
//         }   /*if activestates*/
//      }   /*for site*/
//
//      devsetholdstates(activestates);
//   }   /*while*/

    /*re-activate all incoming sites*/
//   devsetholdstates(savestates);
   ret_values = Ipass;

   F021_TurnOff_AllTPADS();
   TIME.Wait(tdelay);

   tiprintpass = save_printpass;
   tistdscreenprint = save_scrnprint;
//   v_no_supplyset_delay = savesupdelay;

   if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
   {
      cout << "F021_BCC_BinSearch TTR :  " << endl;
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(savestates[site])  
//            cout << "site " << site:5 << "  " << Ipass[site]:5:3 << "  " << endl;
//      cout << "TT == " << timernread(ttimer1) << endl;
   } 

}   // F021_BCC_BinSearch_TTR


TMResultM TL_Run_BCCVT (StringS       tname,
                        vttype        vt_type,
                        prepostcorner prepost_type,
                        BoolS         IsMainArray,
                        BoolS         IsBcc,
                        StringS       logstr) {
                        
   const IntS TCR39 = 39; 

   BoolM savesites,logsites;
   TMResultM final_results, tmp_results;
   IntS site,bank,sblk,eblk,count,i,j;
   IntS start_tnum,testnum,pattype,tcrnum;
   TPModeType tcrmode;
   FloatS resol,maxtime;
   FloatM tt_timer;
   FloatS ttimer1,ttimer2;
   StringS str1,str2,str3,str4,str5;
   prepostcorner prepost;
   FloatM vt_values,vt_intvalues;
   FloatS Llimit,Ulimit;
   FloatM FloatSval;
   StringS unitval;
   FloatM startArr,stopArr,forceArr;
   BoolS logena,datalogonly,do_ena,pbistred;
   BoolS save_printpass,do_ena_red,useminval;
   IntS special_opt,miniter,maxiter,iter;
   StringM site_cof_inst_str;
   IntS tnum_esda;
   BoolS use_pbist_equiv,internal_ena;
   IntS minbank,maxbank,iratio;
   
   if(tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ F021_BCCVT_func +++++" << endl;
      
   save_printpass = tiprintpass;

   if(not TI_FlashDebug)  
      tiprintpass = false;

   prepost = prepost_type;
   tcrmode = ReadMode;

   do_ena = false;
   datalogonly = false;
   use_pbist_equiv = false;
   internal_ena = false;

   TIME.StartTimer();

   if (IsMainArray) {
      if (IsBcc) {
         do_ena = MainBCC.ENA[vt_type][prepost];
         datalogonly = MainBCC.DLOGONLY[vt_type][prepost];
      }
      else {
         do_ena = MainVT.ENA[vt_type][prepost];
         datalogonly = MainVT.DLOGONLY[vt_type][prepost];
      } 
   }
   else { // +++ OTP +++
      if (IsBcc) {
         do_ena = OtpBCC.ENA[vt_type][prepost];
         datalogonly = OtpBCC.DLOGONLY[vt_type][prepost];
      }
      else {
         do_ena = OtpVT.ENA[vt_type][prepost];
         datalogonly = OtpVT.DLOGONLY[vt_type][prepost];
      } 
   } 

   if (tname=="") {
      datalogonly = true;
      if (not do_ena)  
         do_ena = true;   // always run if null_testname
      if (logstr=="") {
         if (IsMainArray)  
            str1 = "MAIN_";
         else
            str1 = "OTP_";
         logena = false;  // no tw log
      }
      else {
         str1 = logstr;
         logena = true;
      } 
   }
   else {
      logena = true;
      str1 = tname;   // using tname for tw & ignore logstr
      str1.Replace(str1.Find("_Test"), 5, "");   // remove _Test
   } 

   if (do_ena) {

      str2 = "";
      maxtime = GL_F021_BANK_VT_MAXTIME;

      // added special option so not to disable site for drl
      switch (vt_type) {
        case CHKVT0DRL : special_opt = 3; break;
        case CHKVT1DRL : special_opt = 4; break;
        case RCODEVT0  : 
        case RCODEVT1  : special_opt = 5; break;
        default        : special_opt = 0; break;
      }

      // use for re-assign bank/blk/sect value if doing pbist and redund
      switch (vt_type) {
         case  CHKVT0: 
         case  CHKVT0DRL:
         case  ONOVT0:
         case  CSFGVT0:
         case  EGFG1VT0:
         case  EGFG2VT0:
         case  EGFG3VT0:
         case  EGFG4VT0:
         case  EGFG5VT0:
         case  RDDISTBVT0:
         case  RDDISTB2VT0:
         case  RCODEVT0:   
            if (IsBcc) { 
               str2 = "BCC0_";
               useminval = false;
            }
            else {
               str2 = "VT0_";
               useminval = true;
            }
            break; 
         default :  
            if (IsBcc) {
               str2 = "BCC1_";
               useminval = true;
            }
            else {
               str2 = "VT1_";
               useminval = false;
            }
            break; 
      }   // case
         
       // ********  MAIN ARRAY  ********
      if (IsMainArray) {
         // ===== IsBcc IsMainArray=====
         if (IsBcc) {
            Llimit     = MainBCC.LLIM[vt_type][prepost];
            Ulimit     = MainBCC.ULIM[vt_type][prepost];
            startArr   = MainBCC.SSTART[vt_type][prepost];
            stopArr    = MainBCC.SSTOP[vt_type][prepost];
            resol      = MainBCC.SRESOL[vt_type][prepost];
            iratio     = MainBCC.IRATIO[vt_type][prepost];
            tcrnum     = MainBCC.TCRNUM[vt_type][prepost];
            do_ena_red = MainBCC.ENARED[vt_type][prepost];
            pattype    = MainBCC.MEMCFG[vt_type];

            if (tcrnum!=TCR39)  
               forceArr = TCR.TP1_VRange[tcrnum][tcrmode];
            else
               forceArr = TCR.TP2_VRange[tcrnum][tcrmode];

            if (GL_DO_BCC_MAIN_USING_PBIST) {
               use_pbist_equiv = true;  // for esda nonpbist tnum
               switch(vt_type) {
                 case  CHKVT0:
                 case  CHKVT0DRL:
                 case  RCODEVT0 :   
                    start_tnum = (IntS(TNUM_PBIST_BCC0S))+MainBCC.TDATA[vt_type];
                    if (GL_DO_MASK_1S_BCC0_DRL_PBIST)  
                       start_tnum = start_tnum+TNUM_PBIST_MASK1S;
                    break; 
                 case  CHKVT1:
                 case  CHKVT1DRL:
                 case  RCODEVT1 :   
                    start_tnum = TNUM_PBIST_BCC1S & (IntS(0xffff0fff)) +MainBCC.TDATA[vt_type];
                    break; 
                 case REVTUNVT1:
                 case PGMFFVT1:
                 case PUNTHRUVT1:
                 case FGWLVT1:
                 case TUNOXTSMCVT1:
                 case TUNOXVT1:
                 case THINOXVT1:
                    start_tnum = TNUM_PBIST_BCC1S;
                    break; 
                 case  ONOVT0:
                 case  CSFGVT0:
                 case  EGFG1VT0:
                 case  EGFG2VT0:
                 case  EGFG3VT0:
                 case  EGFG4VT0:
                 case  EGFG5VT0:
                 case  RDDISTBVT0:
                 case  RDDISTB2VT0: 
                    start_tnum = TNUM_PBIST_BCC0S;
                    break; 
               }   // case
               miniter = 1;
               if (do_ena_red)  
                  maxiter = miniter+1;
               else
                  maxiter = miniter;
            }  // using_pbist
            else {
               switch (tcrnum) {
                 case 5  : start_tnum = TNUM_TCR5;  break;
                 case 6  : start_tnum = TNUM_TCR6;  break;
                 case 38 : start_tnum = TNUM_TCR38; break;
                 default : start_tnum = TNUM_TCR39; break;
               }   // case

               start_tnum = start_tnum + MainBCC.IRATIO[vt_type][prepost] + MainBCC.TDATA[vt_type] + MainBCC.RDOPTION[vt_type][prepost];
               if (do_ena_red)  
                  start_tnum = start_tnum+TNUM_REDUNDENA;

               switch(vt_type) {
                  case  CHKVT0:
                  case  CHKVT0DRL:
                  case  RCODEVT0 : 
                     if (GL_DO_MASK_1S_BCC0_DRL_PBIST)  
                        start_tnum = start_tnum+TNUM_PBIST_MASK1S;
                     break;
               }   // case

               miniter = 1;
               maxiter = miniter;
            }   // using nonpbist

            if(MainBCC.MEMCFG[vt_type]==SECTTYPE) {
               start_tnum = start_tnum+TNUM_TARGET_SECT;
               pattype = SECTTYPE;
            }
            else if(MainBCC.MEMCFG[vt_type]==BLOCKTYPE) {
               start_tnum = start_tnum+TNUM_TARGET_BLOCK;
               pattype = BLOCKTYPE;
            }
            else if(MainBCC.MEMCFG[vt_type]==QUADTYPE) {
               start_tnum = start_tnum+TNUM_TARGET_QUAD;
               pattype = QUADTYPE;
            }
            else if(MainBCC.MEMCFG[vt_type]==ARBTYPE) {
               start_tnum = start_tnum+TNUM_TARGET_ARB;
               pattype = BANKTYPE;
            }
            else
               pattype = BANKTYPE;
            
            // internal bcc1 only
            if (GL_DO_BCC_USING_INTERNAL and str2.Find("1") >= 0 ) {
               internal_ena = true;
               start_tnum = TNUM_TCR72+TNUM_BIDI_VT+MainBCC.TDATA[vt_type];
               if (do_ena_red)  
                  start_tnum = start_tnum+TNUM_REDUNDENA;
               if (pattype==SECTTYPE)  
                  start_tnum = start_tnum+TNUM_TARGET_SECT;
               else if(pattype==BLOCKTYPE)  
                  start_tnum = start_tnum+TNUM_TARGET_BLOCK;
               else if(pattype==QUADTYPE)  
                  start_tnum = start_tnum+TNUM_TARGET_QUAD;
               else if(pattype==ARBTYPE)  
                  start_tnum = start_tnum+TNUM_TARGET_ARB;
            }   
         }  // ===== IsBcc IsMainArray=====
         else {
            // ===== VT IsMainArray=====
            Llimit     = MainVT.LLIM[vt_type][prepost];
            Ulimit     = MainVT.ULIM[vt_type][prepost];
            startArr   = MainVT.SSTART[vt_type][prepost];
            stopArr    =  MainVT.SSTOP[vt_type][prepost];
            resol      = MainVT.SRESOL[vt_type][prepost];
            iratio     = MainVT.IRATIO[vt_type][prepost];
            tcrnum     = MainVT.TCRNUM[vt_type][prepost];
            do_ena_red = MainVT.ENARED[vt_type][prepost];
            forceArr   = 20uA;
   
            if(GL_DO_VT_MAIN_USING_PBIST) {
               use_pbist_equiv = true;  // for esda nonpbist tnum
               if(GL_DO_VT_USING_INTERNAL)  
                  internal_ena = true;
               switch(vt_type) {
                  case  CHKVT0:
                  case  CHKVT0DRL:
                  case  RCODEVT0 :   
                     if (GL_DO_VT_USING_INTERNAL)  
                        start_tnum = TNUM_PBIST_IVT0S+MainVT.TDATA[vt_type];
                     else
                        start_tnum = TNUM_PBIST_VT0S+MainVT.TDATA[vt_type];
                     break; 
                  case  CHKVT1:
                  case  CHKVT1DRL:
                  case  RCODEVT1:   
                     start_tnum = TNUM_PBIST_VT1S & (IntS(0xffff0fff)) +MainVT.TDATA[vt_type];
                     break; 
                  case REVTUNVT1:
                  case PGMFFVT1:
                  case PUNTHRUVT1:
                  case FGWLVT1:
                  case TUNOXTSMCVT1:
                  case TUNOXVT1:
                  case THINOXVT1:  
                     start_tnum = TNUM_PBIST_VT1S;
                     break; 
                  case  ONOVT0:
                  case  CSFGVT0:
                  case  EGFG1VT0:
                  case  EGFG2VT0:
                  case  EGFG3VT0:
                  case  EGFG4VT0:
                  case  EGFG5VT0:
                  case  RDDISTBVT0:
                  case  RDDISTB2VT0: 
                     if (GL_DO_VT_USING_INTERNAL)  
                        start_tnum = TNUM_PBIST_IVT0S;
                     else
                        start_tnum = TNUM_PBIST_VT0S;
                     break; 
               }   // case
               miniter = 1;
               if (do_ena_red)  
                  maxiter = miniter+1;
               else
                  maxiter = miniter;
            }  // using_pbist
            else {
               switch(tcrnum) {
                 case 5  : start_tnum = TNUM_TCR5;  break;
                 case 6  : start_tnum = TNUM_TCR6;  break;
                 case 38 : start_tnum = TNUM_TCR38; break;
                 default : start_tnum = TNUM_TCR39; break;
               }   // case
               
               start_tnum = start_tnum + MainVT.IRATIO[vt_type][prepost] + MainVT.TDATA[vt_type] + MainVT.RDOPTION[vt_type][prepost];
               if(GL_DO_VT_USING_BIDI and (not GL_DO_VT_USING_INTERNAL))  
                  start_tnum = start_tnum+TNUM_BIDI_VT;
               if(do_ena_red)  
                  start_tnum = start_tnum+TNUM_REDUNDENA;

               // internal vt0 only
               if (GL_DO_VT_USING_INTERNAL and (str2.Find("0") >= 0) ) {
                  internal_ena = true;
                  start_tnum = TNUM_TCR72 + MainVT.TDATA[vt_type];  // + MainVT.RDOPTION[vt_type,prepost];
                  if (do_ena_red)  
                     start_tnum = start_tnum+TNUM_REDUNDENA;
               } 
               
               miniter = 1;
               maxiter = miniter;
            }   // nonpbist

            if(MainVT.MEMCFG[vt_type]==SECTTYPE) {
               start_tnum = start_tnum+TNUM_TARGET_SECT;
               pattype = SECTTYPE;
            }
            else if(MainVT.MEMCFG[vt_type]==BLOCKTYPE) {
               start_tnum = start_tnum+TNUM_TARGET_BLOCK;
               pattype = BLOCKTYPE;
            }
            else if(MainVT.MEMCFG[vt_type]==QUADTYPE) {
               start_tnum = start_tnum+TNUM_TARGET_QUAD;
               pattype = QUADTYPE;
            }
            else if (MainVT.MEMCFG[vt_type]==ARBTYPE) {
               start_tnum = start_tnum+TNUM_TARGET_ARB;
               pattype = ARBTYPE;
            }
            else
               pattype = BANKTYPE;

         }   // ===== VT IsMainArray =====
      }   // ++++ MainArrary +++++
      
      // ********  OTP ARRAY  ********
      else {   //=====  OTP  =====
         pattype = OTPTYPE;
         do_ena_red = false;
         miniter = 1;
         maxiter = miniter;

         if (IsBcc) {
            Llimit = OtpBCC.LLIM[vt_type][prepost];
            Ulimit = OtpBCC.ULIM[vt_type][prepost];
            startArr = OtpBCC.SSTART[vt_type][prepost];
            stopArr =  OtpBCC.SSTOP[vt_type][prepost];
            resol = OtpBCC.SRESOL[vt_type][prepost];
            iratio = OtpBCC.IRATIO[vt_type][prepost];
            tcrnum = OtpBCC.TCRNUM[vt_type][prepost];

            if (tcrnum!=TCR39)  
               forceArr = TCR.TP1_VRange[tcrnum][tcrmode];
            else
               forceArr = TCR.TP2_VRange[tcrnum][tcrmode];
               
            if (GL_DO_BCC_OTP_USING_PBIST) {
               use_pbist_equiv = true;  // for esda nonpbist tnum
               switch(vt_type) {
                 case  CHKVT0:
                 case  CHKVT0DRL:
                 case  RCODEVT0 :   
                    start_tnum = TNUM_PBIST_BCC0S+OtpBCC.TDATA[vt_type];
                    if (GL_DO_MASK_1S_BCC0_DRL_PBIST)  
                       start_tnum = start_tnum+TNUM_PBIST_MASK1S;
                    break; 
                 case  CHKVT1:
                 case  CHKVT1DRL:
                 case  RCODEVT1 :   
                    start_tnum = TNUM_PBIST_BCC1S & (IntS(0xffff0fff)) +OtpBCC.TDATA[vt_type];
                    break; 
                 case REVTUNVT1:
                 case PGMFFVT1:
                 case PUNTHRUVT1:
                 case FGWLVT1:
                 case TUNOXTSMCVT1:
                 case TUNOXVT1:
                 case THINOXVT1: 
                    start_tnum = TNUM_PBIST_BCC1S & (IntS(0xffff0fff)) +OtpBCC.TDATA[vt_type];
                    break; 
                 case  ONOVT0:
                 case  CSFGVT0:
                 case  EGFG1VT0:
                 case  EGFG2VT0:
                 case  EGFG3VT0:
                 case  EGFG4VT0:
                 case  EGFG5VT0:
                 case  RDDISTBVT0:
                 case  RDDISTB2VT0:  
                    start_tnum = TNUM_PBIST_BCC0S+OtpBCC.TDATA[vt_type];
                    break; 
               }   // case
            }  // using_pbist
            else {
               switch (tcrnum) {
                 case  5 : start_tnum = TNUM_TCR5;  break;
                 case  6 : start_tnum = TNUM_TCR6;  break;
                 case 38 : start_tnum = TNUM_TCR38; break;
                 default : start_tnum = TNUM_TCR39; break;
               }   // case
               
               start_tnum = start_tnum+OtpBCC.IRATIO[vt_type][prepost]+
                             OtpBCC.RDOPTION[vt_type][prepost]+OtpBCC.TDATA[vt_type];
               switch (vt_type) {
                 case  CHKVT0:
                 case  CHKVT0DRL:
                 case  RCODEVT0 : 
                    if (GL_DO_MASK_1S_BCC0_DRL_PBIST)  
                       start_tnum = start_tnum+TNUM_PBIST_MASK1S;
               }   // case
            }   // using nonpbist

             // internal bcc1 only
            if (GL_DO_BCC_USING_INTERNAL and str2.Find("1") >= 0 ) {
               internal_ena = true;
               start_tnum = TNUM_TCR72+TNUM_BIDI_VT+OtpBCC.TDATA[vt_type];
            } 
            
         }  // ===== IsBcc OTP =====
         else {   // +++ VT +++
            Llimit   = OtpVT.LLIM[vt_type][prepost];
            Ulimit   = OtpVT.ULIM[vt_type][prepost];
            startArr = OtpVT.SSTART[vt_type][prepost];
            stopArr  =  OtpVT.SSTOP[vt_type][prepost];
            resol    = OtpVT.SRESOL[vt_type][prepost];
            iratio   = OtpVT.IRATIO[vt_type][prepost];
            tcrnum   = OtpVT.TCRNUM[vt_type][prepost];
            forceArr = 20uA;
      
            if (GL_DO_VT_OTP_USING_PBIST) {
               use_pbist_equiv = true;  // for esda nonpbist tnum
               if (GL_DO_VT_USING_INTERNAL)  
                  internal_ena = true;
               switch (vt_type) {
                 case  CHKVT0:
                 case  CHKVT0DRL:
                 case  RCODEVT0 :   
                    if (GL_DO_VT_USING_INTERNAL)  
                       start_tnum = TNUM_PBIST_IVT0S+OtpVT.TDATA[vt_type];
                    else
                       start_tnum = TNUM_PBIST_VT0S+OtpVT.TDATA[vt_type];
                    break; 
                 case  CHKVT1:
                 case  CHKVT1DRL:
                 case  RCODEVT1 :   
                    start_tnum = TNUM_PBIST_VT1S & (IntS(0xffff0fff)) +OtpVT.TDATA[vt_type];
                    break; 
                 case REVTUNVT1:
                 case PGMFFVT1:
                 case PUNTHRUVT1:
                 case FGWLVT1:
                 case TUNOXTSMCVT1:
                 case TUNOXVT1:
                 case THINOXVT1:  
                    start_tnum = TNUM_PBIST_VT1S & (IntS(0xffff0fff)) +OtpVT.TDATA[vt_type];
                    break; 
                 case  ONOVT0:
                 case  CSFGVT0:
                 case  EGFG1VT0:
                 case  EGFG2VT0:
                 case  EGFG3VT0:
                 case  EGFG4VT0:
                 case  EGFG5VT0:
                 case  RDDISTBVT0:
                 case  RDDISTB2VT0:  
                    if (GL_DO_VT_USING_INTERNAL)  
                       start_tnum = TNUM_PBIST_IVT0S+OtpVT.TDATA[vt_type];
                    else
                       start_tnum = TNUM_PBIST_VT0S+OtpVT.TDATA[vt_type];
                    break; 
               }   // case
            }  // using_pbist
            else {
               switch (tcrnum) {
                 case 5  : start_tnum = TNUM_TCR5;
                 case 6  : start_tnum = TNUM_TCR6;
                 case 38 : start_tnum = TNUM_TCR38;
                 default : start_tnum = TNUM_TCR39;
               }   // case
               
               start_tnum = start_tnum+OtpVT.IRATIO[vt_type][prepost]+OtpVT.RDOPTION[vt_type][prepost]+OtpVT.TDATA[vt_type];
               if (GL_DO_VT_USING_BIDI and (not GL_DO_VT_USING_INTERNAL))  
                  start_tnum = start_tnum+TNUM_BIDI_VT;

               if (GL_DO_VT_USING_INTERNAL and str2.Find("0") >= 0 ) {
                  internal_ena = true;
                  start_tnum = TNUM_TCR72 + OtpVT.TDATA[vt_type];
               } 
            }   // nonpbist
         }   // ===== VT OTP =====
      }     // =====  OTP  =====

      if (TI_FlashESDAEna) {
         if (use_pbist_equiv or internal_ena) {
            switch (tcrnum) {
              case 5  : tnum_esda = TNUM_TCR5;  break;
              case 6  : tnum_esda = TNUM_TCR6;  break;
              case 38 : tnum_esda = TNUM_TCR38; break;
              default : tnum_esda = TNUM_TCR39; break;
            }   // case

            if( pattype==OTPTYPE) {
               if (IsBcc)  
                  tnum_esda = tnum_esda+OtpBCC.IRATIO[vt_type][prepost]+OtpBCC.RDOPTION[vt_type][prepost]+OtpBCC.TDATA[vt_type];
               else
                  tnum_esda = tnum_esda+OtpVT.IRATIO[vt_type][prepost]+OtpVT.RDOPTION[vt_type][prepost]+OtpVT.TDATA[vt_type];
            }
            else {
               if (IsBcc) {
                  tnum_esda = tnum_esda + MainBCC.IRATIO[vt_type][prepost] + MainBCC.TDATA[vt_type] + MainBCC.RDOPTION[vt_type][prepost];
                  if (MainBCC.MEMCFG[vt_type]==SECTTYPE)  
                     tnum_esda = tnum_esda + TNUM_TARGET_SECT;
                  else if (MainBCC.MEMCFG[vt_type]==BLOCKTYPE)  
                     tnum_esda = tnum_esda + TNUM_TARGET_BLOCK;
                  else if (MainBCC.MEMCFG[vt_type]==QUADTYPE)  
                     tnum_esda = tnum_esda + TNUM_TARGET_QUAD;
               }
               else {
                  tnum_esda = tnum_esda + MainVT.IRATIO[vt_type][prepost] + MainVT.TDATA[vt_type] + MainVT.RDOPTION[vt_type][prepost];
                  if (MainVT.MEMCFG[vt_type]==SECTTYPE)  
                     tnum_esda = tnum_esda + TNUM_TARGET_SECT;
                  else if (MainVT.MEMCFG[vt_type]==BLOCKTYPE)  
                     tnum_esda = tnum_esda + TNUM_TARGET_BLOCK;
                  else if (MainVT.MEMCFG[vt_type]==QUADTYPE)  
                     tnum_esda = tnum_esda + TNUM_TARGET_QUAD;
               } 
               
               if(do_ena_red)  
                  tnum_esda = tnum_esda+TNUM_REDUNDENA;
            }   /*if-else pattype*/
         }   /*if use_pbist_equiv*/
         
         FLEsda.Tnum    = tnum_esda;
         FLEsda.Pattype = pattype;
         FLEsda.VT_type = vt_type;
         FLEsda.TCRNum  = tcrnum;
         FLEsda.TCRMode = ReadMode;
         FLEsda.PPCorner = prepost;
         FLEsda.UseBcc  = IsBcc;
      }   // TI_FlashESDAEna
                  
      if ((logstr=="") and (tname==""))  
         str1 = str1 + str2;

      // KChau 05/19/11 - removed previous code that do VT for data collection on last bank only as switch
      //                  to using VT instead of BCC and added BCC0 data collection on last bank instead
      if ((IsBcc) and ((vt_type==CHKVT0) or (vt_type==CHKVT0DRL) or (vt_type==EGFG4VT0))) {
         minbank = F021_Flash.MAXBANK;
         maxbank = F021_Flash.MAXBANK;
      }
      else {
         minbank= 0;
         maxbank=F021_Flash.MAXBANK;
      } 
      
      for (bank = minbank; bank <= maxbank; ++bank) {
         switch (vt_type) {
            case RCODEVT0 :
               if (F021_RunCode.DO_RUNCODE_VT0_ENA[Random][bank]) {
                  sblk = bank;
                  eblk = bank;
               }
               else {
                  sblk = bank;
                  eblk = -1;
               }
               break; 
            case RCODEVT1 :
               if (F021_RunCode.DO_RUNCODE_VT1_ENA[Random][bank]) {
                  sblk = bank;
                  eblk = bank;
               }
               else {
                  sblk = bank;
                  eblk = -1;
               }   
               break; 
            default:
               if ((pattype==BANKTYPE) or (pattype==OTPTYPE)) {
                  sblk = bank;
                  eblk = bank;
               }
               else if (pattype==BLOCKTYPE) {
                  sblk = 0;
                  eblk = F021_Flash.MAXBLOCK[bank];
               }
               else if (pattype==QUADTYPE) { 
                  sblk = 0;
                  eblk = FL_MAX_QUADRANT;
               }
               else {
                  sblk = 0;
                  eblk = F021_Flash.MAXSECT[bank];
               }
               break; 
         }   //  case
         
         testnum = start_tnum+(bank<<4);
         
         if (F021_Flash.EMUBANK[bank] and IsBcc) {
            switch (vt_type) {
               case CHKVT1:
               case CHKVT1DRL:
               case REVTUNVT1:
               case PGMFFVT1:
               case PUNTHRUVT1:
               case FGWLVT1:
               case TUNOXTSMCVT1:
               case TUNOXVT1:
               case THINOXVT1:
               case  RCODEVT1 :   
                  if (pattype==OTPTYPE) {
                     Llimit = OtpBCC.LLIM_EMU[vt_type][prepost];
                     Ulimit = OtpBCC.ULIM_EMU[vt_type][prepost];
                  }
                  else {
                     Llimit = MainBCC.LLIM_EMU[vt_type][prepost];
                     Ulimit = MainBCC.ULIM_EMU[vt_type][prepost];
                  }   
                  break; 
            }   // case
         }   // if EMUBANK

         for (count = sblk; count <= eblk ; ++count) {
            // do twice if pbist and redund enable, do once if nonpbist
            for (iter = miniter; iter <= maxiter; ++iter) {
               tmp_results = TM_NOTEST;

               if( special_opt==5) {
                  GL_DO_BCCVT_RCODE_ENA = true;
                  GL_DO_BCCVT_RCODE_BANK = bank;
               } 
               
               if (IsBcc) {
                  if (iter==miniter) {
                     if (GL_DO_BCC_USING_INTERNAL) {
                        MeasInternalVT(testnum,Llimit,Ulimit,tmp_results,vt_values);
                        tt_timer = TIME.GetTimer();
                     }
                     else {
                        F021_BCC_BinSearch_TTR(testnum,startArr,stopArr,resol,forceArr,maxtime,tt_timer,vt_values);
                     } 
                     pbistred = false;
                  }
                  else if (iter==(miniter+1)) {
                     if (GL_DO_BCC_USING_INTERNAL) {
                        MeasInternalVT(testnum+TNUM_REDUNDENA,Llimit,Ulimit,tmp_results,vt_values);
                        tt_timer = TIME.GetTimer();
                     }
                     else {
                        F021_BCC_BinSearch_TTR(testnum+TNUM_REDUNDENA,startArr,stopArr,resol,forceArr,maxtime,tt_timer,vt_values);
                     } 
                     pbistred = true;
                  } 

                  if (not GL_DO_BCC_USING_INTERNAL) {
                     // translate to internal value
                     if (iratio==TNUM_MULT2) {
                        vt_intvalues += vt_values;
                        vt_values = vt_intvalues;
                     }
                     else if (iratio==TNUM_MULT4) {
                        vt_intvalues += vt_values;
                        vt_intvalues *= 2;
                        vt_values = vt_intvalues;
                     }
                     else if (iratio==TNUM_DIV2) { 
                        vt_values = 0.5*vt_values;
                     } 
                  } 
                  
//                  if ((vt_values >= Llimit) and (vt_values <= Ulimit))  
//                     tmp_results = true;

                    // Set passing SIM value
                    if (SYS.TesterSimulated()) vt_values = ((Ulimit - Llimit) / 2.);
                    
                    tmp_results = TIDlog.Value(vt_values, UTL_VOID, Llimit, Ulimit, unitval, "InternalVT",
                                               UTL_VOID, UTL_VOID, true, TWMinimumData, ER_PASS, false);
                    
                  
                  // KChau 03/01/10 - added special case for bcc0
                  switch (vt_type) {
                     case  CHKVT0:
                     case  CHKVT0DRL:
                     case  ONOVT0:
                     case  CSFGVT0:
                     case  EGFG1VT0:
                     case  EGFG2VT0:
                     case  EGFG3VT0:
                     case  EGFG4VT0:
                     case  EGFG5VT0:
                     case  RDDISTBVT0:
                     case  RDDISTB2VT0:
                     case  RCODEVT0 :
                        
                        // Set passing SIM value
                        if (SYS.TesterSimulated()) vt_values = ((5.0uA - 0.0uA) / 2.);
                        
                        tmp_results = TIDlog.Value(vt_values, UTL_VOID, 0.0uA, 5.0uA, unitval, "InternalVT_BCC0",
                                                   UTL_VOID, UTL_VOID, true, TWMinimumData, ER_PASS, false);
                        break; 
                  }   // case
                  
                    if ( (not(tmp_results == TM_PASS)) and (not(datalogonly)) ) {
                       if (special_opt==3) GL_BCC0DRL_RESULT = false;
                       if (special_opt==4) GL_BCC1DRL_RESULT = false;
                    }   
//                  if ( (not (tmp_results)) and (not (datalogonly)) )  {
//                     if (special_opt==3)  
//                        GL_BCC0DRL_RESULT = false;
//                     if (special_opt==4)  
//                        GL_BCC1DRL_RESULT = false;
//                  } 
                  
                  if ((pattype==BANKTYPE) or (pattype==ARBTYPE)) {
                     if (not pbistred)  
                        BANK_BCC_VALUE[bank][0][vt_type][prepost] = vt_values;
                     else {
                        RED_BCC_VALUE[bank][0][vt_type][prepost] = vt_values;
                        // re-assign value based on vt_type
                        if (useminval) {
                           if (RED_BCC_VALUE[bank][0][vt_type][prepost] < BANK_BCC_VALUE[bank][0][vt_type][prepost])  
                               BANK_BCC_VALUE[bank][0][vt_type][prepost] = RED_BCC_VALUE[bank][0][vt_type][prepost];
                        }
                        else {
                           if (RED_BCC_VALUE[bank][0][vt_type][prepost] > BANK_BCC_VALUE[bank][0][vt_type][prepost])  
                               BANK_BCC_VALUE[bank][0][vt_type][prepost] = RED_BCC_VALUE[bank][0][vt_type][prepost];
                        } 
                     } 
                  }
                  else if (pattype==OTPTYPE)  
                     OTP_BCC_VALUE[bank][vt_type][prepost] = vt_values;
                  else {
                     if (not pbistred)  
                        BANK_BCC_VALUE[bank][count][vt_type][prepost] = vt_values;
                     else {
                        RED_BCC_VALUE[bank][count][vt_type][prepost] = vt_values;
                        // re-assign value based on vt_type
                        if (useminval) {
                           if (RED_BCC_VALUE[bank][count][vt_type][prepost] < BANK_BCC_VALUE[bank][count][vt_type][prepost])  
                               BANK_BCC_VALUE[bank][count][vt_type][prepost] = RED_BCC_VALUE[bank][count][vt_type][prepost];
                        }
                        else
                        {
                           if(RED_BCC_VALUE[bank][count][vt_type][prepost] > BANK_BCC_VALUE[bank][count][vt_type][prepost])  
                              BANK_BCC_VALUE[bank][count][vt_type][prepost] = RED_BCC_VALUE[bank][count][vt_type][prepost];
                        } 
                     } 
                  } 
               }  // BCC
               else {
                  if (iter==miniter) {
                     if (GL_DO_VT_USING_INTERNAL) {
                        MeasInternalVT(testnum,Llimit,Ulimit,tmp_results,vt_values);
                        tt_timer = TIME.GetTimer();
                     }
                     else
                        F021_Vt_BinSearch_TTR(testnum,startArr,stopArr,resol,forceArr,maxtime,tt_timer,vt_values);
                        
                     pbistred = false;
                  }
                  else if (iter==(miniter+1)) {
                     if (GL_DO_VT_USING_INTERNAL) {
                        MeasInternalVT(testnum+TNUM_REDUNDENA,Llimit,Ulimit,tmp_results,vt_values);
                        ttimer2 = TIME.GetTimer();
                        tt_timer = ttimer2;
                     }
                     else
                       F021_Vt_BinSearch_TTR(testnum+TNUM_REDUNDENA,startArr,stopArr,resol,forceArr,maxtime,tt_timer,vt_values);
                     pbistred = true;
                  } 
                  
                  // Set passing SIM value
                  if (SYS.TesterSimulated()) vt_values = ((Ulimit - Llimit) / 2.);
                  
                  tmp_results = TIDlog.Value(vt_values, UTL_VOID, Llimit, Ulimit, unitval, "InternalVT_BCC",
                                             UTL_VOID, UTL_VOID, true, TWMinimumData, ER_PASS, false);
                  
//                  if ((not (tmp_results)) and (not (datalogonly))) {
//                     if (special_opt==3)  
//                        GL_VT0DRL_RESULT = false;
//                     if (special_opt==4)  
//                        GL_VT1DRL_RESULT = false;
//                  } 
                  
                  if ((pattype==BANKTYPE) or (pattype==ARBTYPE)) {
                     if (not pbistred)  
                        BANK_VT_VALUE[bank][0][vt_type][prepost] = vt_values;
                     else {
                        RED_VT_VALUE[bank][0][vt_type][prepost] = vt_values;
                        // re-assign value based on vt_type
                        if (useminval) {
                           if (RED_VT_VALUE[bank][0][vt_type][prepost] < BANK_VT_VALUE[bank][0][vt_type][prepost])  
                              BANK_VT_VALUE[bank][0][vt_type][prepost] = RED_VT_VALUE[bank][0][vt_type][prepost];
                        }
                        else {
                           if(RED_VT_VALUE[bank][0][vt_type][prepost] > BANK_VT_VALUE[bank][0][vt_type][prepost])  
                              BANK_VT_VALUE[bank][0][vt_type][prepost] = RED_VT_VALUE[bank][0][vt_type][prepost];
                        } 
                     } 
                  }
                  else if (pattype==OTPTYPE)  
                     OTP_VT_VALUE[bank][vt_type][prepost] = vt_values;
                  else {
                     if (not pbistred)                          
                        BANK_VT_VALUE[bank][count][vt_type][prepost] = vt_values;
                     else {
                        RED_VT_VALUE[bank][count][vt_type][prepost] = vt_values;
                        // re-assign value based on vt_type
                        if (useminval) {
                           if (RED_VT_VALUE[bank][count][vt_type][prepost] < BANK_VT_VALUE[bank][count][vt_type][prepost])  
                              BANK_VT_VALUE[bank][count][vt_type][prepost] = RED_VT_VALUE[bank][count][vt_type][prepost];
                        }
                        else {
                           if (RED_VT_VALUE[bank][count][vt_type][prepost] > BANK_VT_VALUE[bank][count][vt_type][prepost])  
                              BANK_VT_VALUE[bank][count][vt_type][prepost] = RED_VT_VALUE[bank][count][vt_type][prepost];
                        } 
                     } 
                  } 
               }   // VT
               
               DLOG.AccumulateResults(final_results,tmp_results);
               
               str3 = "_B";
//               str3 += CONV.IntToString(bank);  // Bug IntToStr can't convert zero (SPR142812)
               if ( bank == 0 ) str3 += "0";
               else             str3 += CONV.IntToString(bank);
               
               if (pattype==BLOCKTYPE) {
                  str4 = "BLK";            
//                  str4 += CONV.IntToString(count);  // Bug IntToStr can't convert zero (SPR142812)
                  if ( count == 0 ) str4 += "0";
                  else              str4 += CONV.IntToString(count);

                  str3 += str4;
               }
               else if (pattype==SECTTYPE) {
                  str4 = "S";
//                  str4 += CONV.IntToString(count);  // Bug IntToStr can't convert zero (SPR142812)
                  if ( count == 0 ) str4 += "0";
                  else              str4 += CONV.IntToString(count);
                  str3 += str4;
               }
               else if (pattype==QUADTYPE) {
                  str4 = "Q";
//                  str4 += CONV.IntToString(count);  // Bug IntToStr can't convert zero (SPR142812) 
                  if ( count == 0 ) str4 += "0";
                  else              str4 += CONV.IntToString(count);                  
                  str3 += str4;
               } 
               
               if (pbistred)  str5 = str1 + "_RED";
               else           str5 = str1;
               
               str5 = str5 + str3;
               
               if (iter==miniter) {
                  cout << "\n   " << str5 << " TestNum:0x" << hex << testnum << " Result:" << vt_values;
                  cout << " LoLim:" << Llimit << " HiLom:" << Ulimit << vt_values << endl;
               } 
//                  PrintResultParam(str5,testnum,tmp_results,LLimit,ULimit,vt_values,GL_PLELL_FORMAT);
               else {
                  cout << "\n   " << str5 << " TestNum:0x" << hex << testnum+TNUM_REDUNDENA << " Result:" << vt_values;
                  cout << " LoLim:" << Llimit << " HiLim:" << Ulimit << vt_values << endl;
               }
//                  PrintResultParam(str5,testnum+TNUM_REDUNDENA,tmp_results,Llimit,Ulimit,vt_values,GL_PLELL_FORMAT);

               if(logena) {
//                  TWTRealToRealMS(vt_values,realval,unitval);
//                  TWPDLDataLogRealVariable(str5, unitval,realval,TWMinimumData);
                  str4 = str5 + "_TT";
//                  TWTRealToRealMS(tt_timer,realval,unitval);
//                  TWPDLDataLogRealVariable(str4, unitval,realval,TWMinimumData);
               } 
               
//               if(not ArrayCompareBoolean(logsites,tmp_results,v_sites)) {
//                  if (not datalogonly) {
//                     F021_Log_FailPat_To_TW(str5,tmp_results,tname);
//                     
//                     if (TI_FlashESDAEna) {
//                        if ((pattype==BANKTYPE) or (pattype==OTPTYPE))  
//                           SetFlashESDAVars(tmp_results,bank,bank);
//                        else
//                           SetFlashESDAVars(tmp_results,bank,count);
//                     } 
//                  } 
//                  
//                  if (TI_FlashCOFEna)  
//                     F021_Update_COF_Inst_Str(str5,site_cof_inst_str,tmp_results);
//               }   // if not arraycompare
//               
//               if ((not TIIgnoreFail) and (not TI_FlashCOFEna) and (not datalogonly) and ((special_opt==0) or (special_opt==5)))  
//                  Devsetholdstates(final_results);
//               
//               if (not v_any_dev_active)  
//                  break;
                 if (tmp_results != TM_PASS)
                    break;
            }   // for iter

            testnum = testnum+1;

//            if ((not TIIgnoreFail) and (not TI_FlashCOFEna) and (not datalogonly) and ((special_opt==0) or (special_opt==5)))  
//               Devsetholdstates(final_results);
//            
         }   /*count*/
      }   /*bank*/
//
       /*restore all active sites*/
//      Devsetholdstates(savesites);
      
//      if (not datalogonly)  
//         ResultsRecordActive(final_results, S_NULL);
//      else
//         ResultsRecordActive(savesites, S_NULL);
      
//      test_results = final_results;
      
      if (TI_FlashCOFEna)
         ;
//         F021_Save_COF_Info(str1,site_cof_inst_str,final_results);
      
      tt_timer = TIME.GetTimer();

      str4 = str1 + "_TTT";
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(str4, unitval,realval,TWMinimumData);

      tiprintpass = save_printpass;
      
      if(tistdscreenprint) {
         // PrintHeaderBool(GL_PLELL_FORMAT);
//         PrintResultBool(str1,start_tnum,final_results,GL_PLELL_FORMAT);
         cout << "   TT = " << tt_timer << endl;
         cout << endl;
      }         // if tistdscreenprint
      
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna) and (not datalogonly) and ((special_opt==0) or (special_opt==5)))  
//         DevSetHoldStates(final_results);

      if(special_opt==5) {
         GL_DO_BCCVT_RCODE_ENA = false;
         GL_DO_BCCVT_RCODE_BANK = 0;
      }             
   }
   return(final_results);
}
     
TMResultM F021_BCC_Delta_func(  IntS    pattype,
                                vttype  vt_type,
                                StringS tname,
                                BoolS   dlogonly) {
   FloatS tdelay;
   BoolM savesites;
   TMResultM tmp_results,final_results;
   TMResultM test_results;
   IntS site,opertype,special_opt;
   IntS testnum,bankcount,count;
   IntS blkstart,blkstop;
   FloatS ttimer1,ttimer2;
   FloatM tt_timer;
   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
   FloatM FloatSval;
//   TWunit unitval;
   StringS fl_testname;
   prepostcorner hitype,lotype;
   FloatM vt_values,vt_intvalues;
   FloatS Llimit,Ulimit;
   IntS shiftbit,length;
   FloatS vstart,vstop,vres;
   BoolM logsites;
   BoolS ersstr_ena,datalogonly;
   StringM site_cof_inst_str;
   IntS iratio;
   vttype previoustype;
   BoolS same_vttype,do_ena_red;
   IntS tcrnum,tnum_esda,imgnum;
   FloatS Llimit_EMU,Ulimit_EMU;
   FloatS1D sorted_vt_delta(5),tmp_delta(5);
   FloatM vt_val1,vt_val2,max_vt_med;
   FloatM median_values;
   FloatS1D vt_delta(2);
   FloatS ULimit_Median;

   // Declaring the BIG arrays local
   FloatM BANK_BCC_DELTA_VALUE[8][16][25];
   
   if (tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ F021_BCC_Delta_func +++++" << endl;

   // default to false on all vt_type. if ersstvt0 search
   // then set it later w/in that vt_type so not to disable site
   ersstr_ena = false;

   tmpstr1 = tname;
   tmpstr1.Replace(tmpstr1.Find("_Test"), 5, "");   // remove _Test
   fl_testname = tname;

   TIME.StartTimer();

   if (tistdscreenprint)  
      ;
//    PrintHeaderParam(GL_PLELL_FORMAT);
   
//   TestOpen(fl_testname);

   if (TI_FlashCOFEna)
      ;
//      F021_Init_COF_Inst_Str(site_cof_inst_str);

// savesites = V_dev_active;
   tmp_results = TM_NOTEST;
   final_results = TM_NOTEST;
   test_results = TM_NOTEST;

    /*KChau 05/17/10 - WEBS VLCTSTD.10 - using post-pre*/
   hitype = post;
   lotype = pre;
   
   datalogonly = dlogonly;
   
   switch (vt_type) {
     // added special option so not to disable site for drl
     case CHKVT0DRL: special_opt = 3; break;
     case CHKVT1DRL: special_opt = 4; break;
     default:        special_opt = 0; break;
   }  // case

   if(pattype==OTPTYPE) {
      Llimit = OtpBCC.LDELTA[vt_type];
      Ulimit = OtpBCC.UDELTA[vt_type];
      iratio = OtpBCC.IRATIO[vt_type][post];
      previoustype = OtpBCC.PREVTYPE[vt_type];
      tcrnum = OtpBCC.TCRNUM[vt_type][post];
      do_ena_red = false;
   }
   else {
      Llimit = MainBCC.LDELTA[vt_type];
      Ulimit = MainBCC.UDELTA[vt_type];
      iratio = MainBCC.IRATIO[vt_type][post];
      previoustype = MainBCC.PREVTYPE[vt_type];
      tcrnum = MainBCC.TCRNUM[vt_type][post];
      do_ena_red = MainBCC.ENARED[vt_type][post];
      switch (vt_type) {
        case  CHKVT0DRL: case CHKVT1DRL :   
           Llimit_EMU = MainBCC.LDELTA_EMU[vt_type];
           Ulimit_EMU = MainBCC.UDELTA_EMU[vt_type];
           break; 
      }  // case
   } 

   if (previoustype == vt_type)  
      same_vttype = true;
   else
      same_vttype = false;

   if (TI_FlashESDAEna)  {
      switch (tcrnum) {
        case  5: tnum_esda =  TNUM_TCR5; break;
        case  6: tnum_esda =  TNUM_TCR6; break;
        case 38: tnum_esda = TNUM_TCR38; break;
        default: tnum_esda = TNUM_TCR39; break;
      }  // case
      
      if (pattype==OTPTYPE) {
         tnum_esda = tnum_esda+OtpBCC.IRATIO[vt_type][post]+OtpBCC.RDOPTION[vt_type][post]+OtpBCC.TDATA[vt_type];
      }
      else {
         tnum_esda = tnum_esda + MainBCC.IRATIO[vt_type][post] + MainBCC.TDATA[vt_type] + MainBCC.RDOPTION[vt_type][post];
         if (MainBCC.MEMCFG[vt_type]==SECTTYPE)  
            tnum_esda = tnum_esda + TNUM_TARGET_SECT;
         else if (MainBCC.MEMCFG[vt_type]==BLOCKTYPE)  
            tnum_esda = tnum_esda + TNUM_TARGET_BLOCK;
         else if (MainBCC.MEMCFG[vt_type]==QUADTYPE)  
            tnum_esda = tnum_esda + TNUM_TARGET_QUAD;

         if (do_ena_red)  
            tnum_esda = tnum_esda+TNUM_REDUNDENA;
      } 
      
      FLEsda.Tnum     = tnum_esda;
      FLEsda.Pattype  = pattype;
      FLEsda.VT_type  = vt_type;
      FLEsda.TCRNum   = tcrnum;
      FLEsda.TCRMode  = ReadMode;
      FLEsda.UseBcc   = true;
      FLEsda.PPCorner = post;
   }  // TI_FlashESDAEna
   
   if (pattype == MODTYPE)  {
      // +++ Module operation +++
      final_results = TM_NOTEST;
      if (tistdscreenprint)  
         cout << "+++ WARNING : Invalid MemType Entered +++" << endl;
   }
   else {  //-- bank/otp/blk/sect --
      
      for (bankcount = 0; bankcount <= F021_Flash.MAXBANK; ++bankcount) {
         if ((pattype==BANKTYPE) or (pattype==OTPTYPE)) {
            blkstart = bankcount;
            blkstop  = bankcount;
         }
         else if (pattype==BLOCKTYPE) {
            blkstart = 0;
            blkstop  = F021_Flash.MAXBLOCK[bankcount];
         }
         else if (pattype==QUADTYPE) {
            blkstart = 0;
            blkstop  = FL_MAX_QUADRANT;
         }
         else {
            blkstart = 0;
            blkstop  = F021_Flash.MAXSECT[bankcount];
         } 

         if ((SelectedTITestType==PreBurnIn) and (vt_type==RCODEVT0) and
             (not (F021_RunCode.DO_RUNCODE_VT0_ENA[TNI][bankcount]))) {
            if (tistdscreenprint)
               cout << "Bank " << setw(3) << bankcount << vt_type << " is configured as Disable !!" << endl;
         }
         else {
            for (count = blkstart; count <= blkstop; ++count) {
//             logsites = v_dev_active;
               tmp_results = TM_NOTEST;
               vt_values = 0uA;
               
               // Set passing SIM value
               if (SYS.TesterSimulated()) vt_values = ((Ulimit - Llimit) / 2.);
                   
               if (pattype==OTPTYPE) {
                  if (same_vttype)  
                     vt_values = OTP_BCC_VALUE[count][vt_type][hitype]-
                                        OTP_BCC_VALUE[count][vt_type][lotype];
                  else
                     vt_values = OTP_BCC_VALUE[count][vt_type][post]-
                                        OTP_BCC_VALUE[count][previoustype][post];

                  OTP_BCC_DELTA_VALUE.SetValue(count,vt_type,vt_values);
               }
               else if (pattype==BANKTYPE) {
                  if (same_vttype)  
                     vt_values = BANK_BCC_VALUE[bankcount][0][vt_type][hitype]-
                                        BANK_BCC_VALUE[bankcount][0][vt_type][lotype];
                  else
                     vt_values = BANK_BCC_VALUE[bankcount][0][vt_type][post]-
                                        BANK_BCC_VALUE[bankcount][0][previoustype][post];
                     
                  BANK_BCC_DELTA_VALUE[bankcount][0][vt_type] = vt_values;
               }
               else {
                  if (same_vttype)  
                     vt_values = BANK_BCC_VALUE[bankcount][count][vt_type][hitype]-
                                        BANK_BCC_VALUE[bankcount][count][vt_type][lotype];
                  else
                     vt_values = BANK_BCC_VALUE[bankcount][count][vt_type][post]-
                                        BANK_BCC_VALUE[bankcount][count][previoustype][post];
                     
                  BANK_BCC_DELTA_VALUE[bankcount][count][vt_type] = vt_values;
               } 

                /*WEBS VLCTSTD.15 -- translate to internal value*/
                /*KChau 08/17/10 - removed translate to internal value since it"s taken care in bcc func*/
                for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
                  if (((vt_type==CHKVT0DRL) or (vt_type==CHKVT1DRL)) and (pattype!=OTPTYPE) and (F021_Flash.EMUBANK[bankcount])) {
                     if ((vt_values[*si]<=Llimit_EMU) or (vt_values[*si]>=Ulimit_EMU)) {
                        tmp_results[*si] = TM_FAIL;
                     }   /*if LL/ULimit_EMU*/
                  }
                  else {
                     if ((vt_values[*si]<=Llimit) or (vt_values[*si]>=Ulimit)) {
                        tmp_results[*si] = TM_FAIL;
                     }   /*if Ll/Ulimit*/
                  } 

                  if ((not tmp_results[*si]) and (not datalogonly)) {
                     if (special_opt==3)
                        GL_BCC0DRL_RESULT[*si] = false;
                     if (special_opt==4)  
                        GL_BCC1DRL_RESULT[*si] = false;
                  } 
               }   // for site
               DLOG.AccumulateResults(final_results,tmp_results);
               
               // log to TW*/
//               tmpstr2 = CONV.IntToString(bankcount);  // Bug IntToStr can't convert zero (SPR142812) 
               if ( bankcount == 0 ) tmpstr2 = "0";
               else                  tmpstr2 = CONV.IntToString(bankcount);                  
               tmpstr2 = "_B" + tmpstr2;  /*_B#*/

               if ((pattype==BLOCKTYPE) or (pattype==SECTTYPE) or (pattype==QUADTYPE)) {
   //               tmpstr3 = CONV.IntToString(count);  // Bug IntToStr can't convert zero (SPR142812) 
                  if ( count == 0 ) tmpstr3 = "0";
                  else              tmpstr3 = CONV.IntToString(count);                  
                  if(pattype==BLOCKTYPE)  
                     tmpstr3 = "BLK" + tmpstr3;
                  else if(pattype==QUADTYPE)  
                     tmpstr3 = "Q" + tmpstr3;
                  else
                     tmpstr3 = "S" + tmpstr3;

                  tmpstr2 = tmpstr2 + tmpstr3;
               } 
               
               tmpstr3 = tmpstr1 + tmpstr2;  // now has PGMx_B#
               tmpstr4 = tmpstr3;

               if (tistdscreenprint)  
//                PrintResultParam(tmpstr3,0,tmp_results,LLimit,ULimit,vt_values,GL_PLELL_FORMAT);
                  cout << tmpstr3 << "   " << tmp_results << "   " << Llimit << "   " << Ulimit << "   " << vt_values << endl;
               
//             TWTRealToRealMS(vt_values,realval,unitval);
//             TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
         
                /*KChau 01/31/08 - added so not to log for erase stress test*/
               if (not ersstr_ena)  
//                if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//                {
                     if (not datalogonly) {
                        ;
//                        F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
                        
                        if (TI_FlashESDAEna)  {
                           if ((pattype==BANKTYPE) or (pattype==OTPTYPE))  
                              SetFlashESDAVars(tmp_results,bankcount,bankcount);
                           else
                              SetFlashESDAVars(tmp_results,bankcount,count);
                        } 
                     } 
                     
                     if (TI_FlashCOFEna)
                        ;
//                        F021_Update_COF_Inst_Str(tmpstr2,site_cof_inst_str,tmp_results);
//                } 

               // not to disable failing site w/ ersstrvt0 type to get all banks vt
//               if ((not TIIgnoreFail) and (not ersstr_ena) and
//                   (not TI_FlashCOFEna) and (not datalogonly) and (special_opt==0))  
//                Devsetholdstates(final_results);
               
//             if (not v_any_dev_active)  
//                break;
            }  // for count*/
         }  // not VT0_DIS*/
         
         // +++ Median or delta-delta +++
         if ((vt_type==CHKVT1DRL) and (pattype==QUADTYPE)) {
            tmp_results = TM_NOTEST;
//          logsites = v_dev_active;
            ULimit_Median = DRLBCC1_Median_ULimit[bankcount];
            median_values = 5uA;
            vt_val1 = 0uA;
            vt_val2 = 0uA;
            max_vt_med = 0uA;
            
            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si) {
               for (count = blkstart; count <= blkstop; ++count)
                  tmp_delta[count] = MATH.Abs(BANK_BCC_DELTA_VALUE[bankcount][count][vt_type][*si]);
               
//             ArraySortTreal(sorted_vt_delta,tmp_delta,4,s_ascending);
               median_values[*si] = (sorted_vt_delta[1]+sorted_vt_delta[2])/2;
               vt_delta[0] = MATH.Abs(sorted_vt_delta[0]-median_values[*si]);
               vt_delta[1] = MATH.Abs(sorted_vt_delta[3]-median_values[*si]);

               if((vt_delta[0] > ULimit_Median) or (vt_delta[1] > ULimit_Median))  
                  tmp_results[*si] = TM_FAIL;

               vt_val1[*si] = vt_delta[0];
               vt_val2[*si] = vt_delta[1];

               if(vt_delta[0]>=vt_delta[1])  
                  max_vt_med[*si] = vt_delta[0];
               else
                  max_vt_med[*si] = vt_delta[1];
            }   // for site

            DLOG.AccumulateResults(final_results,tmp_results);

//            tmpstr2 = CONV.IntToString(bankcount);  // Bug IntToStr can't convert zero (SPR142812) 
            if ( bankcount == 0 ) tmpstr2 = "0";
            else                  tmpstr2 = CONV.IntToString(bankcount);                  
            tmpstr2 = "_B" + tmpstr2;
            tmpstr2 = tmpstr1 + tmpstr2;
            
            tmpstr3 = tmpstr2 + "_MEDIAN";
//          TWTRealToRealMS(median_values,realval,unitval);
//          TWPDLDataLogRealVariable(tmpstr3, unitval,realval,TWMinimumData);
//          PrintResultParam(tmpstr3,0,tmp_results,LLimit,ULimit,median_values,GL_PLELL_FORMAT);
            cout << tmpstr3 << "   " << tmp_results << "   " << Llimit << "   " << Ulimit << "   " << median_values << endl;
            
//          if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))
//          {
               if (not datalogonly)
                  ;
//                  F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
//          } 

            tmpstr3 = tmpstr2 + "_DLT0";
//          TWTRealToRealMS(vt_val1,realval,unitval);
//          TWPDLDataLogRealVariable(tmpstr3, unitval,realval,TWMinimumData);
//          PrintResultParam(tmpstr3,0,tmp_results,0v,ULimit_Median,vt_val1,GL_PLELL_FORMAT);
            cout << tmpstr3 << "   " << tmp_results << "   0V   " << ULimit_Median << "   " << vt_val1 << endl;
            
            tmpstr3 = tmpstr2 + "_DLT3";
//          TWTRealToRealMS(vt_val2,realval,unitval);
//          TWPDLDataLogRealVariable(tmpstr3, unitval,realval,TWMinimumData);
//          PrintResultParam(tmpstr3,0,tmp_results,0v,ULimit_Median,vt_val2,GL_PLELL_FORMAT);
            cout << tmpstr3 << "   " << tmp_results << "   0V   " << ULimit_Median << "   " << vt_val2 << endl;
            
            tmpstr3 = tmpstr2 + "_MAX";
//          TWTRealToRealMS(max_vt_med,realval,unitval);
//          TWPDLDataLogRealVariable(tmpstr3, unitval,realval,TWMinimumData);
//          PrintResultParam(tmpstr3,0,tmp_results,0v,ULimit_Median,max_vt_med,GL_PLELL_FORMAT);
            cout << tmpstr3 << "   " << tmp_results << "   0V   " << ULimit_Median << "   " << max_vt_med << endl;
         }  // Median
         
      }  // for bankcount
   }  // -- bank/otp/blk/sect --

   // restore all active sites
// Devsetholdstates(savesites);

   // binning all vt_type except ersstrvt0
//   if ((not ersstr_ena) and (not datalogonly))  
//      ResultsRecordActive(final_results, S_NULL);
//   else
//      ResultsRecordActive(savesites, S_NULL);
      
//   TestClose;

   test_results = final_results;
   
   if (TI_FlashCOFEna)
      ;
//      F021_Save_COF_Info(tmpstr1,site_cof_inst_str,final_results);
   
   ttimer1 = TIME.GetTimer();
   tt_timer = ttimer1;

   tmpstr4 = tmpstr1 + "_TTT";
// TWTRealToRealMS(tt_timer,realval,unitval);
// TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);

   if (tistdscreenprint) {
      // PrintHeaderBool(GL_PLELL_FORMAT);
//    PrintResultBool(tmpstr1,0,final_results,GL_PLELL_FORMAT);
      cout << "   TT " << ttimer1 << endl;
      cout << endl;
   }

   // not to disable site when doing ersstr
//   if (     (not TIIgnoreFail) and (not ersstr_ena) and (not TI_FlashCOFEna)
//        and (not datalogonly) and (special_opt==0))  
//    DevSetHoldStates(final_results);
            
     return(test_results);
//   F021_BCC_Delta_func = V_any_dev_active;
}  // F021_BCC_Delta_func
   
//   
TMResultM F021_Program_func(    IntS start_testnum,
                               StringS tname)
//if function returns TMResultM no need for argument test_results: BoolM test_results);
{
   const IntS none_ena = 0; 
   const IntS cmpress_ena = 1; 
   const IntS avnv_ena = 2; 
   const IntS pmos_ena = 3; 
   const IntS efchksum_ena = 4; 
   const IntS TARGET_BANK = 0; 
   const IntS TARGET_SECT = 1; 
   const IntS TARGET_OTP = 4; 
   const IntS TARGET_SEMIOTP = 5; 
   const IntS TARGET_DATAOTP = 6; 
   const IntS TOPT_SW_COMPRESS = 0x31; 

   Sites savesites,new_active_sites,logsites;
   TMResultM final_results,tmp_results;
   IntM pgmpulse;
   IntS bankcount,count;
   IntS site,opertype,pattype;
   FloatS ttimer1,ttimer2;
   FloatM tt_timer;
   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
   IntS testnum,start_tnum;
   FloatM FloatSval;
//   TWunit unitval;
   StringS fl_testname, unitval;
   FloatS maxtime;
   IntS1D addr_loc(4);
   IntS length;
   FloatM vhvprog_val,vhvpvfy_val;
   IntM cmpr_factor1,cmpr_factor2;
   IntS addr_loc_mbox;
   IntS wr_flag_num;
   IntM src_data1,src_data2;
   BoolS hexvalue,nothexvalue;
   BoolS bcd_format,notbcd;
   BoolS firsttime;
   IntM rti_timer;
   StringM site_cof_inst_str;
   IntS target_bits;
   IntS pulse_ulim;
   IntS blkstart,blkstop;
   BoolS dlogonly,faildetect;

   savesites = ActiveSites;
   new_active_sites = ActiveSites;

//   if(V_any_dev_active)  
//   {
      if(tistdscreenprint and TI_FlashDebug)  
         cout << "+++++ F021_Program_func +++++" << endl;

      opertype = none_ena;   /*set to default normal operation*/
      dlogonly = false;

      length = tname.Length();
//      writestring(tmpstr1,mid(tmpstr1,2,length-6));
      tmpstr1 = tname.Substring(2,length-6);
      fl_testname = tname;
//      
//      timernstart(ttimer1);      
      TIME.StartTimer();
//
//      TestOpen(fl_testname);
//
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//      F021_Init_COF_Inst_Str simply sets the string associated with each active site to an empty string.  Unison
//      is sited.  Don't need a site loop for this.
        site_cof_inst_str = "";
//
//      savesites = V_dev_active;
//      tmp_results = V_dev_active;
      final_results = TM_NOTEST;
//      final_results = V_dev_active;
      tmp_results = final_results;  
      testnum = start_testnum;
//
//       /*otp template pgm w/ eng override*/
      if(testnum == TNUM_OTP_PROG_TEMPLATE)  
      {
         opertype = pmos_ena;
         pattype = OTPTYPE;
      }
      else
      {
         target_bits = (testnum & 0x00000f00) >>8;
         /*** BEGIN if else tree replaces switch statement ***/
         if (target_bits == TARGET_BANK)
         {
            pattype=BANKTYPE;
         }
         else if (target_bits == TARGET_SECT)
         {
            pattype = SECTTYPE;
         }
         else if ((target_bits == TARGET_OTP) || (target_bits == TARGET_SEMIOTP) || (target_bits == TARGET_SEMIOTP) || (target_bits == TARGET_DATAOTP))
         {
            pattype = OTPTYPE;
         }
         else
         {
            pattype = MODTYPE;
         }
         /*** END if else tree replaces switch statement ***/
 //        switch(target_bits) 
//         {
//           case TARGET_BANK    : pattype = BANKTYPE;
//           case TARGET_SECT    : pattype = SECTTYPE;
//           TARGET_OTP,
//           TARGET_SEMIOTP,
//           case TARGET_DATAOTP : pattype = OTPTYPE;
//           default:     pattype = MODTYPE;
//         }   /*case*/
         
          /*check override pulse limits bit22*/
         if((testnum&0x00400000)>0)  
         {
            if(tistdscreenprint)  
            {
               cout << endl; cout << "*** WARNING: OVERRIDE PULSE LIMITS is Enable." << "  MAKE SURE THIS IS INTENTIONALLY DONE SO <<  i.e. Engineering Debug Only ***" << endl;cout << endl;
               IO.Flush(IO.Stdout);
            } 
             /*make sure not use in production unless*/
            if(!TI_FlashCOFEna)  
            {
               pattype = MODTYPE;
               if(tistdscreenprint) 
               {
                  cout << "*** PLS SET TI_FlashCOFEna true" << " IF INTENTION OVERRIDE PULSE LIMITS. ***" << endl;
                  IO.Flush(IO.Stdout);
               }
            } 
         } //if((testnum&0x00400000)>0) 
      } //else
      
       /*check bank/sector bits*/
      if((((testnum&0x00000070)>>4)!=0) or ((testnum&0x0000000f)!=0))  
      {
         if(tistdscreenprint)
         {
            cout << "*** ERROR: Bank/Sector bits are not start @0." << "  Please double check!!! ***" << endl;
            IO.Flush(IO.Stdout);
         }
         if(not tistdscreenprint) 
         {
            cout << "*** ERROR: Bank/Sector bits are not start @0." << "  Please double check!!! ***" << endl;
            IO.Flush(IO.Stdout);
         }
         pattype = MODTYPE;
      } 

            
      if(TI_FlashESDAEna)  
         FLEsda.Pattype  = pattype;

      if(pattype == MODTYPE)  
      {
          /*+++ Module operation +++*/
         final_results = TM_FAIL;
         if(tistdscreenprint)
         {
            cout << "+++ WARNING : Invalid Test Number Entered +++" << endl;
            IO.Flush(IO.Stdout);
         }
      }
      else 
      {
          /*++++++++ Bank operation ++++++++*/
         if((testnum&0x0f000000)==0x03000000)  
            maxtime = GL_F021_BANK_SWPGM_MAXTIME;
         else
            maxtime = GL_F021_BANK_PGM_MAXTIME;

         pulse_ulim = BANK_PROG_ULimit;

//         if(tistdscreenprint)  
//            PrintHeaderErsProg(0,pulse_ulim,0,0,0,0,(not GL_PLELL_FORMAT));

         if(((testnum&0x03100000) >>20)==TOPT_SW_COMPRESS)  
         {
            opertype = cmpress_ena;  /*software compress pgm*/
            wr_flag_num = 0x1234;
            bcd_format = true;
            hexvalue   = true;
            firsttime = true;
            maxtime = GL_F021_BANK_SWPGM_MAXTIME;
            pulse_ulim = BANK_PROG_ULimit*5;
         } 
         
         for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
         {
            if((pattype==BANKTYPE) or (pattype==OTPTYPE))  
            {
               blkstart = bankcount;
               blkstop  = bankcount;
            }
            else if(pattype==BLOCKTYPE)  
            {
               blkstart = 0;
               blkstop  = F021_Flash.MAXBLOCK[bankcount];
            }
            else
            {
               blkstart = 0;
               blkstop  = F021_Flash.MAXSECT[bankcount];
            } 

             /*+++++ SW Compressed pgm +++++*/
            if(opertype==cmpress_ena)  
            {
                /*calculate correction factor once*/
                /*KChau 07/28/09 - changed calculation based on 1CT=25mV(FPA), 35mV(HD)*/
                /*previously was using 2CT=50mV, 70mV. New format is 0xppmm where pp=positive CT, mm=negCT*/
               if(firsttime)  
               {
                    //Unison is sited.  Does not need this site iterator
//                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
 //                    if(v_dev_active[site])  
//                     {
                     if((PUMP_PARA_VALUE[ProgMode][post]) != 0.0V)  
                        vhvprog_val = PUMP_PARA_VALUE[ProgMode][post];
                     else
                        vhvprog_val = PUMP_PARA_VALUE[ProgMode][pre];
                     
                     if(vhvprog_val>VHV_Prog_Target)  
                     {
                        if(GL_PUMPTYPE==FPAPUMP)  
                           cmpr_factor1 = MATH.Round((vhvprog_val-VHV_Prog_Target)/25mV);
                        else
                           cmpr_factor1 = MATH.Round((vhvprog_val-VHV_Prog_Target)/35mV);
                     }
                     else
                     {
                        if(GL_PUMPTYPE==FPAPUMP)  
                           cmpr_factor1 = MATH.Round((VHV_Prog_Target-vhvprog_val)/25mV);
                        else
                           cmpr_factor1 = MATH.Round((VHV_Prog_Target-vhvprog_val)/35mV);
                         /*positive CT setting*/
                        cmpr_factor1 = cmpr_factor1<<8;
                     } 
                        
                     if((PUMP_PARA_VALUE[PvfyMode][post]) != 0.0V)  
                        vhvpvfy_val = PUMP_PARA_VALUE[PvfyMode][post];
                     else
                        vhvpvfy_val = PUMP_PARA_VALUE[PvfyMode][pre];
                        
                     if(vhvpvfy_val>VHV_Pvfy_Target)  
                     {
                        if(GL_PUMPTYPE==FPAPUMP)  
                           cmpr_factor2 = MATH.Round((vhvpvfy_val-VHV_Pvfy_Target)/25mV);
                        else
                           cmpr_factor2 = MATH.Round((vhvpvfy_val-VHV_Pvfy_Target)/35mV);
                        }
                        else
                        {
                           if(GL_PUMPTYPE==FPAPUMP)  
                              cmpr_factor2 = MATH.Round((VHV_Pvfy_Target-vhvpvfy_val)/25mV);
                           else
                              cmpr_factor2 = MATH.Round((VHV_Pvfy_Target-vhvpvfy_val)/35mV);
                            /*positive CT setting*/
                           cmpr_factor2 = cmpr_factor2<<8;
                        } 
//                     }   /*v_dev_active*/
                  firsttime = false;
               }   /*1sttime*/
            }   /*cmpress_ena*/

            testnum  = start_testnum+(bankcount<<4);

            for (count = blkstart;count <= blkstop;count++)
            {
//               switch(opertype) {
//                 case cmpress_ena :  
//                    if(tistdscreenprint and TI_FlashDebug)  
//                       cout << "Upload correction factor for compressed pgming..." << endl;
//                    addr_loc_mbox = ADDR_RAM_MAILBOX;
//                    src_data2 = wr_flag_num;  /*msword*/
//                    src_data1 = 2;  /*lsword} {2 16-bit word*/
//                     /*upload to ram 32-bit write flag and data length*/
//                    WriteRamContentDec_32Bit(addr_loc_mbox,src_data1,hexvalue,
//                                             src_data2,hexvalue, bcd_format);
//                    addr_loc_mbox = addr_loc_mbox+ADDR_RAM_INC;
//                    src_data2 = cmpr_factor1;  /*msword*/
//                    src_data1 = cmpr_factor2;  /*lsword*/
//                    WriteRamContentDec_32Bit(addr_loc_mbox,src_data1,hexvalue,
//                                             src_data2,hexvalue, bcd_format);
//                  break;   /*cmpress_ena*/
//                 
//                 case pmos_ena    :  
//                    RAM_Upload_VHV_PMOS_EngOvride(count);
//                  break; 
//               }   /* case */
                if (opertype == cmpress_ena)
                {
                    if(tistdscreenprint and TI_FlashDebug)
                    {
                       cout << "Upload correction factor for compressed pgming..." << endl;
                       IO.Flush(IO.Stdout);
                    }
                    addr_loc_mbox = ADDR_RAM_MAILBOX;
                    src_data2 = wr_flag_num;  /*msword*/
                    src_data1 = 2;  /*lsword} {2 16-bit word*/
                     /*upload to ram 32-bit write flag and data length*/
                    WriteRamContentDec_32Bit(addr_loc_mbox,src_data1,hexvalue,
                                             src_data2,hexvalue, bcd_format);
                    addr_loc_mbox = addr_loc_mbox+ADDR_RAM_INC;
                    src_data2 = cmpr_factor1;  /*msword*/
                    src_data1 = cmpr_factor2;  /*lsword*/
                    WriteRamContentDec_32Bit(addr_loc_mbox,src_data1,hexvalue,
                                             src_data2,hexvalue, bcd_format);
                }
                else if (opertype == pmos_ena)
                {
                   RAM_Upload_VHV_PMOS_EngOvride(count);
                }
               faildetect = false;
//               logsites = v_dev_active;
               logsites = ActiveSites;
               tmp_results = F021_RunTestNumber(testnum,maxtime,tt_timer);
//               ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
               final_results = DLOG.AccumulateResults(final_results,tmp_results);
               
               pgmpulse = 0;
               Get_TLogSpace_MaxPPulse(pgmpulse);

                /*pass/fail per limit*/
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
 //                 if(v_dev_active[site])  
                     if(pgmpulse > pulse_ulim)  
                     {
                        final_results = TM_FAIL;
                        tmp_results = TM_FAIL;
                     } 
               
                /*log to TW*/
                /*tw string: PGMx_B#_TT and PGMx_B#_PGM_PLS*/
               //writestring(tmpstr2,bankcount:1);
               IO.Print(tmpstr2, "%1d", bankcount);
               IO.Flush(IO.Stdout);
               tmpstr2 = "_B" + tmpstr2;  /*_B#*/

               if((pattype==BLOCKTYPE) or (pattype==SECTTYPE))  
               {
                  IO.Print(tmpstr3, "%1d", count);
                  IO.Flush(IO.Stdout);
                  if(pattype==BLOCKTYPE)  
                     tmpstr3 = "BLK" + tmpstr3;
                  else
                     tmpstr3 = "S" + tmpstr3;
                  tmpstr2 = tmpstr2 + tmpstr3;
               } 

               tmpstr3 = tmpstr1 + tmpstr2;  /*now has PGMx_B#*/
               tmpstr4 = tmpstr3 + "_TT";
               //already sited, don't need to converted to multisite
               //TWTRealToRealMS(tt_timer,realval,unitval);
               unitval = "s";
               TWPDLDataLogRealVariable(tmpstr4, unitval,tt_timer,TWMinimumData);
            
               tmpstr4 = tmpstr3 + "_PGM_PLS";
               TWPDLDataLogVariable(tmpstr4,pgmpulse, TWMinimumData);
               
                /*log RTI timer (internal vclock cycle value) to tw*/
               rti_timer = 0;
               GetRTIValue(rti_timer);
               tmpstr4 = tmpstr3 + "_RTI_TT";
               TWPDLDataLogVariable(tmpstr4,rti_timer, TWMinimumData);
               
//               if(tistdscreenprint)  
//                  PrintResultErsProg(tmpstr3,testnum,pgmpulse,pgmpulse,pgmpulse,
//                                     0,pulse_ulim,0,0,0,0,(not GL_PLELL_FORMAT));

                /*log failed test to tw*/
                /*KChau 12/21/07 - determine if any site is failing to log to TW.*/

//               if(not ArrayCompareBoolean(logsites,tmp_results,v_sites)) 
                if (ActiveSites !=  logsites) 
               {
                  faildetect = true;
                  if(not dlogonly)  {}
//                     F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname); //not yet implemented
//                  
                  if(TI_FlashCOFEna)  {}
//                     F021_Update_COF_Inst_Str(tmpstr2,site_cof_inst_str,tmp_results); //not yet implemented
//
                  if(TI_FlashESDAEna and (not dlogonly))  
                     if((pattype==BANKTYPE) or (pattype==OTPTYPE))  
                        SetFlashESDAVars(tmp_results,bankcount,bankcount); //not yet implemented
                     else
                     {
//                        SetFlashESDAVars(tmp_results,bankcount,count); //not yet implemented
                     }
               } 
               
               testnum = testnum+1; 

//No Devsetholdstates analog in Unison so forget this code
//               if(faildetect and (not dlogonly))  
//                  if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//                     Devsetholdstates(final_results);
              
//               if(not v_any_dev_active)  
//                  break;
            }   /*for count*/
//            if(not v_any_dev_active)  
//               break;
         }   /*for bankcount*/
      }    /*+++ End of Bank operation +++*/
//
//       /*restore all active sites*/
//      Devsetholdstates(savesites);
//
//      if(not dlogonly)  
//         ResultsRecordActive(final_results, S_NULL);
//      else
//         ResultsRecordActive(savesites, S_NULL);         
//      TestClose;
//
//      test_results = final_results; //test_results removed from the arguments list
//      
//      if(TI_FlashCOFEna)  
//         F021_Save_COF_Info(tmpstr1,site_cof_inst_str,final_results); //not yet implemented
      
//      ttimer1 = timernread(ttimer1);
      ttimer1 = TIME.StopTimer();
      //tt_timer = ttimer1;

      tmpstr4 = tmpstr1 + "_TTT";
      //Unison is sited.  Don't need this
//      TWTRealToRealMS(tt_timer,realval,unitval);
      TWPDLDataLogRealVariable(tmpstr4, ttimer1.GetUnits(),ttimer1,TWMinimumData);

      if(tistdscreenprint)  
      {
          /*PrintHeaderBool(GL_PLELL_FORMAT);*/
//         PrintResultBool(tmpstr1,start_testnum,final_results,GL_PLELL_FORMAT); not yet implemented
         cout << "   TT " << ttimer1 << endl; 
         cout << endl;
         IO.Flush(IO.Stdout);
      }         /*if tistdscreenprint*/
      
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna) and (not dlogonly))  
//         DevSetHoldStates(final_results);
            
//   }   /*if v_any_dev_active*/

//   F021_Program_func = V_any_dev_active;
     return(final_results);
}   /*F021_Program_func*/
//   
//
 
TMResultM F021_Erase_func( IntS start_testnum, StringS tname) {

   IntM erspulse,cmptpulse,preconpulse;
   TMResultM final_results, test_results;
   IntS bankcount,count;
   IntS site,opertype,pattype;
   FloatS ttimer1,ttimer2;
   FloatM tt_timer = 0.0;
   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
   StringS tmpstr5;
   IntS testnum;
   FloatM FloatSval;
   StringS unitval;
   StringS fl_testname,fl_testname2;
   FloatS maxtime;
   IntS1D addr_loc(4);
   IntS length;
   BoolM logsites;
   IntS ers_llimit;
   IntM rti_timer;
   StringM site_cof_inst_str;
   IntS target_bits;
   BoolS ersstr_ena;
   IntS blkstart,blkstop;
   BoolS faildetect;
   

   if (tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ F021_Erase_func +++++" << endl;
   
   ersstr_ena = false;  // true = use to disable tw log, compare limits for fast/slow-ers stress
   
   tmpstr1 = tname;
   tname.Replace(tname.Find("_Test"), 5, "");   // remove _Test
   fl_testname = tname;
   
   TIME.StartTimer();

// Clear string function
//   if (TI_FlashCOFEna)  
//      F021_Init_COF_Inst_Str(site_cof_inst_str);

   testnum = start_testnum;

   target_bits = (testnum & 0x00000f00) >> 8;
   switch(target_bits) {
     case TARGET_BANK:    pattype = BANKTYPE; break;
     case TARGET_SECT:    pattype = SECTTYPE; break;
     case TARGET_OTP: 
     case TARGET_SEMIOTP: pattype = OTPTYPE;  break;
     default:             pattype = MODTYPE;  break;
   }

   // check bank/sector bits
   if ((((testnum&0x00000070)>>4)!=0) or ((testnum&0x0000000f)!=0)) {
      if (tistdscreenprint)  
         cout << "*** ERROR: Bank/Sector bits do not start @0." << 
                 "  Please double check!!! ***" << endl;
      if (not tistdscreenprint)  
         cout << "*** ERROR: Bank/Sector bits do not start @0." << 
                 "  Please double check!!! ***" << endl;
      pattype = MODTYPE;
   } 
  
   if ((((testnum & IntS(0xf0000000)) >>28 ) & 0x0000000f)!=0x6) {
      // check bit16
      if (((testnum&0x00010000)>>16)==1)  
         opertype = TOPT_W_PREC;
      else
         opertype = TOPT_WO_PREC;
      
      // check override pulse limits bit22
      if ((testnum&0x00400000)>0) {
         if (tistdscreenprint) {
            cout << endl;
            cout << "*** WARNING: OVERRIDE PULSE LIMITS are Enabled." << 
                    "  MAKE SURE THE INTENTION IS TO OVERRIDE <<  i.e. Engineering Debug Only ***" << endl;
            cout << endl;
         } 
         // make sure not use in production unless
         if (not TI_FlashCOFEna) {
            pattype = MODTYPE;
            if (tistdscreenprint)  
               cout << "*** PLS SET TI_FlashCOFEna true" << 
                       " TO OVERRIDE PULSE LIMITS. ***" << endl;
         } 
      } 
   }
   else {
      opertype = TOPT_WO_PREC;
   } 
      
   if (TI_FlashESDAEna) FLEsda.Pattype = pattype;

   
   if(pattype == MODTYPE) {
      // +++ Module operation +++
      final_results = TM_NOTEST;
      if (tistdscreenprint)  
         cout << "+++ WARNING : Invalid Test Number Entered +++" << endl;
   }
   else {
      // ++++++++ Bank operation ++++++++
      // KChau 03/27/08 - added ers_llimit so won"t fail on
      // erspulse of 0 for fast & slow erase tests since shell
      // don"t have pulse log at mstat3 location.
      if ((testnum==TNUM_BANK_ERS_STRESS_FAST) or
          (testnum==TNUM_BANK_ERS_STRESS_SLOW) or
          (testnum==TNUM_BANK_ERS_WEAK)) {
         ers_llimit = 1;
         ersstr_ena = true;
      }
      else
         ers_llimit = 0;

      maxtime = GL_F021_BANK_ERS_MAXTIME;

      for (bankcount = 0; bankcount <= F021_Flash.MAXBANK; ++bankcount) {
         if ((pattype==BANKTYPE) or (pattype==OTPTYPE)) {
            blkstart = bankcount;
            blkstop  = bankcount;
         }
         else if (pattype==BLOCKTYPE) {
            blkstart = 0;
            blkstop  = F021_Flash.MAXBLOCK[bankcount];
         }
         else {
            blkstart = 0;
            blkstop  = F021_Flash.MAXSECT[bankcount];
         } 

         testnum  = start_testnum+(bankcount<<4);

         for (count = blkstart; count <= blkstop; ++count) {
            faildetect = false;
            final_results = F021_RunTestNumber(testnum,maxtime,tt_timer);
            
            // TW strings
            tmpstr2 = "_B";  // _B#
//            tmpstr2 = CONV.IntToString(bankcount);  // Bug IntToStr can't convert zero (SPR142812)
            if ( bankcount == 0 ) tmpstr2 += "0";
            else                  tmpstr2 += CONV.IntToString(bankcount);
            
           
            if ((pattype==BLOCKTYPE) or (pattype==SECTTYPE)) {
            
               if (pattype==BLOCKTYPE)
                  tmpstr3 = "BLK";
               else
                  tmpstr3 = "S";
               
//            tmpstr3 = CONV.IntToString(bankcount);  // Bug IntToStr can't convert zero (SPR142812)
               if ( count == 0 ) tmpstr3 += "0";
               else              tmpstr3 += CONV.IntToString(count);
               tmpstr2 += tmpstr3;
            } 
            
            tmpstr3 = tmpstr1 + tmpstr2;
            tmpstr4 = tmpstr3 + "_TT";
            TIDlog.Value(tt_timer, UTL_VOID, 0, UTL_VOID, unitval, tmpstr4,
                         UTL_VOID, UTL_VOID, true, TWMinimumData, ER_PASS, false);
            
            if (not ersstr_ena) {
               erspulse = 0;
               
               if (opertype==1) {   // erase w/precon
                  preconpulse = 0;
                  Get_TLogSpace_MaxPPulse(preconpulse);
                  tmpstr4 = tmpstr3 + "_PREC_PLS";
                  final_results = TIDlog.Value(preconpulse, UTL_VOID, UTL_VOID, BANK_PRECON_ULimit, unitval, tmpstr4,
                                               UTL_VOID, UTL_VOID, true, TWMinimumData, ER_PASS, false);
               } 

               Get_TLogSpace_ErsPulse(erspulse);
               tmpstr4 = tmpstr3 + "_Ers_PLS";
               final_results = TIDlog.Value(erspulse, UTL_VOID, ers_llimit, BANK_ERS_ULimit, unitval, tmpstr4,
                                            UTL_VOID, UTL_VOID, true, TWMinimumData, ER_PASS, false);
               final_results = TIDlog.Value(cmptpulse, UTL_VOID, UTL_VOID, BANK_CMPT_ULimit, unitval, tmpstr3,
                                            UTL_VOID, testnum, false, TWMinimumData, ER_PASS, false);                            
            }
            else { /*fast/slow-ers*/
               ;
            }
            
            // log RTI timer (internal vclock cycle value) to tw
            rti_timer = 0;
            // GetRTIValue(rti_timer);
            tmpstr4 = tmpstr3 + "_RTI_TT";
            TIDlog.Value(rti_timer, UTL_VOID, 0, UTL_VOID, unitval, tmpstr4,
                         UTL_VOID, UTL_VOID, true, TWMinimumData, ER_PASS, false);

            if (not(final_results == TM_PASS)) {
               faildetect = true;
//                :TODO: TestWare Logging
//                F021_Log_FailPat_To_TW(tmpstr3,final_results,fl_testname);
               
               if (TI_FlashCOFEna)
                  ;
//                :TODO: Test string size
//                F021_Update_COF_Inst_Str(tmpstr2,site_cof_inst_str,final_results);

               if (TI_FlashESDAEna)  
                  if ((pattype==BANKTYPE) or (pattype==OTPTYPE))
//                   :TODO: ESDA
                     SetFlashESDAVars(final_results,bankcount,bankcount);
                  else
                     SetFlashESDAVars(final_results,bankcount,count);
            } 
            
            testnum = testnum+1; 
         }   // for count
      }   // for bankcount
   }   // +++ End of Bank operation +++

   test_results = DLOG.AccumulateResults(test_results, final_results);

//   COF = Continue-On-Fail
//   if (TI_FlashCOFEna)  
//      F021_Save_COF_Info(tmpstr1,site_cof_inst_str,final_results);
   
   tt_timer = TIME.StopTimer();

   tmpstr4 = tmpstr1 + "_TTT";
   TIDlog.Value(tt_timer, UTL_VOID, 0, UTL_VOID, unitval, tmpstr4,
                UTL_VOID, UTL_VOID, true, TWMinimumData, ER_PASS, false); 
   
   if (tistdscreenprint) {
      // PrintHeaderBool(GL_PLELL_FORMAT);
      // PrintResultBool(tmpstr1,start_testnum,final_results,GL_PLELL_FORMAT);
      cout << "   TT " << ttimer1 << endl;
      cout << endl;
   }
   
   if ((not RunAllTests) and (not TI_FlashCOFEna))
      ;
      // DevSetHoldStates(final_results);
   
   return(test_results);
}   // F021_Erase_func

//
//
TMResultM F021_Read_func(    IntS start_testnum,
                            StringS tname)
//                            BoolM test_results)
{
   const IntS TARGET_BANK = 0x0; 
   const IntS TARGET_SECT = 0x1; 
   const IntS TARGET_BLOCK = 0x2; 
   const IntS TARGET_LOGSECT = 0x3; 
   const IntS TARGET_OTP = 0x4; 
   const IntS TARGET_SEMIOTP = 0x5; 
   const IntS TARGET_DATAOTP = 0x6; 
//   const  TARGET_ARB = 0xA;  /* :MANUAL FIX REQUIRED: Unknown const type */

   BoolM v_any_dev_active;
   Sites savesites;
   TMResultM tmp_results,final_results,red_results;
   IntS bankcount,count;
   IntS site,opertype,pattype;
   FloatS ttimer1,ttimer2;
   FloatM tt_timer;
   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
   StringS tmpstr5,str1,str2;
   IntS testnum,redtnum;
   FloatM FloatSval;
//   TWUnit unitval; don't need this.  Just us GetUnits()
   StringS fl_testname;
   FloatS maxtime;
   IntS length;
   Sites logsites;
   IntM rti_timer;
   IntS setbitesda,prevtestnum;
   IntS imgnum,start_imgnum;
   StringM site_cof_inst_str;
   IntS target_bits,special_opt,tmpint;
   IntS blkstart,blkstop;
   BoolS faildetect,datalogonly;
//
//   if(V_any_dev_active)  
   if (ActiveSites.GetPassingSites().AnyEqual(true))
   {
      if(tistdscreenprint and TI_FlashDebug)  
         cout << "+++++ F021_Read_func +++++" << endl;      

//      writestring(tmpstr1,tname);
      tmpstr1 = tname.Substring(2,tname.Length()-6);
//      length = len(tmpstr1);
//      writestring(tmpstr1,mid(tmpstr1,2,length-6));
      fl_testname = tname;

      TIME.StartTimer();

//      PrintHeaderBool(GL_PLELL_FORMAT);
//
//      TestOpen(fl_testname);


      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
         //F021_Init_COF_Inst_Str basically clears the string to empty
         site_cof_inst_str = "";
//
//      savesites = V_dev_active;
      savesites = ActiveSites;
      tmp_results = TM_NOTEST;
      final_results = TM_NOTEST;
//      tmp_results = V_dev_active;
//      final_results = V_dev_active;
//
      testnum = start_testnum;
      target_bits = (testnum & 0x00000f00) >>8;
      //***** Begin Switch statement code *****
      if (target_bits == TARGET_BANK)
      {
         pattype = BANKTYPE;
      }
      else if (target_bits == TARGET_SECT)
      {
         pattype = SECTTYPE;
      }
      else if (target_bits == TARGET_BLOCK)
      {
         pattype = BLOCKTYPE;
      }
      else if ((target_bits == TARGET_OTP) || (target_bits == TARGET_SEMIOTP) || (target_bits == TARGET_DATAOTP))
      {
         pattype = OTPTYPE;
      }
      else
      {
         pattype = MODTYPE;
      }
      //***** End Switch statement code *****
//      switch(target_bits) {
//        case TARGET_BANK                : pattype = BANKTYPE;
//        case TARGET_SECT                : pattype = SECTTYPE;
//        case TARGET_BLOCK               : pattype = BLOCKTYPE;
//        TARGET_OTP, TARGET_SEMIOTP,
//        case TARGET_DATAOTP             : pattype = OTPTYPE;
//        default:     pattype = MODTYPE;
//      }   /*case*/
//
       /*check bank/sector bits*/
      if((((testnum&0x00000070)>>4)!=0) or ((testnum&0x0000000f)!=0))  
      {
         if(tistdscreenprint)  
            cout << "*** ERROR: Bank/Sector bits are not start @0." << 
                    "  Please double check!!! ***" << endl;
         if(not tistdscreenprint)  
            cout << "*** ERROR: Bank/Sector bits are not start @0." << 
                    "  Please double check!!! ***" << endl;
         pattype = MODTYPE;
      } 

       /*check if deplete tnum 0x43...*/
      tmpint = ((testnum&IntS(0xff000000)) >>24) & 0xff;
      if(tmpint==0x43)  
      {
         if(pattype==BANKTYPE)  
            special_opt = 1;
         else
            special_opt = 2;
         datalogonly = true;
      }
      else if(tmpint==0xB0)  
      {
         datalogonly = false;
         if(GL_DO_REDENA and (pattype!=OTPTYPE))  
            special_opt = 3;
         else
            special_opt = 0;
      }
      else
      {
         special_opt = 0;
         datalogonly = false;
      } 

      if(TI_FlashESDAEna)  
      {
         FLEsda.Tnum = start_testnum;
         FLEsda.Pattype  = pattype;
      } 

      
      if(pattype == MODTYPE)  
      {
          /*+++ Module operation +++*/
         final_results = TM_FAIL;
         if(tistdscreenprint)  
            cout << "+++ WARNING : Invalid Test Number Entered +++" << endl;
      }
      else
      {
          /*++++++++ Bank operation ++++++++*/

         maxtime = GL_F021_MAXTIME;

         for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
         {
            if((pattype==BANKTYPE) or (pattype==OTPTYPE))  
            {
               blkstart = bankcount;
               blkstop  = bankcount;
            }
            else if(pattype==BLOCKTYPE)  
            {
               blkstart = 0;
               blkstop  = F021_Flash.MAXBLOCK[bankcount];
            }
            else
            {
               blkstart = 0;
               blkstop  = F021_Flash.MAXSECT[bankcount];
            } 

            testnum  = start_testnum+(bankcount<<4);

            for (count = blkstart;count <= blkstop;count++)
            {
               faildetect = false;
               //logsites = v_dev_active;
               logsites = ActiveSites;

                /*log to TW*/
               //writestring(tmpstr2,bankcount:1);
               if (bankcount ==0) tmpstr2 = "0";
               else tmpstr2 = CONV.IntToString(bankcount);
               
               tmpstr2 = "_B" + tmpstr2;  /*_B#*/
               
               if((pattype==BLOCKTYPE) or (pattype==SECTTYPE))  
               {
                  //writestring(tmpstr3,count:1);
                  if (count == 0) tmpstr3 = "0";
                  else tmpstr3 = CONV.IntToString(count);
                  
                  if(pattype==BLOCKTYPE)  
                     tmpstr3 = "BLK" + tmpstr3;
                  else
                     tmpstr3 = "S" + tmpstr3;
                  tmpstr2 = tmpstr2 + tmpstr3;
               } 
               
               tmpstr3 = tmpstr1 + tmpstr2;  /*now has xx_B#*/

               if(special_opt==3)  
               {
                  redtnum = testnum+TNUM_REDUNDENA;
                  red_results = F021_RunTestNumber(redtnum,maxtime,tt_timer);
                  //PrintResultBool(tmpstr3,redtnum,red_results,GL_PLELL_FORMAT); //Not yet implemented
               } 
                  
               tmp_results = F021_RunTestNumber(testnum,maxtime,tt_timer);
//               if(tistdscreenprint)  
//                  PrintResultBool(tmpstr3,testnum,tmp_results,GL_PLELL_FORMAT); //Not yet implemented

               if(special_opt==3)  
//                  ArrayAndBoolean(tmp_results,tmp_results,red_results,v_sites);
                  tmp_results = tmp_results & red_results;

//               ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
               final_results = final_results & tmp_results;               
               tmpstr4 = tmpstr3 + "_TT";
//               TWTRealToRealMS(tt_timer,realval,unitval); //don't need to sens tt_timer to realval in Unison
               TWPDLDataLogRealVariable(tmpstr4, tt_timer.GetUnits(),tt_timer,TWMinimumData);

                /*log RTI timer (internal vclock cycle value) to tw*/
               rti_timer = 0;
//               GetRTIValue(rti_timer);
               tmpstr4 = tmpstr3 + "_RTI_TT";
               TWPDLDataLogVariable(tmpstr4,rti_timer, TWMinimumData);
//               
//               if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))
               if(!(ActiveSites == logsites))  
               {
                  if(not datalogonly)  
                  {
                     faildetect = true;
//                     F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
//                     
                     if(TI_FlashCOFEna)  
                        //F021_Update_COF_Inst_Str(tmpstr2,site_cof_inst_str,tmp_results);
                        if (tmp_results == TM_FAIL)
                           site_cof_inst_str = site_cof_inst_str + tmpstr2;
                     
                     if(TI_FlashESDAEna)  
                        if((pattype==BANKTYPE) or (pattype==OTPTYPE))  
                           SetFlashESDAVars(tmp_results,bankcount,bankcount);
                        else
                           SetFlashESDAVars(tmp_results,bankcount,count);
                  } 
               } 

               testnum = testnum+1;

               if(faildetect and (not datalogonly))  
//                  if((not TIIgnoreFail) and (not TI_FlashCOFEna))  //Not sure why TIIgnoreFail doesn't come through
                  if(not TI_FlashCOFEna)
                     //Devsetholdstates(final_results);
                     ActiveSites.DisableFailingSites(final_results==TM_FAIL);
               
               //if(not v_any_dev_active)  
               if(!ActiveSites.GetPassingSites().AnyEqual(true))
                  break;
            }   /*for count*/
            //if(not v_any_dev_active) 
            if(!ActiveSites.GetPassingSites().AnyEqual(true))
               break;
         }   /*for bankcount*/
      }    /*+++ End of Bank operation +++*/

//       /*restore all active sites*/
//      Devsetholdstates(savesites);
      v_any_dev_active = SetActiveSites(savesites);    
//
//      if(not datalogonly)  
//         ResultsRecordActive(final_results, S_NULL);
//      else
//         ResultsRecordActive(savesites, S_NULL);
//      TestClose;

//      test_results = final_results;

      if(TI_FlashCOFEna)  
//         F021_Save_COF_Info(tmpstr1,site_cof_inst_str,final_results);
      
      ttimer1 = TIME.GetTimer(); //timernread(ttimer1);
      tt_timer = ttimer1;

      tmpstr4 = tmpstr1 + "_TTT";
//      TWTRealToRealMS(tt_timer,realval,unitval); //don't need to do this in Unison
      TWPDLDataLogRealVariable(tmpstr4, tt_timer.GetUnits(),tt_timer,TWMinimumData);

      if(tistdscreenprint)  
      {
          /*PrintHeaderBool(GL_PLELL_FORMAT);*/
         //PrintResultBool(tmpstr1,start_testnum,final_results,GL_PLELL_FORMAT); //not yet declared
         cout << "   TT " << ttimer1 << endl;
         cout << endl;
      }   /*if tistdscreenprint*/

      if(datalogonly and ((special_opt==1) or (special_opt==2)))  
      {
         if(special_opt==1)  
         {
            str1 = "DEPLT_BANK_FAIL_";
            str2 = "DEPLT_BANK_PASS_";
         }
         else
         {
            str1 = "DEPLT_SECT_FAIL";
            str2 = "DEPLT_SECT_PASS";
         } 
         
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               if(not final_results[site])
               if (final_results == TM_FAIL)  
                  GL_F021_LOG_SOFTBIN_STAT = GL_F021_LOG_SOFTBIN_STAT + str1;
               else
                  GL_F021_LOG_SOFTBIN_STAT = GL_F021_LOG_SOFTBIN_STAT + str2;
//            } 
         
         TWPDLDataLogText("FL_SOFTBIN_STAT",GL_F021_LOG_SOFTBIN_STAT,TWMinimumData);
      }   /*if datalogonly*/
//      
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna) and (not datalogonly))  
//         DevSetHoldStates(final_results);
//            
   }   /*if v_any_dev_active*/
//
//   F021_Read_func = V_any_dev_active;
    return (final_results);
}   /*F021_Read_func*/
//   
//
// /*Fletcher checksum: 16-bit data chunk, return 32-bit checksum*/
// /*efbinstring: binary string (expect msb-lsb).  chksum2: upper 16-bit chksum, chksum1: lower 16-bit chksum*/
//BoolS CalcChksum_FlashEfuse_func(    StringM efbinstring,
//                                        IntM chksum1,
//                                        IntM chksum2)
//{
//   IntS site;
//   StringM efstr;
//   StringS tmpstr;
//   IntS totlen,numword;
//   IntS count,tdata;
//   IntM sum1,sum2,slen;
//   IntS sseed,numbit;
//   BoolS validlen,dbugprint;
//
//   dbugprint = false;
//   sseed  = 0xffff;
//   numbit = 16;
//   sum1 = sseed;
//   sum2 = sseed;
//
//   validlen = true;
//   totlen = 0;
//
//    /*check for valid string length site-to-site*/
//   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      if(v_dev_active[site])  
//      {
//         efstr[site] = efbinstring[site];
//         slen[site] = len(efstr[site]);
//         if(totlen==0)  
//            totlen = slen[site];
//         if((totlen!=slen[site]) or (totlen==0))  
//         {
//            validlen = false;
//            if(tistdscreenprint)  
//               cout << "*** Invalid Flash Efuse String !!! ***" << endl;
//            break;
//         } 
//      } 
//
//   if(validlen and (totlen>0))  
//   {
//#if TUIVERSION >== "3.9a"  
//      numword = round(ceiling(totlen/numbit));;
//#else
//      if((totlen mod numbit)>0)  
//     numword = (totlen div numbit) + 1;
//      else
//     numword = (totlen div numbit);
//#endif
//
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            if(tistdscreenprint and dbugprint)  
//               cout << "Site" << site:-4 << "Efuse string: " << efstr[site] << endl;
//            for (count = 1;count <= numword;count++)
//            {
//               totlen = len(efstr[site]);               
//
//               if(totlen>==numbit)  
//               {
//                  tmpstr = mid(efstr[site],1,numbit);
//                  if((totlen-numbit)>0)  
//                     efstr[site] = mid(efstr[site],(1+numbit),(totlen-numbit));
//                  else
//                     efstr[site] = "";
//               }
//               else
//               {
//                  tmpstr = mid(efstr[site],1,totlen);
//               }   /*if-else*/
//
//               readstring("0b" + tmpstr) + tdata;
//               sum1[site] = sum1[site]+tdata;
//               sum2[site] = sum2[site]+sum1[site];
//               if(tistdscreenprint and dbugprint)  
//                  cout << "Count : " << count:-5 << "Site" << site:-3 << "data==" << tdata:10 << " sum1==" << 
//                          sum1[site]:s_hex << endl; /*:-10},"  sum2=",sum2[site]:s_hex{:-10*/
//            }   /*for count*/
//
//            sum1[site] = (sum1[site]&sseed)+(sum1[site]>>numbit);
//            sum2[site] = (sum2[site]&sseed)+(sum2[site]>>numbit);
//
//             /*if(tistdscreenprint and dbugprint) then
//                writeln(tiwindow,"After 1st shifting, Site",site:-4," sum1=",
//                        sum1[site]:s_hex:-10,"  sum2=",sum2[site]:s_hex:-10);*/
//
//             /*2nd shifting to reduce sum to 16 bits*/
//            sum1[site] = (sum1[site]&sseed)+(sum1[site]>>numbit);
//            sum2[site] = (sum2[site]&sseed)+(sum2[site]>>numbit);
//
//             /*if(tistdscreenprint and dbugprint) then
//             begin
//                writeln(tiwindow,"After 2nd shifting, Site",site:-4," sum1=",
//                        sum1[site]:s_hex:-10,"  sum2=",sum2[site]:s_hex:-10);
//                writeln(tiwindow);
//             end;*/
//         }   /*if v_dev_active*/
//   }   /*if validlen*/
//
//   if(tistdscreenprint)  
//      cout << endl;
//
//   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      if(v_dev_active[site])  
//      {
//         chksum1[site] = sum1[site];
//         chksum2[site] = sum2[site];         
//         if(tistdscreenprint)  
//            cout << "Site" << site:-4 << "Flash Efuse CheckSum (msw-lsw)== " << 
//                    chksum2[site]:s_hex << chksum1[site]:s_hex << endl;
//      } 
//
//   if(tistdscreenprint)  
//      cout << endl;
//
//    /*save to global vars for later use*/
//   EFCHKSUM_MSW = sum2;
//   EFCHKSUM_LSW = sum1;
//
//   CalcChksum_FlashEfuse_func = validlen;
//}   /* CalcChksum_FlashEfuse_func */
//   
//   
//
//BoolS Compare_FlashEfuse_OTP_Chksum_func(    StringS tname,
//                                                BoolM test_results)
//{
//   BoolM savesites,logsites;
//   BoolM tmp_results,final_results;
//   IntS site,bankcount,length;
//   FloatS ttimer1,ttimer2;
//   FloatM tt_timer;
//   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
//   FloatM FloatSval;
//   TWunit unitval;
//   StringS fl_testname;
//   StringM site_cof_inst_str;
//   IntM chksum_msw,chksum_lsw;
//   IntM echksum_msw,echksum_lsw;
//   StringM chksum_msw_str,chksum_lsw_str;
//   StringM echksum_msw_str,echksum_lsw_str;
//   BoolS do_once;
//
//   if(V_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ Compare_FlashEfuse_OTP_Chksum_func +++++" << endl;
//
//      writestring(tmpstr1,tname);
//      length = len(tmpstr1);
//      writestring(tmpstr1,mid(tmpstr1,2,length-6));  /*remove _Test*/
//      fl_testname = tname;
//      
//      TestOpen(fl_testname);
//
//      timernstart(ttimer1);      
//
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//
//      savesites = V_dev_active;
//      final_results = V_dev_active;
//      chksum_msw = 0;
//      chksum_lsw = 0;
//
//      if not(CalcChksum_FlashEfuse_func(SaveFlashProgString,chksum_lsw,chksum_msw))  
//      {
//         final_results = false;
//      }
//      else
//      {
//         do_once = false;
//         for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//         {
//            tmp_results = v_dev_active;
//            logsites = v_dev_active;
//            
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            {
//               if(v_dev_active[site])  
//               {
//                  if(not do_once)  
//                  {
//                     writestring(chksum_msw_str[site],chksum_msw[site]:s_hex:1);
//                     writestring(chksum_lsw_str[site],chksum_lsw[site]:s_hex:1);
//                  } 
//                     
//                  echksum_msw[site] = FRM_OTP_BANK_EFSUM_HI_VAL[bankcount][site];
//                  echksum_lsw[site] = FRM_OTP_BANK_EFSUM_LO_VAL[bankcount][site];
//                  writestring(echksum_msw_str[site],echksum_msw[site]:s_hex:1);
//                  writestring(echksum_lsw_str[site],echksum_lsw[site]:s_hex:1);
//                  
//                  if((echksum_msw[site]!=chksum_msw[site]) or
//                     (echksum_lsw[site]!=chksum_lsw[site]))  
//                  {
//                     final_results[site] = false;
//                     tmp_results[site] = false;
//                  } 
//
//                  if(tistdscreenprint)  
//                     cout << "Site" << site:-5 << "EXP CHKSUM (MSW << LSW) == " << 
//                             echksum_msw_str[site]:-7 << echksum_lsw_str[site]:-7 << " ":5 << 
//                             "ACT == " << chksum_msw_str[site]:-7 << chksum_lsw_str[site]:-7 << endl;
//               }   /*if v_dev_active*/
//            }   /*for site*/
//
//             /*log to TW*/
//            if(not do_once)  
//            {
//               TWPDLDataLogText("FL_EFCSUM_ACT_MSW",chksum_msw_str,TWMinimumData);
//               TWPDLDataLogText("FL_EFCSUM_ACT_LSW",chksum_lsw_str,TWMinimumData);
//               do_once = true;
//            } 
//            
//            writestring(tmpstr2,bankcount:1);
//            tmpstr2 = "_B" + tmpstr2;  /*_B#*/
//
//            tmpstr3 = "FL_EFCSUM_EXP_MSW" + tmpstr2;
//            TWPDLDataLogText(tmpstr3,echksum_msw_str,TWMinimumData);
//            tmpstr3 = "FL_EFCSUM_EXP_LSW" + tmpstr2;
//            TWPDLDataLogText(tmpstr3,echksum_lsw_str,TWMinimumData);
//
//             /*log failed test to tw*/
//             /*KChau 12/21/07 - determine if any site is failing to log to TW.*/
//            if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//            {
//               tmpstr3 = tmpstr1 + tmpstr2;
//               F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
//               if(TI_FlashCOFEna)  
//                  F021_Update_COF_Inst_Str(tmpstr2,site_cof_inst_str,tmp_results);
//            } 
//            
//            if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//               Devsetholdstates(final_results);
//
//            if(not v_any_dev_active)  
//               break;
//
//         }   /*for bankcount*/
//      }    /*if-else*/
//
//       /*restore all active sites*/
//      Devsetholdstates(savesites);
//
//      ResultsRecordActive(final_results, S_NULL);
//      TestClose;
//
//      test_results = final_results;
//      
//      if(TI_FlashCOFEna)  
//         F021_Save_COF_Info(tmpstr1,site_cof_inst_str,final_results);
//      
//      ttimer1 = timernread(ttimer1);
//      tt_timer = ttimer1;
//
//      tmpstr4 = tmpstr1 + "_TTT";
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//      
//      if(tistdscreenprint)  
//      {
//         PrintHeaderBool(GL_PLELL_FORMAT);
//         PrintResultBool(tmpstr1,0,final_results,GL_PLELL_FORMAT);
//      } 
//
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//         DevSetHoldStates(final_results);
//            
//   }   /*if v_any_dev_active*/
//
//   Compare_FlashEfuse_OTP_Chksum_func = V_any_dev_active;
//}   /* Compare_FlashEfuse_OTP_Chksum_func */
//   
//void Get_Flash_MBoxSpace_OTP_SCRAM()
//{
//   IntS addr,store_option;
//   FloatS ttimer1;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint)  
//         cout << "*** Get_Flash_MBoxSpace_OTP_SCRAM ***" << endl;
//
//      timernstart(ttimer1);
//      addr = ADDR_RAM_MAILBOX;
//      store_option = ord(MBOXOTP_ARR);
//      GetRamContent_SCRAM(addr,store_option);
//      if(tistdscreenprint)  
//         cout << " Get_Flash_MBoxSpace_OTP_SCRAM TT : " << timernread(ttimer1) << endl;
//   }    
//}   /* Get_Flash_MBoxSpace_OTP_SCRAM */
//
//void Get_MBoxSpace_FlagNum(    IntM msw_data,
//                                    IntM lsw_data)
//{
//   const IntS X16_IND1 = 1; 
//   const IntS X16_IND0 = 2; 
//
//   IntS addr_loc,site;
//   IntM msw_val,lsw_val;
//
//   if(v_any_dev_active)  
//   {
//      if(GL_DO_ESDA_WITH_SCRAM)  
//      {
//         msw_val = FL_SCRAM_CAPT_ARR[X16_IND1];
//         lsw_val = FL_SCRAM_CAPT_ARR[X16_IND0];
//      }
//      else
//      {
//         addr_loc = ADDR_RAM_MAILBOX;
//         GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,lsw_val);
//         GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_val);
//      } 
//
//      msw_data = msw_val;
//      lsw_data = lsw_val;
//   } 
//}   /* Get_MBoxSpace_FlagNum */
//
// /*rownum = 0,1,2,...*/
// /*wdnum  = 0,1,2,...,6,7 (i.e. 16bit word per row)*/
//void Get_MBoxSpace_RowX_WdX(      IntS rownum, IntS wdnum,
//                                     IntM ret_val)
//{
//   const IntS X16_IND1 = 3; 
//
//   IntS addr_loc,site;
//   IntM msw_val,lsw_val;
//   IntS msw_off,lsw_off,wd_off;
//
//   if(v_any_dev_active)  
//   {
//      if(GL_DO_ESDA_WITH_SCRAM)  
//      {
//         msw_off = (rownum*8)+X16_IND1;
//         wd_off = wdnum+msw_off;
//         msw_val = FL_SCRAM_CAPT_ARR[wd_off];
//      }
//      else
//      {
//         addr_loc = ADDR_RAM_MAILBOX;
//         msw_off = (rownum*4)+1;
//         wd_off = wdnum div 2;
//         addr_loc = addr_loc + ((msw_off+wd_off)*ADDR_RAM_INC);
//
//         lsw_off = wdnum mod 2;
//         if(lsw_off == 0)  
//            GetRamContentDec_16bit(ramread_nburst_msw,addr_loc,msw_val);
//         else
//            GetRamContentDec_16bit(ramread_nburst_lsw,addr_loc,msw_val);
//      } 
//
//      ret_val = msw_val;
//   } 
//}   /* Get_MBoxSpace_RowX_WdX */
//   
//
//void Get_MBoxSpace_BCCVT(BoolS rdbcc,
//                              IntS banknum,
//                              IntS index)
//{
//   IntS site,bank,count,loop,row,length;
//   IntS numword,numword_max,tmp_value;
//   IntM value;
//   StringM temp_bcd;
//   StringS str1,str2,str3;
//   BoolM tmp_results;
//   FloatM bccval;
//   vttype vt_type; 
//
//   if(v_any_dev_active)  
//   {
//      if(index<==3)  
//      {
//         count = index+1;
//         writestring(str3,count:1);
//         if(rdbcc)  
//            str3 = "BCC0_PreBK" + str3;
//         else
//            str3 = "VT0_PreBK" + str3;
//         str3 = str3 + "_";
//         vt_type = CHKVT0DRL;
//      }
//      else
//      {
//         count = index-3;
//         writestring(str3,count:1);
//         if(rdbcc)  
//            str3 = "BCC1_PreBK" + str3;
//         else
//            str3 = "VT1_PreBK" + str3;
//         str3 = str3 + "_";
//         vt_type = CHKVT1DRL;
//      } 
//
//      if(tistdscreenprint)  
//      {
//         PrintHeaderParam(GL_PLELL_FORMAT);
//         tmp_results = v_dev_active;
//      } 
//      
//      loop = index;
//      bank = banknum;
//      numword = 0;
//
//      if(tistdscreenprint)  
//      {
//         writestring(str2,bank:1);
//         str2 = "B" + str2;
//      } 
//
//      if(rdbcc)  
//      {
//         if(MainBCC.MEMCFG[vt_type]==BANKTYPE)  
//         {
//            numword_max = numword;
//         }
//         else if(MainBCC.MEMCFG[vt_type]==BLOCKTYPE)  
//         {
//            numword_max = F021_Flash.MAXBLOCK[bank];
//         }
//         else
//         {
//            numword_max = F021_Flash.MAXSECT[bank];
//         } 
//      }
//      else
//      {
//         if(MainVT.MEMCFG[vt_type]==BANKTYPE)  
//         {
//            numword_max = numword;
//         }
//         else if(MainVT.MEMCFG[vt_type]==QUADTYPE)  
//         {
//        numword_max = FL_MAX_QUADRANT;
//         }
//         else if(MainVT.MEMCFG[vt_type]==BLOCKTYPE)  
//         {
//            numword_max = F021_Flash.MAXBLOCK[bank];
//         }
//         else
//         {
//            numword_max = F021_Flash.MAXSECT[bank];
//         } 
//      } 
//
//       /*numword_max+1 to include otp value retrieval*/
//      for (row = numword;row <= (numword_max+1);row++)
//      {
//         Get_MBoxSpace_RowX_WdX(row,loop,value);
//         count = (row*8)+loop;   /*from 0..127*/
//         
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               writestring(temp_bcd[site],value[site]:s_hex:1);
//               length = len(temp_bcd[site]);
//               writestring(temp_bcd[site],mid(temp_bcd[site],3,length-2));
//               switch((length-2)) {
//                 case 1 : temp_bcd[site] = "000" + temp_bcd[site];
//                 case 2 : temp_bcd[site] = "00" + temp_bcd[site];
//                 case 3 : temp_bcd[site] = "0" + temp_bcd[site];
//               }   /*case*/
//               
//               if(rdbcc)  
//               {
//                  OTP_BCC_INFO_INTVAL[bank][count][site] = value[site];  /*use for otp restore at mp3*/
//                  OTP_BCC_INFO[bank][count][site]=temp_bcd[site];
//               }
//               else
//                  OTP_VT_INFO[bank][count][site]=temp_bcd[site];
//                  
//               tmp_value = 0;
//               str1 = temp_bcd[site];
//               stringtoint(str1,tmp_value);
//
//               if(rdbcc)  
//               {
//                  bccval[site] = (tmp_value/100)*1uA;
//                  switch(index) {
//                    case  0: case 4 :   
//                        /*store mp1 value @mp2 for drl*/
//                       if(TITestType==MP2)  
//                        
//                           /*OTP_BCC_INFO_VAL[bank,count,site] := bccval[site];} {don"t need this var*/
//                          if(row<==numword_max)  
//                             BANK_BCC_VALUE[bank][row][vt_type][pre][site] = bccval[site];
//                          else
//                             OTP_BCC_VALUE[bank][vt_type][pre][site] = bccval[site];
//                        break; 
//                     break; 
//                    case  1: case 5 :   
//                        /*store mp2 value @mp3 for drl*/
//                       if(TITestType==MP3)  
//                        
//                          if(row<==numword_max)  
//                             BANK_BCC_VALUE[bank][row][vt_type][pre][site] = bccval[site];
//                          else
//                             OTP_BCC_VALUE[bank][vt_type][pre][site] = bccval[site];
//                        break; 
//                     break; 
//                    case  2: case 6 :   
//                        /*store mp3 value @preburin for drl*/
//                       if(TITestType==PreBurnIn)  
//                        
//                          if(row<==numword_max)  
//                             BANK_BCC_VALUE[bank][row][vt_type][pre][site] = bccval[site];
//                          else
//                             OTP_BCC_VALUE[bank][vt_type][pre][site] = bccval[site];
//                        break; 
//                     break; 
//                    case  3: case 7 :   
//                        /*store preburnin value @postburin1 for drl*/
//                       if(TITestType==PostBurnIn1)  
//                        
//                          if(row<==numword_max)  
//                             BANK_BCC_VALUE[bank][row][vt_type][pre][site] = bccval[site];
//                          else
//                             OTP_BCC_VALUE[bank][vt_type][pre][site] = bccval[site];
//                        break; 
//                     break; 
//                  }   /* case */
//               }
//               else
//               {
//                  bccval[site] = (tmp_value/100)*1V;
//                   /*OTP_VT_INFO_VAL[bank,count,site] := (tmp_value/100)*1V;} {don"t need this var*/
//                  switch(index) {
//                    case  0: case 4 :   
//                        /*store mp1 value @mp2 for drl*/
//                       if(TITestType==MP2)  
//                        
//                          if(row<==numword_max)  
//                             BANK_VT_VALUE[bank][row][vt_type][pre][site] = bccval[site];
//                          else
//                             OTP_VT_VALUE[bank][vt_type][pre][site] = bccval[site];
//                        break; 
//                     break; 
//                    case  1: case 5 :   
//                        /*store mp2 value @mp3 for drl*/
//                       if(TITestType==MP3)  
//                        
//                          if(row<==numword_max)  
//                             BANK_VT_VALUE[bank][row][vt_type][pre][site] = bccval[site];
//                          else
//                             OTP_VT_VALUE[bank][vt_type][pre][site] = bccval[site];
//                        break; 
//                     break; 
//                    case  2: case 6 :   
//                        /*store mp3 value @preburin for drl*/
//                       if(TITestType==PreBurnIn)  
//                        
//                          if(row<==numword_max)  
//                             BANK_VT_VALUE[bank][row][vt_type][pre][site] = bccval[site];
//                          else
//                             OTP_VT_VALUE[bank][vt_type][pre][site] = bccval[site];
//                        break; 
//                     break; 
//                    case  3: case 7 :   
//                        /*store preburnin value @postburin1 for drl*/
//                       if(TITestType==PostBurnIn1)  
//                        
//                          if(row<==numword_max)  
//                             BANK_VT_VALUE[bank][row][vt_type][pre][site] = bccval[site];
//                          else
//                             OTP_VT_VALUE[bank][vt_type][pre][site] = bccval[site];
//                        break; 
//                     break; 
//                  }   /* case */
//               } 
//                  
//            }   /*if v_dev_active*/
//         
//         if(tistdscreenprint)  
//         {
//            writestring(str1,row:1);
//            str1 = "_Row" + str1;
//            str1 = str2 + str1;
//            str1 = str3 + str1;
//            if(rdbcc)  
//            {
//               PrintResultParam(str1,0,tmp_results,0ua,0ua,bccval,GL_PLELL_FORMAT);
//            }
//            else
//            {
//               PrintResultParam(str1,0,tmp_results,0v,0v,bccval,GL_PLELL_FORMAT);
//            } 
//         } 
//      }   /*for row*/
//   }   /*v_any_dev_active*/
//} 
//
//
//void Get_PreBake1_BCC0(IntS bank)
//{
//   IntS index;
//   BoolS rdbcc;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "*** Get_PreBake1_BCC0 ***" << endl;
//
//      if(MainBCC.MEMCFG[CHKVT0] != MainBCC.MEMCFG[CHKVT0DRL])  
//      {
//         cout << "!!!" << endl;
//         cout << "!!! INVALID MainBCC.MEMCFG[CHKVT0] and MEMCFG[CHKVT0DRL] !!!" << endl;
//         cout << "!!!" << endl;
//      } 
//
//      rdbcc = true;
//      index = 0;
//      Get_MBoxSpace_BCCVT(rdbcc,bank,index);
//   }   /*v_any_dev_active*/
//}   /* Get_PreBake1_BCC0 */
//
//void Get_PreBake1_BCC1(IntS bank)
//{
//   IntS index;
//   BoolS rdbcc;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "*** Get_PreBake1_BCC1 ***" << endl;
//
//      if(MainBCC.MEMCFG[CHKVT1] != MainBCC.MEMCFG[CHKVT1DRL])  
//      {
//         cout << "!!!" << endl;
//         cout << "!!! INVALID MainBCC.MEMCFG[CHKVT1] and MEMCFG[CHKVT1DRL] !!!" << endl;
//         cout << "!!!" << endl;
//      } 
//
//      rdbcc = true;
//      index = 4;
//      Get_MBoxSpace_BCCVT(rdbcc,bank,index);
//   }   /*v_any_dev_active*/
//}   /* Get_PreBake1_BCC1 */
//   
//void Get_PreBake2_BCC0(IntS bank)
//{
//   IntS index;
//   BoolS rdbcc;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "*** Get_PreBake2_BCC0 ***" << endl;
//
//      if(MainBCC.MEMCFG[CHKVT0] != MainBCC.MEMCFG[CHKVT0DRL])  
//      {
//         cout << "!!!" << endl;
//         cout << "!!! INVALID MainBCC.MEMCFG[CHKVT0] and MEMCFG[CHKVT0DRL] !!!" << endl;
//         cout << "!!!" << endl;
//      } 
//
//      rdbcc = true;
//      index = 1;
//      Get_MBoxSpace_BCCVT(rdbcc,bank,index);
//   }   /*v_any_dev_active*/
//}   /* Get_PreBake2_BCC0 */
//
//void Get_PreBake2_BCC1(IntS bank)
//{
//   IntS index;
//   BoolS rdbcc;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "*** Get_PreBake2_BCC1 ***" << endl;
//
//      if(MainBCC.MEMCFG[CHKVT1] != MainBCC.MEMCFG[CHKVT1DRL])  
//      {
//         cout << "!!!" << endl;
//         cout << "!!! INVALID MainBCC.MEMCFG[CHKVT1] and MEMCFG[CHKVT1DRL] !!!" << endl;
//         cout << "!!!" << endl;
//      } 
//
//      rdbcc = true;
//      index = 5;
//      Get_MBoxSpace_BCCVT(rdbcc,bank,index);
//   }   /*v_any_dev_active*/
//}   /* Get_PreBake2_BCC1 */
//   
//void Get_PreBake3_BCC0(IntS bank)
//{
//   IntS index;
//   BoolS rdbcc;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "*** Get_PreBake3_BCC0 ***" << endl;
//
//      if(MainBCC.MEMCFG[CHKVT0] != MainBCC.MEMCFG[CHKVT0DRL])  
//      {
//         cout << "!!!" << endl;
//         cout << "!!! INVALID MainBCC.MEMCFG[CHKVT0] and MEMCFG[CHKVT0DRL] !!!" << endl;
//         cout << "!!!" << endl;
//      } 
//
//      rdbcc = true;
//      index = 2;
//      Get_MBoxSpace_BCCVT(rdbcc,bank,index);
//   }   /*v_any_dev_active*/
//}   /* Get_PreBake3_BCC0 */
//
//void Get_PreBake3_BCC1(IntS bank)
//{
//   IntS index;
//   BoolS rdbcc;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "*** Get_PreBake3_BCC1 ***" << endl;
//
//      if(MainBCC.MEMCFG[CHKVT1] != MainBCC.MEMCFG[CHKVT1DRL])  
//      {
//         cout << "!!!" << endl;
//         cout << "!!! INVALID MainBCC.MEMCFG[CHKVT1] and MEMCFG[CHKVT1DRL] !!!" << endl;
//         cout << "!!!" << endl;
//      } 
//
//      rdbcc = true;
//      index = 6;
//      Get_MBoxSpace_BCCVT(rdbcc,bank,index);
//   }   /*v_any_dev_active*/
//}   /* Get_PreBake3_BCC1 */
//   
//void Get_PreBake4_BCC0(IntS bank)
//{
//   IntS index;
//   BoolS rdbcc;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "*** Get_PreBake4_BCC0 ***" << endl;
//
//      if(MainBCC.MEMCFG[CHKVT0] != MainBCC.MEMCFG[CHKVT0DRL])  
//      {
//         cout << "!!!" << endl;
//         cout << "!!! INVALID MainBCC.MEMCFG[CHKVT0] and MEMCFG[CHKVT0DRL] !!!" << endl;
//         cout << "!!!" << endl;
//      } 
//
//      rdbcc = true;
//      index = 3;
//      Get_MBoxSpace_BCCVT(rdbcc,bank,index);
//   }   /*v_any_dev_active*/
//}   /* Get_PreBake4_BCC0 */
//
//void Get_PreBake4_BCC1(IntS bank)
//{
//   IntS index;
//   BoolS rdbcc;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "*** Get_PreBake4_BCC1 ***" << endl;
//
//      if(MainBCC.MEMCFG[CHKVT1] != MainBCC.MEMCFG[CHKVT1DRL])  
//      {
//         cout << "!!!" << endl;
//         cout << "!!! INVALID MainBCC.MEMCFG[CHKVT1] and MEMCFG[CHKVT1DRL] !!!" << endl;
//         cout << "!!!" << endl;
//      } 
//
//      rdbcc = true;
//      index = 7;
//      Get_MBoxSpace_BCCVT(rdbcc,bank,index);
//   }   /*v_any_dev_active*/
//}   /* Get_PreBake4_BCC1 */
//   
//
//BoolS F021_ReadBCCOTP_func(    BoolM test_results,
//                                  BoolS binout_ena)
//{
//   IntS bankcount,count,loop,row;
//   IntS site,rd_flag_num,length,addr;
//   IntS start_tnum,testnum,store_option;
//   IntS numword,numword_max,tmp_value;
//   IntM msw_data,lsw_data;
//   FloatM tt_timer;
//   BoolM final_results,tmp_results;
//   FloatS maxtime;
//   StringM temp_bcd;
//   StringS str1;
//   IntS index_bankvt0,index_bankvt1;
//   IntS index_otpvt0,index_otpvt1;
//
//   if(v_any_dev_active)  
//   {
//      start_tnum = TNUM_OTP_RD_VT_MBOX;
//      maxtime = GL_F021_MAXTIME;
//      rd_flag_num = 0x4321;
//      numword     = 0;
//      numword_max = 127;
//
//      final_results = v_dev_active;
//      
//      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//      {
//         testnum = start_tnum+(bankcount<<4);
//         tmp_results = v_dev_active;
//         F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results);
//
//         if(GL_DO_ESDA_WITH_SCRAM)  
//            Get_Flash_MBoxSpace_OTP_SCRAM;
//         
//         Get_MBoxSpace_FlagNum(msw_data,lsw_data);
//         
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//                /*if(lsw_data[site]<>data_flag_num) then
//                 tmp_results[site] := false;*/
//               if(msw_data[site]!=rd_flag_num)  
//               {
//                  tmp_results[site] = false;
//                  if(tistdscreenprint)  
//                     cout << "Site " << site:-4 << " Read Flag Not Matched " << 
//                             msw_data[site]:s_hex:-8 << " Expect of " << rd_flag_num:s_hex:-8 << endl;
//               } 
//            } 
//         
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//
//         loop = 0;
//         row  = 0;
//         
//         for (count = numword;count <= numword_max;count++)
//         {
//            Get_MBoxSpace_RowX_WdX(row,loop,lsw_data);
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  OTP_BCC_INFO_INTVAL[bankcount][count][site] = lsw_data[site];
//                   /*convert int number to hex string w/ 0x prefix*/
//                  writestring(temp_bcd[site],lsw_data[site]:s_hex:1);
//                   /*extract string w/o 0x prefix and prepend 0s as needed*/
//                   /*number "3" below is start position to extract*/
//                  length = len(temp_bcd[site]);
//                  writestring(temp_bcd[site],mid(temp_bcd[site],3,length-2));
//                  switch((length-2)) {
//                    case 1 : temp_bcd[site] = "000" + temp_bcd[site];
//                    case 2 : temp_bcd[site] = "00" + temp_bcd[site];
//                    case 3 : temp_bcd[site] = "0" + temp_bcd[site];
//                  }   /*case*/
//                  
//                  OTP_BCC_INFO[bankcount][count][site]=temp_bcd[site];
//                  tmp_value = 0;
//                  str1 = temp_bcd[site];
//                  stringtoint(str1,tmp_value);
//                  OTP_BCC_INFO_VAL[bankcount][count][site] = (tmp_value/100)*1uA;
//               }   /*if*/
//               
//            loop = loop+1;
//            if((loop mod 8)==0)  
//            {
//               loop = 0;
//               row  = row+1;
//            } 
//         }   /*for count*/
//         
//         if(binout_ena)  
//            if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//               DevSetHoldStates(final_results);
//      }   /*for bankcount*/
//
//      test_results = final_results;
//
//      if(tistdscreenprint)  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               cout << endl;
//               cout << "Site " << site:-5 << " OTP BCC INFO" << endl;
//               for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//               {
//                  cout << "BANK " << bankcount:-4 << endl;
//                  loop = 0;
//                  row  = 0;
//                  for (count = numword;count <= numword_max;count++)
//                  {
//                     if((loop mod 8)==0)  
//                        cout << "Row " << row:-6;
//                     cout << OTP_BCC_INFO[bankcount][count][site] << " ":4;
//                     loop = loop+1;
//                     if((loop mod 8)==0)  
//                     {
//                        cout << endl;
//                        loop = 0;
//                        row  = row+1;
//                     } 
//                  }   /*for count*/
//                  cout << endl;
//               }   /*for bankcount*/
//            }   /*if v_dev_active*/
//      }   /*if tistdscreenprint*/
//
//      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//      {
//         switch(TITestType) {
//           case MP2       :  
//                          index_bankvt0 = 0;
//                          index_bankvt1 = 4;
//                        break; 
//           case MP3       :  
//                          if(not GL_SKIP_MP2_FLASHFLOW)  
//                           
//                             index_bankvt0 = 1;
//                             index_bankvt1 = 5;
//                           
//                          else
//                           
//                             index_bankvt0 = 0;
//                             index_bankvt1 = 4;
//                           break;                              
//                        break; 
//           case PreBurnIn :  
//                          index_bankvt0 = 2;
//                          index_bankvt1 = 6;
//                        break; 
//         }   /* case */
//                    
//         if((MainBCC.MEMCFG[CHKVT0DRL]==BANKTYPE) and (MainBCC.MEMCFG[CHKVT1DRL]==BANKTYPE))  
//         {
//            index_otpvt0  = index_bankvt0+8;
//            index_otpvt1  = index_otpvt0+4;
//            
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  BANK_BCC_VALUE[bankcount][0][CHKVT0DRL][pre][site] =
//                  OTP_BCC_INFO_VAL[bankcount][index_bankvt0][site];
//                  
//                  BANK_BCC_VALUE[bankcount][0][CHKVT1DRL][pre][site] =
//                  OTP_BCC_INFO_VAL[bankcount][index_bankvt1][site];
//                  
//                  OTP_BCC_VALUE[bankcount][CHKVT0DRL][pre][site] =
//                  OTP_BCC_INFO_VAL[bankcount][index_otpvt0][site];
//                  
//                  OTP_BCC_VALUE[bankcount][CHKVT1DRL][pre][site] =
//                  OTP_BCC_INFO_VAL[bankcount][index_otpvt1][site];
//               } 
//         }
//         else
//         {
//            if((MainBCC.MEMCFG[CHKVT0DRL]==SECTTYPE) and (MainBCC.MEMCFG[CHKVT1DRL]==SECTTYPE))  
//               loop = F021_Flash.MAXSECT[bankcount];
//        else if((MainBCC.MEMCFG[CHKVT0DRL]==QUADTYPE) and (MainBCC.MEMCFG[CHKVT1DRL]==QUADTYPE))  
//           loop = FL_MAX_QUADRANT;
//        else
//               loop = F021_Flash.MAXBLOCK[bankcount];
//            
//            index_otpvt0  = index_bankvt0+(8*(loop+1));
//            index_otpvt1  = index_otpvt0+4;
//            
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  for (count = 0;count <= loop;count++)
//                  {
//                     BANK_BCC_VALUE[bankcount][count][CHKVT0DRL][pre][site] =
//                     OTP_BCC_INFO_VAL[bankcount][(index_bankvt0+(count*8))][site];
//                     
//                     BANK_BCC_VALUE[bankcount][count][CHKVT1DRL][pre][site] =
//                     OTP_BCC_INFO_VAL[bankcount][(index_bankvt1+(count*8))][site];
//                  } 
//                  
//                  OTP_BCC_VALUE[bankcount][CHKVT0DRL][pre][site] =
//                  OTP_BCC_INFO_VAL[bankcount][index_otpvt0][site];
//                  
//                  OTP_BCC_VALUE[bankcount][CHKVT1DRL][pre][site] =
//                  OTP_BCC_INFO_VAL[bankcount][index_otpvt1][site];
//               }   /*if v_dev_active*/
//         }   /*TARGET_SECT, LOGSECT*/
//      }   /*for bankcount*/
//   
//   }   /*if v_any_dev_active*/
//
//   F021_ReadBCCOTP_func = v_any_dev_active;
//} 
//
//BoolS F021_WriteBCCOTP_func(   StringS tname,
//                                  IntS wr_option,
//                                  BoolM test_results)
//{
//   const IntS TARGET_BANK = 0x0; 
//   const IntS TARGET_SECT = 0x1; 
//   const IntS TARGET_LOGSECT = 0x2; 
//
//   IntS bankcount,count,loop;
//   IntS site,wr_flag_num,length;
//   IntS1D start_tnumarr(4);
//   IntS testnum,start_tnum;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   FloatM tt_timer;
//   BoolM final_results,tmp_results;
//   BoolM savesites,logsites;
//   FloatS maxtime,ttimer1,ttimer2;
//   StringM temp_bcd;
//   StringS str1;
//   IntS addr_loc,ovrdata;
//   IntS pattype,pattype2;
//   IntS target_tnum,field_tnum;
//   BoolS bcd_format,hexvalue;
//   IntM1D vt_data(128);
//   StringS fl_testname;
//   StringM site_cof_inst_str;
//   BoolS faildetect;
//   FloatM FloatSval;
//   TWunit unitval;
//   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
//
//   if(v_any_dev_active)  
//   {
//      maxtime = GL_F021_MAXTIME;
//      wr_flag_num = 0x1234;
//      bcd_format  = true;
//      hexvalue    = true;
//      
//      writestring(tmpstr1,tname);
//      length = len(tmpstr1);
//      writestring(tmpstr1,mid(tmpstr1,2,length-6));  /*remove _Test*/
//      fl_testname = tname;
//      
//      timernstart(ttimer1);
//
//      TestOpen(fl_testname);
//
//      PrintHeaderBool(GL_PLELL_FORMAT);
//
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//
//      savesites = v_dev_active;
//      final_results = v_dev_active;
//
//      start_tnum = TNUM_OTP_WR_VT_MBOX;
//      
//      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//      {
//         timernstart(ttimer2);
//         faildetect = false;
//         
//         switch(wr_option) {
//           case 0..2:    /*mp1,mp2*/
//              pattype = MainBCC.MEMCFG[CHKVT0DRL];
//
//              if(TITestType==MP1)  
//                 field_tnum = 0x00880000;
//              else
//                 field_tnum = 0x00440000;
//              
//              if(pattype==BANKTYPE)  
//               
//                 numword_max = 3;  /*base 0 so 4 words*/
//                 target_tnum = 0;
//                 for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                    if(v_dev_active[site])  
//                     
//                       vt_data[0][site] = Trunc((BANK_BCC_VALUE[bankcount][0][CHKVT0][pre][site]/1uA)*100);
//                       vt_data[1][site] = Trunc((BANK_BCC_VALUE[bankcount][0][CHKVT1][pre][site]/1uA)*100);
//                       vt_data[2][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT0][pre][site]/1uA)*100);
//                       vt_data[3][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT1][pre][site]/1uA)*100);
//                     break; 
//               
//              else 
//               
//                 if(pattype==BLOCKTYPE)  
//                  
//                     /*eg: numword=maxblk=3.  so numword_max=9 base0 (4 vt0 values, 4 vt1, 2 vt0/1 otp values)*/
//                    numword     = F021_Flash.MAXBLOCK[bankcount];  /*base0*/
//                    numword_max = (2*(numword+1))+1;  /*base0*/
//                    target_tnum = TARGET_LOGSECT<<8;
//                  
//                 else if(pattype==QUADTYPE)  
//                  
//                     /*eg: numword=maxblk=3.  so numword_max=9 base0 (4 vt0 values, 4 vt1, 2 vt0/1 otp values)*/
//                    numword     = FL_MAX_QUADRANT;  /*base0*/
//                    numword_max = (2*(numword+1))+1;  /*base0*/
//                    target_tnum = TNUM_TARGET_QUAD;
//                  
//                 else
//                  
//                    numword     = F021_Flash.MAXSECT[bankcount];  /*base0*/
//                    numword_max = (2*(numword+1))+1;  /*base0*/
//                    target_tnum = TARGET_SECT<<8;
//                  break; 
//
//                 loop = 0;
//                 for (count = 0;count <= numword;count++)
//                  
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                        
//                          vt_data[loop][site] = Trunc((BANK_BCC_VALUE[bankcount][count][CHKVT0][pre][site]/1uA)*100);
//                          vt_data[loop+1][site] = Trunc((BANK_BCC_VALUE[bankcount][count][CHKVT1][pre][site]/1uA)*100);
//                       } 
//                    loop = loop+2;
//                 } 
//                 
//                 for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                    if(v_dev_active[site])  
//                    {
//                       vt_data[loop][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT0][pre][site]/1uA)*100);
//                       vt_data[loop+1][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT1][pre][site]/1uA)*100);
//                    } 
//              }   /*if blocktype/secttype*/
//              
//              testnum = start_tnum+field_tnum+target_tnum+(bankcount<<4);
//           }   /*case 0..2*/
//           
// /* KChau 04/16/10 - temp using CHKVT Echk since no rcode.
//            3: begin {mp3}
//                  pattype := MainBCC.MEMCFG[RCODEVT0];
//                  field_tnum := 0x00220000;
//                  
//                  if(pattype=BANKTYPE) then
//                  begin
//                     numword_max := 3;
//                     target_tnum := 0;
//                     for site := 1 to v_sites do
//                        if(v_dev_active[site]) then
//                        begin
//                           vt_data[0,site] := Trunc((BANK_BCC_VALUE[bankcount,0,RCODEVT0,pre,site]/1uA)*100);
//                           vt_data[1,site] := Trunc((BANK_BCC_VALUE[bankcount,0,RCODEVT1,pre,site]/1uA)*100);
//                           vt_data[2,site] := Trunc((OTP_BCC_VALUE[bankcount,CHKVT0,pre,site]/1uA)*100);
//                           vt_data[3,site] := Trunc((OTP_BCC_VALUE[bankcount,CHKVT1,pre,site]/1uA)*100);
//                        end;
//                  end
//                  else 
//                  begin
//                     if(pattype=BLOCKTYPE) then
//                     begin
//                        numword     := F021_Flash.MAXBLOCK[bankcount];
//                        numword_max := (2*(numword+1))+1; {base0}
//                        target_tnum := TARGET_LOGSECT<<8;
//                     end
//                     else
//                     begin
//                        numword     := F021_Flash.MAXSECT[bankcount];
//                        numword_max := (2*(numword+1))+1; {base0}
//                        target_tnum := TARGET_SECT<<8;
//                     end;
//                     
//                     loop := 0;
//                     for count := 0 to numword do
//                     begin
//                        for site := 1 to v_sites do
//                           if(v_dev_active[site]) then
//                           begin
//                              vt_data[loop,site] := Trunc((BANK_BCC_VALUE[bankcount,count,RCODEVT0,pre,site]/1uA)*100);
//                              vt_data[loop+1,site] := Trunc((BANK_BCC_VALUE[bankcount,count,RCODEVT1,pre,site]/1uA)*100);
//                           end;
//                        loop := loop+2;
//                     end;
//                     
//                     for site := 1 to v_sites do
//                        if(v_dev_active[site]) then
//                        begin
//                           vt_data[loop,site] := Trunc((OTP_BCC_VALUE[bankcount,CHKVT0,pre,site]/1uA)*100);                          
//                           vt_data[loop+1,site] := Trunc((OTP_BCC_VALUE[bankcount,CHKVT1,pre,site]/1uA)*100);
//                        end;
//                  end; {if blocktype/secttype}
//                  
//                  testnum := start_tnum+field_tnum+target_tnum+(bankcount<<4);
//               end; {case 3}
// */
//
//           3: {  /*mp3*/
//                 pattype = MainBCC.MEMCFG[CHKVT0];
//                 field_tnum = 0x00220000;
//                 
//                 if(pattype==BANKTYPE)  
//                 {
//                    numword_max = 3;
//                    target_tnum = 0;
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                       {
//                          vt_data[0][site] = Trunc((BANK_BCC_VALUE[bankcount][0][CHKVT0][pre][site]/1uA)*100);
//                          vt_data[1][site] = Trunc((BANK_BCC_VALUE[bankcount][0][CHKVT1][pre][site]/1uA)*100);
//                          vt_data[2][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT0][pre][site]/1uA)*100);
//                          vt_data[3][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT1][pre][site]/1uA)*100);
//                       } 
//                 }
//                 else 
//                 {
//                    if(pattype==BLOCKTYPE)  
//                    {
//                       numword     = F021_Flash.MAXBLOCK[bankcount];
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TARGET_LOGSECT<<8;
//                    }
//                    else if(pattype==QUADTYPE)  
//                    {
//                       numword     = FL_MAX_QUADRANT;
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TNUM_TARGET_QUAD;
//                    }
//                    else
//                    {
//                       numword     = F021_Flash.MAXSECT[bankcount];
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TARGET_SECT<<8;
//                    } 
//                    
//                    loop = 0;
//                    for (count = 0;count <= numword;count++)
//                    {
//                       for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                          if(v_dev_active[site])  
//                          {
//                             vt_data[loop][site] = Trunc((BANK_BCC_VALUE[bankcount][count][CHKVT0][pre][site]/1uA)*100);
//                             vt_data[loop+1][site] = Trunc((BANK_BCC_VALUE[bankcount][count][CHKVT1][pre][site]/1uA)*100);
//                          } 
//                       loop = loop+2;
//                    } 
//                    
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                       {
//                          vt_data[loop][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT0][pre][site]/1uA)*100);                          
//                          vt_data[loop+1][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT1][pre][site]/1uA)*100);
//                       } 
//                 }   /*if blocktype/secttype*/
//                 
//                 testnum = start_tnum+field_tnum+target_tnum+(bankcount<<4);
//              }   /*case 3*/
//         
//           4: {  /*restore mp1 value @mp2*/
//                 pattype = MainBCC.MEMCFG[CHKVT0DRL];
//                 field_tnum = 0x00880000;
//                 
//                 if(pattype==BANKTYPE)  
//                 {
//                    numword_max = 3;  /*base0 */
//                    target_tnum = 0;
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                       {
//                          vt_data[0][site] = Trunc((BANK_BCC_VALUE[bankcount][0][CHKVT0DRL][pre][site]/1uA)*100);
//                          vt_data[1][site] = Trunc((BANK_BCC_VALUE[bankcount][0][CHKVT1DRL][pre][site]/1uA)*100);
//                          vt_data[2][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT0DRL][pre][site]/1uA)*100);
//                          vt_data[3][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT1DRL][pre][site]/1uA)*100);
//                       } 
//                 }
//                 else 
//                 {
//                    if(pattype==BLOCKTYPE)  
//                    {
//                       numword     = F021_Flash.MAXBLOCK[bankcount];  /*base0*/
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TARGET_LOGSECT<<8;
//                    }
//                    else if(pattype==QUADTYPE)  
//                    {
//                       numword     = FL_MAX_QUADRANT;
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TNUM_TARGET_QUAD;
//                    }
//                    else
//                    {
//                       numword     = F021_Flash.MAXSECT[bankcount];  /*base0*/
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TARGET_SECT<<8;
//                    } 
//                    
//                    loop = 0;
//                    for (count = 0;count <= numword;count++)
//                    {
//                       for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                          if(v_dev_active[site])  
//                          {
//                             vt_data[loop][site] = Trunc((BANK_BCC_VALUE[bankcount][count][CHKVT0DRL][pre][site]/1uA)*100);
//                             vt_data[loop+1][site] = Trunc((BANK_BCC_VALUE[bankcount][count][CHKVT1DRL][pre][site]/1uA)*100);
//                          } 
//                       loop = loop+2;
//                    } 
//                    
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                       {
//                          vt_data[loop][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT0DRL][pre][site]/1uA)*100);
//                          vt_data[loop+1][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT1DRL][pre][site]/1uA)*100);
//                       } 
//                 }   /*if blocktype/secttype*/
//                 
//                 testnum = start_tnum+field_tnum+target_tnum+(bankcount<<4);
//              }   /*case 4*/
//           
//           5: {  /*restore mp1,mp2 value @mp3*/
//                 pattype = MainBCC.MEMCFG[CHKVT0DRL];
//                 field_tnum = 0x00CC0000;
//                 
//                 if(pattype==BANKTYPE)  
//                 {
//                    numword_max = 7;  /*base0 */
//                    target_tnum = 0;
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                       {
//                          vt_data[0][site] = Trunc((BANK_BCC_VALUE[bankcount][0][CHKVT0DRL][pre][site]/1uA)*100);
//                          vt_data[1][site] = Trunc((BANK_BCC_VALUE[bankcount][0][CHKVT0DRL][post][site]/1uA)*100);
//                          vt_data[2][site] = Trunc((BANK_BCC_VALUE[bankcount][0][CHKVT1DRL][pre][site]/1uA*100));
//                          vt_data[3][site] = Trunc((BANK_BCC_VALUE[bankcount][0][CHKVT1DRL][post][site]/1uA)*100);
//                          vt_data[4][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT0DRL][pre][site]/1uA)*100);
//                          vt_data[5][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT0DRL][post][site]/1uA)*100);
//                          vt_data[6][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT1DRL][pre][site]/1uA)*100);
//                          vt_data[7][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT1DRL][post][site]/1uA)*100);
//                       } 
//                 }
//                 else 
//                 {
//                    if(pattype==BLOCKTYPE)  
//                    {
//                       numword     = F021_Flash.MAXBLOCK[bankcount];  /*base0*/
//                       numword_max = (4*(numword+1))+3;  /*base0*/
//                       target_tnum = TARGET_LOGSECT<<8;
//                    }
//                    else if(pattype==QUADTYPE)  
//                    {
//                       numword     = FL_MAX_QUADRANT;
//                       numword_max = (4*(numword+1))+3;  /*base0*/
//                       target_tnum = TNUM_TARGET_QUAD;
//                    }
//                    else
//                    {
//                       numword     = F021_Flash.MAXSECT[bankcount];  /*base0*/
//                       numword_max = (4*(numword+1))+3;  /*base0*/
//                       target_tnum = TARGET_SECT<<8;
//                    } 
//
//                    loop = 0;
//                    for (count = 0;count <= numword_max;count++)
//                    {
//                       for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                          if(v_dev_active[site])  
//                          {
//                             vt_data[loop][site] = Trunc((BANK_BCC_VALUE[bankcount][count][CHKVT0DRL][pre][site]/1uA)*100);   /*mp1 vt0*/
//                             vt_data[loop+1][site] = Trunc((BANK_BCC_VALUE[bankcount][count][CHKVT0DRL][post][site]/1uA)*100);  /*mp2 vt0*/
//                             vt_data[loop+2][site] = Trunc((BANK_BCC_VALUE[bankcount][count][CHKVT1DRL][pre][site]/1uA)*100);   /*mp1 vt1*/
//                             vt_data[loop+3][site] = Trunc((BANK_BCC_VALUE[bankcount][count][CHKVT1DRL][post][site]/1uA)*100);  /*mp2 vt1*/
//                          } 
//                       loop = loop+4;
//                    } 
//
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                       {
//                          vt_data[loop][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT0DRL][pre][site]/1uA)*100);
//                          vt_data[loop+1][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT0DRL][post][site]/1uA)*100);
//                          vt_data[loop+2][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT1DRL][pre][site]/1uA)*100);
//                          vt_data[loop+3][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT1DRL][post][site]/1uA)*100);
//                       } 
//
//                 }   /*if blocktype/secttype*/
//                 
//                 testnum = start_tnum+field_tnum+target_tnum+(bankcount<<4);
//              }   /*case 5*/
//           
//           otherwise {
//              if(tistdscreenprint)  
// invalid wr_option for F021_WriteBCCOTP_func !!!" :  cout << "*** WARNING;) 
//           } 
//            
//         }   /* case wr_option */
//         
//         addr_loc = ADDR_RAM_MAILBOX;
//         msw_data = wr_flag_num;
//         lsw_data = numword_max+1;
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                                  msw_data,hexvalue, bcd_format);
//         
//         for count = 0 to numword_max by 2 do
//         {
//            addr_loc = addr_loc+ADDR_RAM_INC;
//            msw_data = vt_data[count];  /*msword*/
//            lsw_data = vt_data[count+1];  /*lsword*/
//            WriteRamContentDec_32Bit(addr_loc,lsw_data, not hexvalue,
//                                     msw_data, not hexvalue, bcd_format);
//         } 
//
//         logsites = v_dev_active;
//         tmp_results = v_dev_active;
//         F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results);
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//         
//         ttimer2 = timernread(ttimer2);
//         tt_timer = ttimer2;
//
//         writestring(tmpstr2,bankcount:1);
//         tmpstr2 = "_B" + tmpstr2;  /*_B#*/
//         tmpstr3 = tmpstr1 + tmpstr2;
//         tmpstr4 = tmpstr3 + "_TT";
//
//         TWTRealToRealMS(tt_timer,realval,unitval);
//         TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//               
//         if(tistdscreenprint)  
//            PrintResultBool(tmpstr3,testnum,tmp_results,GL_PLELL_FORMAT);
//               
//         if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//         {
//            faildetect = true;
//            F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
//            
//            if(TI_FlashCOFEna)  
//               F021_Update_COF_Inst_Str(tmpstr2,site_cof_inst_str,tmp_results);
//         } 
//         
//         if(faildetect)  
//            if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//               DevSetHoldStates(final_results);
//         
//         if(not v_any_dev_active)  
//            break;
//      }   /*for bankcount*/
//
//      Devsetholdstates(savesites);
//
//      ResultsRecordActive(final_results, S_NULL);
//      TestClose;
//
//      test_results = final_results;
//
//      if(TI_FlashCOFEna)  
//         F021_Save_COF_Info(tmpstr1,site_cof_inst_str,final_results);
//      
//      ttimer1 = timernread(ttimer1);
//      tt_timer = ttimer1;
//
//      tmpstr4 = tmpstr1 + "_TTT";
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//         DevSetHoldStates(final_results);
//
//   }   /*if v_any_dev_active*/
//
//   F021_WriteBCCOTP_func = v_any_dev_active;
//} 
//
//
//void Get_PreBake1_VT0(IntS bank)
//{
//   IntS index;
//   BoolS rdbcc;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "*** Get_PreBake1_VT0 ***" << endl;
//
//      if(MainVT.MEMCFG[CHKVT0] != MainVT.MEMCFG[CHKVT0DRL])  
//      {
//         cout << "!!!" << endl;
//         cout << "!!! INVALID MainVT.MEMCFG[CHKVT0] and MEMCFG[CHKVT0DRL] !!!" << endl;
//         cout << "!!!" << endl;
//      } 
//
//      rdbcc = false;
//      index = 0;
//      Get_MBoxSpace_BCCVT(rdbcc,bank,index);
//   }   /*v_any_dev_active*/
//}   /* Get_PreBake1_VT0 */
//
//void Get_PreBake1_VT1(IntS bank)
//{
//   IntS index;
//   BoolS rdbcc;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "*** Get_PreBake1_VT1 ***" << endl;
//
//      if(MainVT.MEMCFG[CHKVT1] != MainVT.MEMCFG[CHKVT1DRL])  
//      {
//         cout << "!!!" << endl;
//         cout << "!!! INVALID MainVT.MEMCFG[CHKVT1] and MEMCFG[CHKVT1DRL] !!!" << endl;
//         cout << "!!!" << endl;
//      } 
//
//      rdbcc = false;
//      index = 4;
//      Get_MBoxSpace_BCCVT(rdbcc,bank,index);
//   }   /*v_any_dev_active*/
//}   /* Get_PreBake1_VT1 */
//   
//void Get_PreBake2_VT0(IntS bank)
//{
//   IntS index;
//   BoolS rdbcc;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "*** Get_PreBake2_VT0 ***" << endl;
//
//      if(MainVT.MEMCFG[CHKVT0] != MainVT.MEMCFG[CHKVT0DRL])  
//      {
//         cout << "!!!" << endl;
//         cout << "!!! INVALID MainVT.MEMCFG[CHKVT0] and MEMCFG[CHKVT0DRL] !!!" << endl;
//         cout << "!!!" << endl;
//      } 
//
//      rdbcc = false;
//      index = 1;
//      Get_MBoxSpace_BCCVT(rdbcc,bank,index);
//   }   /*v_any_dev_active*/
//}   /* Get_PreBake2_VT0 */
//
//void Get_PreBake2_VT1(IntS bank)
//{
//   IntS index;
//   BoolS rdbcc;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "*** Get_PreBake2_VT1 ***" << endl;
//
//      if(MainVT.MEMCFG[CHKVT1] != MainVT.MEMCFG[CHKVT1DRL])  
//      {
//         cout << "!!!" << endl;
//         cout << "!!! INVALID MainVT.MEMCFG[CHKVT1] and MEMCFG[CHKVT1DRL] !!!" << endl;
//         cout << "!!!" << endl;
//      } 
//
//      rdbcc = false;
//      index = 5;
//      Get_MBoxSpace_BCCVT(rdbcc,bank,index);
//   }   /*v_any_dev_active*/
//}   /* Get_PreBake2_VT1 */
//   
//void Get_PreBake3_VT0(IntS bank)
//{
//   IntS index;
//   BoolS rdbcc;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "*** Get_PreBake3_VT0 ***" << endl;
//
//      if(MainVT.MEMCFG[CHKVT0] != MainVT.MEMCFG[CHKVT0DRL])  
//      {
//         cout << "!!!" << endl;
//         cout << "!!! INVALID MainVT.MEMCFG[CHKVT0] and MEMCFG[CHKVT0DRL] !!!" << endl;
//         cout << "!!!" << endl;
//      } 
//
//      rdbcc = false;
//      index = 2;
//      Get_MBoxSpace_BCCVT(rdbcc,bank,index);
//   }   /*v_any_dev_active*/
//}   /* Get_PreBake3_VT0 */
//
//void Get_PreBake3_VT1(IntS bank)
//{
//   IntS index;
//   BoolS rdbcc;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "*** Get_PreBake3_VT1 ***" << endl;
//
//      if(MainVT.MEMCFG[CHKVT1] != MainVT.MEMCFG[CHKVT1DRL])  
//      {
//         cout << "!!!" << endl;
//         cout << "!!! INVALID MainVT.MEMCFG[CHKVT1] and MEMCFG[CHKVT1DRL] !!!" << endl;
//         cout << "!!!" << endl;
//      } 
//
//      rdbcc = false;
//      index = 6;
//      Get_MBoxSpace_BCCVT(rdbcc,bank,index);
//   }   /*v_any_dev_active*/
//}   /* Get_PreBake3_VT1 */
//   
//void Get_PreBake4_VT0(IntS bank)
//{
//   IntS index;
//   BoolS rdbcc;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "*** Get_PreBake4_VT0 ***" << endl;
//
//      if(MainVT.MEMCFG[CHKVT0] != MainVT.MEMCFG[CHKVT0DRL])  
//      {
//         cout << "!!!" << endl;
//         cout << "!!! INVALID MainVT.MEMCFG[CHKVT0] and MEMCFG[CHKVT0DRL] !!!" << endl;
//         cout << "!!!" << endl;
//      } 
//
//      rdbcc = false;
//      index = 3;
//      Get_MBoxSpace_BCCVT(rdbcc,bank,index);
//   }   /*v_any_dev_active*/
//}   /* Get_PreBake4_VT0 */
//
//void Get_PreBake4_VT1(IntS bank)
//{
//   IntS index;
//   BoolS rdbcc;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "*** Get_PreBake4_VT1 ***" << endl;
//
//      if(MainVT.MEMCFG[CHKVT1] != MainVT.MEMCFG[CHKVT1DRL])  
//      {
//         cout << "!!!" << endl;
//         cout << "!!! INVALID MainVT.MEMCFG[CHKVT1] and MEMCFG[CHKVT1DRL] !!!" << endl;
//         cout << "!!!" << endl;
//      } 
//
//      rdbcc = false;
//      index = 7;
//      Get_MBoxSpace_BCCVT(rdbcc,bank,index);
//   }   /*v_any_dev_active*/
//}   /* Get_PreBake4_VT1 */
//   
//
//BoolS F021_ReadVTOTP_func(    BoolM test_results,
//                                 BoolS binout_ena)
//{
//   IntS bankcount,count,loop,row;
//   IntS site,rd_flag_num,length;
//   IntS start_tnum,testnum;
//   IntM msw_data,lsw_data;
//   FloatM tt_timer;
//   BoolM final_results,tmp_results;
//   FloatS maxtime;
//   StringM temp_bcd;
//   StringS str1;
//   IntS index_bankvt0,index_bankvt1;
//   IntS index_otpvt0,index_otpvt1;
//   IntS numword,numword_max,tmp_value;
//
//   if(v_any_dev_active)  
//   {
//      start_tnum = TNUM_OTP_RD_VT_MBOX;
//      maxtime = GL_F021_MAXTIME;
//      rd_flag_num = 0x4321;
//      numword     = 0;
//      numword_max = 127;
//
//      final_results = v_dev_active;
//      
//      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//      {
//         testnum = start_tnum+(bankcount<<4);
//         tmp_results = v_dev_active;
//         F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results);
//
//         if(GL_DO_ESDA_WITH_SCRAM)  
//            Get_Flash_MBoxSpace_OTP_SCRAM;
//         
//         Get_MBoxSpace_FlagNum(msw_data,lsw_data);
//         
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//                /*if(lsw_data[site]<>data_flag_num) then
//                 tmp_results[site] := false;*/
//               if(msw_data[site]!=rd_flag_num)  
//               {
//                  tmp_results[site] = false;
//                  if(tistdscreenprint)  
//                     cout << "Site " << site:-4 << " Read Flag Not Matched " << 
//                             msw_data[site]:s_hex:-8 << " Expect of " << rd_flag_num:s_hex:-8 << endl;
//               } 
//            } 
//         
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//
//         loop = 0;
//         row  = 0;
//         
//         for (count = numword;count <= numword_max;count++)
//         {
//            Get_MBoxSpace_RowX_WdX(row,loop,lsw_data);
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            {
//               if(v_dev_active[site])  
//               {
//                   /*convert int number to hex string w/ 0x prefix*/
//                  writestring(temp_bcd[site],lsw_data[site]:s_hex:1);
//                   /*extract string w/o 0x prefix and prepend 0s as needed*/
//                   /*number "3" below is start position to extract*/
//                  length = len(temp_bcd[site]);
//                  writestring(temp_bcd[site],mid(temp_bcd[site],3,length-2));
//                  switch((length-2)) {
//                    case 1 : temp_bcd[site] = "000" + temp_bcd[site];
//                    case 2 : temp_bcd[site] = "00" + temp_bcd[site];
//                    case 3 : temp_bcd[site] = "0" + temp_bcd[site];
//                  }   /*case*/
//                  
//                  OTP_VT_INFO[bankcount][count][site]=temp_bcd[site];
//                  tmp_value = 0;
//                  str1 = temp_bcd[site];
//                  stringtoint(str1,tmp_value);
//                  OTP_VT_INFO_VAL[bankcount][count][site] = (tmp_value/100)*1V;
//               }   /*if*/
//            }   /*for site*/
//         
//            loop = loop+1;
//            if((loop mod 8)==0)  
//            {
//               loop = 0;
//               row  = row+1;
//            } 
//         }   /*for count*/
//         
//         if(binout_ena)  
//            if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//               DevSetHoldStates(final_results);
//      }   /*for bankcount*/
//            
//      test_results = final_results;
//
//      if(tistdscreenprint and TI_FlashDebug)  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               cout << endl;
//               cout << "Site " << site:-5 << " OTP VT INFO" << endl;
//               for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//               {
//                  cout << "BANK " << bankcount:-4 << endl;
//                  loop = 0;
//                  row  = 0;
//                  for (count = numword;count <= numword_max;count++)
//                  {
//                     if((loop mod 8)==0)  
//                        cout << "Row " << row:-6;
//                     cout << OTP_VT_INFO[bankcount][count][site] << " ":4;
//                     loop = loop+1;
//                     if((loop mod 8)==0)  
//                     {
//                        cout << endl;
//                        loop = 0;
//                        row  = row+1;
//                     } 
//                  }   /*for count*/
//                  cout << endl;
//               }   /*for bankcount*/
//            }   /*if v_dev_active*/
//      }   /*if tistdscreenprint*/
//
//      
//      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//      {
//         switch(TITestType) {
//           case MP2       :  
//                          index_bankvt0 = 0;
//                          index_bankvt1 = 4;
//                        break; 
//           case MP3       :  
//                          index_bankvt0 = 1;
//                          index_bankvt1 = 5;
//                        break; 
//           case PreBurnIn :  
//                          index_bankvt0 = 2;
//                          index_bankvt1 = 6;
//                        break; 
//         }   /* case */
//                    
//         if((MainVT.MEMCFG[CHKVT0DRL]==BANKTYPE) and (MainVT.MEMCFG[CHKVT1DRL]==BANKTYPE))  
//         {
//            index_otpvt0  = index_bankvt0+8;
//            index_otpvt1  = index_otpvt0+4;
//            
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  BANK_VT_VALUE[bankcount][0][CHKVT0DRL][pre][site] =
//                  OTP_VT_INFO_VAL[bankcount][index_bankvt0][site];
//                  
//                  BANK_VT_VALUE[bankcount][0][CHKVT1DRL][pre][site] =
//                  OTP_VT_INFO_VAL[bankcount][index_bankvt1][site];
//                  
//                  OTP_VT_VALUE[bankcount][CHKVT0DRL][pre][site] =
//                  OTP_VT_INFO_VAL[bankcount][index_otpvt0][site];
//                  
//                  OTP_VT_VALUE[bankcount][CHKVT1DRL][pre][site] =
//                  OTP_VT_INFO_VAL[bankcount][index_otpvt1][site];
//               } 
//         }
//         else
//         {
//            if((MainVT.MEMCFG[CHKVT0DRL]==SECTTYPE) and (MainVT.MEMCFG[CHKVT1DRL]==SECTTYPE))  
//               loop = F021_Flash.MAXSECT[bankcount];
//            else if((MainVT.MEMCFG[CHKVT0DRL]==QUADTYPE) and (MainVT.MEMCFG[CHKVT1DRL]==QUADTYPE))  
//               loop = FL_MAX_QUADRANT;
//            else
//               loop = F021_Flash.MAXBLOCK[bankcount];
//            
//            index_otpvt0  = index_bankvt0+(8*(loop+1));
//            index_otpvt1  = index_otpvt0+4;
//            
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  for (count = 0;count <= loop;count++)
//                  {
//                     BANK_VT_VALUE[bankcount][count][CHKVT0DRL][pre][site] =
//                     OTP_VT_INFO_VAL[bankcount][(index_bankvt0+(count*8))][site];
//                     
//                     BANK_VT_VALUE[bankcount][count][CHKVT1DRL][pre][site] =
//                     OTP_VT_INFO_VAL[bankcount][(index_bankvt1+(count*8))][site];
//                  } 
//                  
//                  OTP_VT_VALUE[bankcount][CHKVT0DRL][pre][site] =
//                  OTP_VT_INFO_VAL[bankcount][index_otpvt0][site];
//                  
//                  OTP_VT_VALUE[bankcount][CHKVT1DRL][pre][site] =
//                  OTP_VT_INFO_VAL[bankcount][index_otpvt1][site];
//               }   /*if v_dev_active*/
//         }   /*TARGET_SECT, LOGSECT*/
//      }   /*for bankcount*/
//   }   /*if v_any_dev_active*/
//
//   F021_ReadVTOTP_func = v_any_dev_active;
//} 
//   
//
//BoolS F021_WriteVTOTP_func(    StringS tname,
//                                  IntS wr_option,
//                                  BoolM test_results)
//{
//   const IntS TARGET_BANK = 0x0; 
//   const IntS TARGET_SECT = 0x1; 
//   const IntS TARGET_LOGSECT = 0x2; 
//
//   IntS bankcount,count,loop;
//   IntS site,wr_flag_num,length;
//   IntS1D start_tnumarr(4);
//   IntS testnum,start_tnum;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   FloatM tt_timer;
//   BoolM final_results,tmp_results;
//   BoolM savesites,logsites;
//   FloatS maxtime,ttimer1,ttimer2;
//   StringM temp_bcd;
//   StringS str1;
//   IntS addr_loc;
//   IntS pattype,pattype2;
//   IntS target_tnum,field_tnum;
//   BoolS bcd_format,hexvalue;
//   IntM1D vt_data(128);
//   IntS index1,index2,index3,index4;
//   IntS index5,index6,index7,index8;
//   IntS index9,index10,index11;
//   StringS fl_testname;
//   StringM site_cof_inst_str;
//   BoolS faildetect;
//   FloatM FloatSval;
//   TWunit unitval;
//   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
//
//   if(v_any_dev_active)  
//   {
//      maxtime = GL_F021_MAXTIME;
//      wr_flag_num = 0x1234;
//      bcd_format  = true;
//      hexvalue    = true;
//      
//      writestring(tmpstr1,tname);
//      length = len(tmpstr1);
//      writestring(tmpstr1,mid(tmpstr1,2,length-6));  /*remove _Test*/
//      fl_testname = tname;
//      
//      timernstart(ttimer1);
//
//      TestOpen(fl_testname);
//
//      PrintHeaderBool(GL_PLELL_FORMAT);
//
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//
//      savesites = v_dev_active;
//      final_results = v_dev_active;
//
//      start_tnum = TNUM_OTP_WR_VT_MBOX;
//      
//      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//      {
//         timernstart(ttimer2);
//         faildetect = false;
//         
//         switch(wr_option) {
//           case 0..2:    /*mp1,mp2*/
//              pattype = MainVT.MEMCFG[CHKVT0];
//
//              if(TITestType==MP1)  
//                 field_tnum = 0x00880000;
//              else
//                 field_tnum = 0x00440000;
//              
//              if(pattype==BANKTYPE)  
//               
//                 numword_max = 3;  /*base 0 so 4 words*/
//                 target_tnum = 0;
//                 for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                    if(v_dev_active[site])  
//                     
//                       vt_data[0][site] = Trunc(BANK_VT_VALUE[bankcount][0][CHKVT0][pre][site]*100);
//                       vt_data[1][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT0][pre][site]*100);
//                       vt_data[2][site] = Trunc(BANK_VT_VALUE[bankcount][0][CHKVT1][pre][site]*100);
//                       vt_data[3][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT1][pre][site]*100);
//                     break; 
//               
//              else 
//               
//                 if(pattype==BLOCKTYPE)  
//                  
//                     /*eg: numword=maxblk=3.  so numword_max=9 base0 (4 vt0 values, 4 vt1, 2 vt0/1 otp values)*/
//                    numword     = F021_Flash.MAXBLOCK[bankcount];  /*base0*/
//                    numword_max = (2*(numword+1))+1;  /*base0*/
//                    target_tnum = TARGET_LOGSECT<<8;
//                  
//                 else if(pattype==QUADTYPE)  
//                  
//                    numword     = FL_MAX_QUADRANT;
//                    numword_max = (2*(numword+1))+1;  /*base0*/
//                    target_tnum = TNUM_TARGET_QUAD;
//                  
//                 else
//                  
//                    numword     = F021_Flash.MAXSECT[bankcount];  /*base0*/
//                    numword_max = (2*(numword+1))+1;  /*base0*/
//                    target_tnum = TARGET_SECT<<8;
//                  break; 
//
//                 for (count = 0;count <= numword;count++)
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                          vt_data[count][site] = Trunc(BANK_VT_VALUE[bankcount][count][CHKVT0][pre][site]*100);
//
//                 for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                    if(v_dev_active[site])  
//                       vt_data[numword+1][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT0][pre][site]*100);
//
//                 loop = 0;
//                 for (count = (numword+2);count <= (numword_max-1);count++)
//                 {
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                          vt_data[count][site] = Trunc(BANK_VT_VALUE[bankcount][loop][CHKVT1][pre][site]*100);
//                    loop = loop+1;
//                 } 
//
//                 for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                    if(v_dev_active[site])  
//                       vt_data[numword_max][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT1][pre][site]*100);
//              }   /*if blocktype/secttype*/
//              
//              testnum = start_tnum+field_tnum+target_tnum+(bankcount<<4);
//           }   /*case 0..2*/
//
//           3: {  /*mp3*/
//                 pattype = MainVT.MEMCFG[RCODEVT0];
//                 field_tnum = 0x00220000;
//                 
//                 if(pattype==BANKTYPE)  
//                 {
//                    numword_max = 3;
//                    target_tnum = 0;
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                       {
//                          vt_data[0][site] = Trunc(BANK_VT_VALUE[bankcount][0][RCODEVT0][pre][site]*100);
//                          vt_data[1][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT0][pre][site]*100);
//                          vt_data[2][site] = Trunc(BANK_VT_VALUE[bankcount][0][RCODEVT1][pre][site]*100);
//                          vt_data[3][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT1][pre][site]*100);
//                       } 
//                 }
//                 else 
//                 {
//                    if(pattype==BLOCKTYPE)  
//                    {
//                       numword     = F021_Flash.MAXBLOCK[bankcount];
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TARGET_LOGSECT<<8;
//                    }
//                    else if(pattype==QUADTYPE)  
//                    {
//                       numword     = FL_MAX_QUADRANT;
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TNUM_TARGET_QUAD;
//                    }
//                    else
//                    {
//                       numword     = F021_Flash.MAXSECT[bankcount];
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TARGET_SECT<<8;
//                    } 
//                    
//                    for (count = 0;count <= numword;count++)
//                       for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                          if(v_dev_active[site])  
//                             vt_data[count][site] = Trunc(BANK_VT_VALUE[bankcount][count][RCODEVT0][pre][site]*100);
//                    
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                          vt_data[numword+1][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT0][pre][site]*100);
//                    
//                    loop = 0;
//                    for (count = (numword+2);count <= (numword_max-1);count++)
//                    {
//                       for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                          if(v_dev_active[site])  
//                             vt_data[count][site] = Trunc(BANK_VT_VALUE[bankcount][loop][RCODEVT1][pre][site]*100);
//                       loop = loop+1;
//                    } 
//                    
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                          vt_data[numword_max][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT1][pre][site]*100);
//                 }   /*if blocktype/secttype*/
//                 
//                 testnum = start_tnum+field_tnum+target_tnum+(bankcount<<4);
//              }   /*case 3*/
//
//           4: {  /*restore mp1 value @mp2*/
//                 pattype = MainVT.MEMCFG[CHKVT0DRL];
//                 field_tnum = 0x00880000;
//                 
//                 if(pattype==BANKTYPE)  
//                 {
//                    numword_max = 3;  /*base0 */
//                    target_tnum = 0;
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                       {
//                          vt_data[0][site] = Trunc(BANK_VT_VALUE[bankcount][0][CHKVT0DRL][pre][site]*100);
//                          vt_data[1][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT0DRL][pre][site]*100);
//                          vt_data[2][site] = Trunc(BANK_VT_VALUE[bankcount][0][CHKVT1DRL][pre][site]*100);
//                          vt_data[3][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT1DRL][pre][site]*100);
//                       } 
//                 }
//                 else 
//                 {
//                    if(pattype==BLOCKTYPE)  
//                    {
//                       numword     = F021_Flash.MAXBLOCK[bankcount];  /*base0*/
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TARGET_LOGSECT<<8;
//                    }
//                    else if(pattype==QUADTYPE)  
//                    {
//                       numword     = FL_MAX_QUADRANT;
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TNUM_TARGET_QUAD;
//                    }
//                    else
//                    {
//                       numword     = F021_Flash.MAXSECT[bankcount];  /*base0*/
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TARGET_SECT<<8;
//                    } 
//
//                    for (count = 0;count <= numword;count++)
//                       for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                          if(v_dev_active[site])  
//                             vt_data[count][site] = Trunc(BANK_VT_VALUE[bankcount][count][CHKVT0DRL][pre][site]*100);
//                    
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                          vt_data[numword+1][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT0DRL][pre][site]*100);
//                    
//                    loop = 0;
//                    for (count = (numword+2);count <= (numword_max-1);count++)
//                    {
//                       for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                          if(v_dev_active[site])  
//                             vt_data[count][site] = Trunc(BANK_VT_VALUE[bankcount][loop][CHKVT1DRL][pre][site]*100);
//                       loop = loop+1;
//                    } 
//                    
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                          vt_data[numword_max][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT1DRL][pre][site]*100);
//                 }   /*if blocktype/secttype*/
//                 
//                 testnum = start_tnum+field_tnum+target_tnum+(bankcount<<4);
//              }   /*case 4*/
//           
//           5: {  /*restore mp1,mp2 value @mp3*/
//                 pattype = MainVT.MEMCFG[CHKVT0DRL];
//                 field_tnum = 0x00CC0000;
//                 
//                 if(pattype==BANKTYPE)  
//                 {
//                    numword_max = 7;  /*base0 */
//                    target_tnum = 0;
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                       {
//                          vt_data[0][site] = Trunc(BANK_VT_VALUE[bankcount][0][CHKVT0DRL][pre][site]*100);
//                          vt_data[1][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT0DRL][pre][site]*100);
//                          vt_data[2][site] = Trunc(BANK_VT_VALUE[bankcount][0][CHKVT0DRL][post][site]*100);
//                          vt_data[3][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT0DRL][post][site]*100);
//                          vt_data[4][site] = Trunc(BANK_VT_VALUE[bankcount][0][CHKVT1DRL][pre][site]*100);
//                          vt_data[5][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT1DRL][pre][site]*100);
//                          vt_data[6][site] = Trunc(BANK_VT_VALUE[bankcount][0][CHKVT1DRL][post][site]*100);
//                          vt_data[7][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT1DRL][post][site]*100);
//                       } 
//                 }
//                 else 
//                 {
//                    if(pattype==BLOCKTYPE)  
//                    {
//                       numword     = F021_Flash.MAXBLOCK[bankcount];  /*base0*/
//                       numword_max = (4*(numword+1))+3;  /*base0*/
//                       target_tnum = TARGET_LOGSECT<<8;
//                    }
//                    else if(pattype==QUADTYPE)  
//                    {
//                       numword     = FL_MAX_QUADRANT;
//                       numword_max = (4*(numword+1))+3;  /*base0*/
//                       target_tnum = TNUM_TARGET_QUAD;
//                    }
//                    else
//                    {
//                       numword     = F021_Flash.MAXSECT[bankcount];  /*base0*/
//                       numword_max = (4*(numword+1))+3;  /*base0*/
//                       target_tnum = TARGET_SECT<<8;
//                    } 
//
//                    index1 = numword;          /*mp1 vt0*/
//                    index2 = index1+1;         /*mp1 vt0 otp*/
//                    index3 = index2+1;         /*mp2 vt0 start*/
//                    index4 = index3+numword;   /*mp2 vt0 end*/
//                    index5 = index4+1;         /*mp2 vt0 otp*/
//                    index6 = index5+1;         /*mp1 vt1 start*/
//                    index7 = index6+numword;   /*mp1 vt1 end*/
//                    index8 = index7+1;         /*mp1 vt1 otp*/
//                    index9 = index8+1;         /*mp2 vt1 start*/
//                    index10 = index9+numword;  /*mp2 vt1 end*/
//                    
//                    loop = 0;
//                    for (count = 0;count <= numword_max;count++)
//                    {
//                       if(count<==index1)  
//                       {
//                          for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                             if(v_dev_active[site])  
//                                vt_data[count][site] = Trunc(BANK_VT_VALUE[bankcount][loop][CHKVT0DRL][pre][site]*100);
//                       }
//                       else if(count==index2)  
//                       {
//                          for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                             if(v_dev_active[site])  
//                                vt_data[count][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT0DRL][pre][site]*100);
//                       }
//                       else if((count>==index3) and (count<==index4))  
//                       {
//                          for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                             if(v_dev_active[site])  
//                                vt_data[count][site] = Trunc(BANK_VT_VALUE[bankcount][loop][CHKVT0DRL][post][site]*100);
//                       }
//                       else if(count==index5)  
//                       {
//                          for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                             if(v_dev_active[site])  
//                                vt_data[count][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT0DRL][post][site]*100);
//                       }
//                       else if((count>==index6) and (count<==index7))  
//                       {
//                          for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                             if(v_dev_active[site])  
//                                vt_data[count][site] = Trunc(BANK_VT_VALUE[bankcount][loop][CHKVT1DRL][pre][site]*100);
//                       }
//                       else if(count==index8)  
//                       {
//                          for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                             if(v_dev_active[site])  
//                                vt_data[count][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT1DRL][pre][site]*100);
//                       }
//                       else if((count>==index9) and (count<==index10))  
//                       {
//                          for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                             if(v_dev_active[site])  
//                                vt_data[count][site] = Trunc(BANK_VT_VALUE[bankcount][loop][CHKVT1DRL][post][site]*100);
//                       }
//                       else  /*if(count=numword_max) then*/
//                       {
//                          for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                             if(v_dev_active[site])  
//                                vt_data[count][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT1DRL][post][site]*100);
//                       } 
//                    
//                       if(loop==(numword+1))  
//                          loop = 0;
//                       else
//                          loop = loop+1;
//                    }                          /*for count*/
//
//                 }   /*if blocktype/secttype*/
//                 
//                 testnum = start_tnum+field_tnum+target_tnum+(bankcount<<4);
//              }   /*case 5*/
//           
//           otherwise {
//              if(tistdscreenprint)  
// invalid wr_option for F021_WriteVTOTP_func !!!" :  cout << "*** WARNING;) 
//           } 
//            
//         }   /* case wr_option */
//         
//         addr_loc = ADDR_RAM_MAILBOX;
//         msw_data = wr_flag_num; 
//         lsw_data = numword_max+1; 
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                                  msw_data,hexvalue, bcd_format);
//         
//         for count = 0 to numword_max by 2 do
//         {
//            addr_loc = addr_loc+ADDR_RAM_INC;
//            msw_data = vt_data[count];  /*msword*/
//            lsw_data = vt_data[count+1];  /*lsword*/
//            WriteRamContentDec_32Bit(addr_loc,lsw_data, not hexvalue,
//                                     msw_data, not hexvalue, bcd_format);
//         } 
//            
//         logsites = v_dev_active;
//         tmp_results = v_dev_active;
//         F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results);
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//         
//         ttimer2 = timernread(ttimer2);
//         tt_timer = ttimer2;
//
//         writestring(tmpstr2,bankcount:1);
//         tmpstr2 = "_B" + tmpstr2;  /*_B#*/
//         tmpstr3 = tmpstr1 + tmpstr2;
//         tmpstr4 = tmpstr3 + "_TT";
//
//         TWTRealToRealMS(tt_timer,realval,unitval);
//         TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//               
//         if(tistdscreenprint)  
//            PrintResultBool(tmpstr3,testnum,tmp_results,GL_PLELL_FORMAT);
//               
//         if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//         {
//            faildetect = true;
//            F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
//            
//            if(TI_FlashCOFEna)  
//               F021_Update_COF_Inst_Str(tmpstr2,site_cof_inst_str,tmp_results);
//         } 
//         
//         if(faildetect)  
//            if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//               DevSetHoldStates(final_results);
//         
//         if(not v_any_dev_active)  
//            break;
//      }   /*for bankcount*/
//
//      Devsetholdstates(savesites);
//
//      ResultsRecordActive(final_results, S_NULL);
//      TestClose;
//
//      test_results = final_results;
//
//      if(TI_FlashCOFEna)  
//         F021_Save_COF_Info(tmpstr1,site_cof_inst_str,final_results);
//      
//      ttimer1 = timernread(ttimer1);
//      tt_timer = ttimer1;
//
//      tmpstr4 = tmpstr1 + "_TTT";
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//         DevSetHoldStates(final_results);
//
//   }   /*if v_any_dev_active*/
//
//   F021_WriteVTOTP_func = v_any_dev_active;
//} 
//
//
//BoolS F021_ReadVT0BCC1OTP_func(    BoolM test_results,
//                                      BoolS binout_ena)
//{
//   IntS bankcount,count,loop,row;
//   IntS site,rd_flag_num,length;
//   IntS start_tnum,testnum;
//   IntM msw_data,lsw_data;
//   FloatM tt_timer;
//   BoolM final_results,tmp_results;
//   FloatS maxtime;
//   StringM temp_bcd;
//   StringS str1;
//   IntS index_bankvt0,index_bankvt1;
//   IntS index_otpvt0,index_otpvt1;
//   IntS numword,numword_max,tmp_value;
//
//   if(v_any_dev_active)  
//   {
//      start_tnum = TNUM_OTP_RD_VT_MBOX;
//      maxtime = GL_F021_MAXTIME;
//      rd_flag_num = 0x4321;
//      numword     = 0;
//      numword_max = 127;
//
//      final_results = v_dev_active;
//      
//      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//      {
//         testnum = start_tnum+(bankcount<<4);
//         tmp_results = v_dev_active;
//         F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results);
//
//         if(GL_DO_ESDA_WITH_SCRAM)  
//            Get_Flash_MBoxSpace_OTP_SCRAM;
//         
//         Get_MBoxSpace_FlagNum(msw_data,lsw_data);
//         
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//                /*if(lsw_data[site]<>data_flag_num) then
//                 tmp_results[site] := false;*/
//               if(msw_data[site]!=rd_flag_num)  
//               {
//                  tmp_results[site] = false;
//                  if(tistdscreenprint)  
//                     cout << "Site " << site:-4 << " Read Flag Not Matched " << 
//                             msw_data[site]:s_hex:-8 << " Expect of " << rd_flag_num:s_hex:-8 << endl;
//               } 
//            } 
//         
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//
//         loop = 0;
//         row  = 0;
//         
//         for (count = numword;count <= numword_max;count++)
//         {
//            Get_MBoxSpace_RowX_WdX(row,loop,lsw_data);
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            {
//               if(v_dev_active[site])  
//               {
//                   /*convert int number to hex string w/ 0x prefix*/
//                  writestring(temp_bcd[site],lsw_data[site]:s_hex:1);
//                   /*extract string w/o 0x prefix and prepend 0s as needed*/
//                   /*number "3" below is start position to extract*/
//                  length = len(temp_bcd[site]);
//                  writestring(temp_bcd[site],mid(temp_bcd[site],3,length-2));
//                  switch((length-2)) {
//                    case 1 : temp_bcd[site] = "000" + temp_bcd[site];
//                    case 2 : temp_bcd[site] = "00" + temp_bcd[site];
//                    case 3 : temp_bcd[site] = "0" + temp_bcd[site];
//                  }   /*case*/
//                  
//                  OTP_VT_INFO[bankcount][count][site]=temp_bcd[site];
//                  tmp_value = 0;
//                  str1 = temp_bcd[site];
//                  stringtoint(str1,tmp_value);
//                  OTP_VT_INFO_VAL[bankcount][count][site] = (tmp_value/100)*1V;
//
//                  OTP_BCC_INFO_INTVAL[bankcount][count][site] = lsw_data[site];
//                  OTP_BCC_INFO_VAL[bankcount][count][site] = (tmp_value/100)*1uA;
//
//               }   /*if*/
//            }   /*for site*/
//         
//            loop = loop+1;
//            if((loop mod 8)==0)  
//            {
//               loop = 0;
//               row  = row+1;
//            } 
//         }   /*for count*/
//         
//         if(binout_ena)  
//            if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//               DevSetHoldStates(final_results);
//      }   /*for bankcount*/
//            
//      test_results = final_results;
//
//      if(tistdscreenprint)  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               cout << endl;
//               cout << "Site " << site:-5 << " OTP VT/BCC INFO" << endl;
//               for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//               {
//                  cout << "BANK " << bankcount:-4 << endl;
//                  loop = 0;
//                  row  = 0;
//                  for (count = numword;count <= numword_max;count++)
//                  {
//                     if((loop mod 8)==0)  
//                        cout << "Row " << row:-6;
//                     cout << OTP_VT_INFO[bankcount][count][site] << " ":4;
//                     loop = loop+1;
//                     if((loop mod 8)==0)  
//                     {
//                        cout << endl;
//                        loop = 0;
//                        row  = row+1;
//                     } 
//                  }   /*for count*/
//                  cout << endl;
//               }   /*for bankcount*/
//            }   /*if v_dev_active*/
//      }   /*if tistdscreenprint*/
//
//      
//      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//      {
//         switch(TITestType) {
//           case MP2       :  
//                          index_bankvt0 = 0;
//                          index_bankvt1 = 4;
//                        break; 
//           case MP3       :  
//                          if(not GL_SKIP_MP2_FLASHFLOW)  
//                           
//                             index_bankvt0 = 1;
//                             index_bankvt1 = 5;
//                           
//                          else
//                           
//                             index_bankvt0 = 0;
//                             index_bankvt1 = 4;
//                           break; 
//                        break; 
//           case PreBurnIn :  
//                          index_bankvt0 = 2;
//                          index_bankvt1 = 6;
//                        break; 
//         }   /* case */
//                    
//         if((MainVT.MEMCFG[CHKVT0DRL]==BANKTYPE) and (MainVT.MEMCFG[CHKVT1DRL]==BANKTYPE))  
//         {
//            index_otpvt0  = index_bankvt0+8;
//            index_otpvt1  = index_otpvt0+4;
//            
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  BANK_VT_VALUE[bankcount][0][CHKVT0DRL][pre][site] =
//                  OTP_VT_INFO_VAL[bankcount][index_bankvt0][site];
//                  
//                  BANK_BCC_VALUE[bankcount][0][CHKVT1DRL][pre][site] =
//                  OTP_BCC_INFO_VAL[bankcount][index_bankvt1][site];
//                  
//                  OTP_VT_VALUE[bankcount][CHKVT0DRL][pre][site] =
//                  OTP_VT_INFO_VAL[bankcount][index_otpvt0][site];
//                  
//                  OTP_BCC_VALUE[bankcount][CHKVT1DRL][pre][site] =
//                  OTP_BCC_INFO_VAL[bankcount][index_otpvt1][site];
//               } 
//         }
//         else
//         {
//            if((MainVT.MEMCFG[CHKVT0DRL]==SECTTYPE) and (MainVT.MEMCFG[CHKVT1DRL]==SECTTYPE))  
//               loop = F021_Flash.MAXSECT[bankcount];
//            else if((MainVT.MEMCFG[CHKVT0DRL]==QUADTYPE) and (MainVT.MEMCFG[CHKVT1DRL]==QUADTYPE))  
//               loop = FL_MAX_QUADRANT;
//            else
//               loop = F021_Flash.MAXBLOCK[bankcount];
//            
//            index_otpvt0  = index_bankvt0+(8*(loop+1));
//            index_otpvt1  = index_otpvt0+4;
//            
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  for (count = 0;count <= loop;count++)
//                  {
//                     BANK_VT_VALUE[bankcount][count][CHKVT0DRL][pre][site] =
//                     OTP_VT_INFO_VAL[bankcount][(index_bankvt0+(count*8))][site];
//                     
//                     BANK_BCC_VALUE[bankcount][count][CHKVT1DRL][pre][site] =
//                     OTP_BCC_INFO_VAL[bankcount][(index_bankvt1+(count*8))][site];
//                  } 
//                  
//                  OTP_VT_VALUE[bankcount][CHKVT0DRL][pre][site] =
//                  OTP_VT_INFO_VAL[bankcount][index_otpvt0][site];
//                  
//                  OTP_BCC_VALUE[bankcount][CHKVT1DRL][pre][site] =
//                  OTP_BCC_INFO_VAL[bankcount][index_otpvt1][site];
//               }   /*if v_dev_active*/
//         }   /*TARGET_SECT, LOGSECT*/
//      }   /*for bankcount*/
//   }   /*if v_any_dev_active*/
//
//   F021_ReadVT0BCC1OTP_func = v_any_dev_active;
//} 
//   
//
//BoolS F021_WriteVT0BCC1OTP_func(    StringS tname,
//                                       IntS wr_option,
//                                       BoolM test_results)
//{
//   const IntS TARGET_BANK = 0x0; 
//   const IntS TARGET_SECT = 0x1; 
//   const IntS TARGET_LOGSECT = 0x2; 
//
//   IntS bankcount,count,loop;
//   IntS site,wr_flag_num,length;
//   IntS1D start_tnumarr(4);
//   IntS testnum,start_tnum;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   FloatM tt_timer;
//   BoolM final_results,tmp_results;
//   BoolM savesites,logsites;
//   FloatS maxtime,ttimer1,ttimer2;
//   StringM temp_bcd;
//   StringS str1;
//   IntS addr_loc;
//   IntS pattype,pattype2;
//   IntS target_tnum,field_tnum;
//   BoolS bcd_format,hexvalue;
//   IntM1D vt_data(128);
//   IntS index1,index2,index3,index4;
//   IntS index5,index6,index7,index8;
//   IntS index9,index10,index11;
//   StringS fl_testname;
//   StringM site_cof_inst_str;
//   BoolS faildetect;
//   FloatM FloatSval;
//   TWunit unitval;
//   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
//   vttype vtcat0,vtcat1; 
//
//   if(v_any_dev_active)  
//   {
//      maxtime = GL_F021_MAXTIME;
//      wr_flag_num = 0x1234;
//      bcd_format  = true;
//      hexvalue    = true;
//      
//      writestring(tmpstr1,tname);
//      length = len(tmpstr1);
//      writestring(tmpstr1,mid(tmpstr1,2,length-6));  /*remove _Test*/
//      fl_testname = tname;
//      
//      timernstart(ttimer1);
//
//      TestOpen(fl_testname);
//
//      PrintHeaderBool(GL_PLELL_FORMAT);
//
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//
//      savesites = v_dev_active;
//      final_results = v_dev_active;
//
//      start_tnum = TNUM_OTP_WR_VT_MBOX;
//      
//      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//      {
//         timernstart(ttimer2);
//         faildetect = false;
//         
//         switch(wr_option) {
//           case 0..2:    /*mp1,mp2*/
//              pattype = MainVT.MEMCFG[CHKVT0];
//
//              if(TITestType==MP1)  
//                 field_tnum = 0x00880000;
//              else
//                 field_tnum = 0x00440000;
//              
//              if(pattype==BANKTYPE)  
//               
//                 numword_max = 3;  /*base 0 so 4 words*/
//                 target_tnum = 0;
//                 for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                    if(v_dev_active[site])  
//                     
//                       vt_data[0][site] = Trunc(BANK_VT_VALUE[bankcount][0][CHKVT0][pre][site]*100);
//                       vt_data[1][site] = Trunc((BANK_BCC_VALUE[bankcount][0][CHKVT1][pre][site]/1uA)*100);
//                       vt_data[2][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT0][pre][site]*100);
//                       vt_data[3][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT1][pre][site]/1uA)*100);
//                     break; 
//               
//              else 
//               
//                 if(pattype==BLOCKTYPE)  
//                  
//                     /*eg: numword=maxblk=3.  so numword_max=9 base0 (4 vt0 values, 4 vt1, 2 vt0/1 otp values)*/
//                    numword     = F021_Flash.MAXBLOCK[bankcount];  /*base0*/
//                    numword_max = (2*(numword+1))+1;  /*base0*/
//                    target_tnum = TARGET_LOGSECT<<8;
//                  
//                 else if(pattype==QUADTYPE)  
//                  
//                    numword     = FL_MAX_QUADRANT;
//                    numword_max = (2*(numword+1))+1;  /*base0*/
//                    target_tnum = TNUM_TARGET_QUAD;
//                  
//                 else
//                  
//                    numword     = F021_Flash.MAXSECT[bankcount];  /*base0*/
//                    numword_max = (2*(numword+1))+1;  /*base0*/
//                    target_tnum = TARGET_SECT<<8;
//                  break; 
//
//                 loop = 0;
//                 for (count = 0;count <= numword;count++)
//                  
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                        
//                          vt_data[loop][site] = Trunc(BANK_VT_VALUE[bankcount][count][CHKVT0][pre][site]*100);
//                          vt_data[loop+1][site] = Trunc((BANK_BCC_VALUE[bankcount][count][CHKVT1][pre][site]/1uA)*100);
//                       } 
//                    loop = loop+2;
//                 } 
//
//                 for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                    if(v_dev_active[site])  
//                    {
//                       vt_data[loop][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT0][pre][site]*100);
//                       vt_data[loop+1][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT1][pre][site]/1uA)*100);
//                    } 
//
//              }   /*if blocktype/secttype*/
//              
//              testnum = start_tnum+field_tnum+target_tnum+(bankcount<<4);
//           }   /*case 0..2*/
//
//           3: {  /*mp3*/
//                 pattype = BANKTYPE ; /*MainVT.MEMCFG[RCODEVT0]*/
//                 field_tnum = 0x00220000;
//#if $FL_USE_AUTO_FLOW  
//                 vtcat0 = RCODEVT0;
//                 vtcat1 = RCODEVT1;
//#else
//                 vtcat0 = CHKVT0;
//                 vtcat1 = CHKVT1;
//#endif   
//                 
//                 if(pattype==BANKTYPE)  
//                 {
//                    numword_max = 3;
//                    target_tnum = 0;
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                       {
//                          vt_data[0][site] = Trunc(BANK_VT_VALUE[bankcount][0][vtcat0][pre][site]*100);
//                          vt_data[1][site] = Trunc((BANK_BCC_VALUE[bankcount][0][vtcat1][pre][site]/1uA)*100);
//                          vt_data[2][site] = Trunc(OTP_VT_VALUE[bankcount][vtcat0][pre][site]*100);
//                          vt_data[3][site] = Trunc((OTP_BCC_VALUE[bankcount][vtcat1][pre][site]/1uA)*100);
//                       } 
//                 }
//                 else 
//                 {
//                    if(pattype==BLOCKTYPE)  
//                    {
//                       numword     = F021_Flash.MAXBLOCK[bankcount];
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TARGET_LOGSECT<<8;
//                    }
//                    else if(pattype==QUADTYPE)  
//                    {
//                       numword     = FL_MAX_QUADRANT;
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TNUM_TARGET_QUAD;
//                    }
//                    else
//                    {
//                       numword     = F021_Flash.MAXSECT[bankcount];
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TARGET_SECT<<8;
//                    } 
//                    
//                    loop = 0;
//                    for (count = 0;count <= numword;count++)
//                    {
//                       for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                          if(v_dev_active[site])  
//                          {
//                             vt_data[loop][site] = Trunc(BANK_VT_VALUE[bankcount][count][CHKVT0][pre][site]*100);
//                             vt_data[loop+1][site] = Trunc((BANK_BCC_VALUE[bankcount][count][CHKVT1][pre][site]/1uA)*100);
//                          } 
//                       loop = loop+2;
//                    } 
//                    
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                       {
//                          vt_data[loop][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT0][pre][site]*100);
//                          vt_data[loop+1][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT1][pre][site]/1uA)*100);
//                       } 
//                    
//                 }   /*if blocktype/secttype*/
//                 
//                 testnum = start_tnum+field_tnum+target_tnum+(bankcount<<4);
//              }   /*case 3*/
//
//           4: {  /*restore mp1 value @mp2*/
//                 pattype = MainVT.MEMCFG[CHKVT0DRL];
//                 field_tnum = 0x00880000;
//                 
//                 if(pattype==BANKTYPE)  
//                 {
//                    numword_max = 3;  /*base0 */
//                    target_tnum = 0;
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                       {
//                          vt_data[0][site] = Trunc(BANK_VT_VALUE[bankcount][0][CHKVT0DRL][pre][site]*100);
//                          vt_data[1][site] = Trunc((BANK_BCC_VALUE[bankcount][0][CHKVT1DRL][pre][site]/1uA)*100);
//                          vt_data[2][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT0DRL][pre][site]*100);
//                          vt_data[3][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT1DRL][pre][site]/1uA)*100);
//                       } 
//                 }
//                 else 
//                 {
//                    if(pattype==BLOCKTYPE)  
//                    {
//                       numword     = F021_Flash.MAXBLOCK[bankcount];  /*base0*/
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TARGET_LOGSECT<<8;
//                    }
//                    else if(pattype==QUADTYPE)  
//                    {
//                       numword     = FL_MAX_QUADRANT;
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TNUM_TARGET_QUAD;
//                    }
//                    else
//                    {
//                       numword     = F021_Flash.MAXSECT[bankcount];  /*base0*/
//                       numword_max = (2*(numword+1))+1;  /*base0*/
//                       target_tnum = TARGET_SECT<<8;
//                    } 
//
//                    loop = 0;
//                    for (count = 0;count <= numword;count++)
//                    {
//                       for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                          if(v_dev_active[site])  
//                          {
//                             vt_data[loop][site] = Trunc(BANK_VT_VALUE[bankcount][count][CHKVT0DRL][pre][site]*100);
//                             vt_data[loop+1][site] = Trunc((BANK_BCC_VALUE[bankcount][count][CHKVT1DRL][pre][site]/1uA)*100);
//                          } 
//                       loop = loop+2;
//                    } 
//                    
//                    for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                       if(v_dev_active[site])  
//                       {
//                          vt_data[loop][site] = Trunc(OTP_VT_VALUE[bankcount][CHKVT0DRL][pre][site]*100);
//                          vt_data[loop+1][site] = Trunc((OTP_BCC_VALUE[bankcount][CHKVT1DRL][pre][site]/1uA)*100);
//                       } 
//
//                 }   /*if blocktype/secttype*/
//                 
//                 testnum = start_tnum+field_tnum+target_tnum+(bankcount<<4);
//              }   /*case 4*/
// /*           
//            5: begin {restore mp1,mp2 value @mp3}
//                  pattype := MainVT.MEMCFG[CHKVT0DRL];
//                  field_tnum := 0x00CC0000;
//                  
//                  if(pattype=BANKTYPE) then
//                  begin
//                     numword_max := 7; {base0 }
//                     target_tnum := 0;
//                     for site := 1 to v_sites do
//                        if(v_dev_active[site]) then
//                        begin
//                           vt_data[0,site] := Trunc(BANK_VT_VALUE[bankcount,0,CHKVT0DRL,pre,site]*100);
//                           vt_data[1,site] := Trunc(OTP_VT_VALUE[bankcount,CHKVT0DRL,pre,site]*100);
//                           vt_data[2,site] := Trunc(BANK_VT_VALUE[bankcount,0,CHKVT0DRL,post,site]*100);
//                           vt_data[3,site] := Trunc(OTP_VT_VALUE[bankcount,CHKVT0DRL,post,site]*100);
//                           vt_data[4,site] := Trunc(BANK_VT_VALUE[bankcount,0,CHKVT1DRL,pre,site]*100);
//                           vt_data[5,site] := Trunc(OTP_VT_VALUE[bankcount,CHKVT1DRL,pre,site]*100);
//                           vt_data[6,site] := Trunc(BANK_VT_VALUE[bankcount,0,CHKVT1DRL,post,site]*100);
//                           vt_data[7,site] := Trunc(OTP_VT_VALUE[bankcount,CHKVT1DRL,post,site]*100);
//                        end;
//                  end
//                  else 
//                  begin
//                     if(pattype=BLOCKTYPE) then
//                     begin
//                        numword     := F021_Flash.MAXBLOCK[bankcount]; {base0}
//                        numword_max := (4*(numword+1))+3; {base0}
//                        target_tnum := TARGET_LOGSECT<<8;
//                     end
//                     else if(pattype=QUADTYPE) then
//                     begin
//                        numword     := FL_MAX_QUADRANT;
//                        numword_max := (4*(numword+1))+3; {base0}
//                        target_tnum := TNUM_TARGET_QUAD;
//                     end
//                     else
//                     begin
//                        numword     := F021_Flash.MAXSECT[bankcount]; {base0}
//                        numword_max := (4*(numword+1))+3; {base0}
//                        target_tnum := TARGET_SECT<<8;
//                     end;
// 
//                     index1 := numword;         {mp1 vt0}
//                     index2 := index1+1;        {mp1 vt0 otp}
//                     index3 := index2+1;        {mp2 vt0 start}
//                     index4 := index3+numword;  {mp2 vt0 end}
//                     index5 := index4+1;        {mp2 vt0 otp}
//                     index6 := index5+1;        {mp1 vt1 start}
//                     index7 := index6+numword;  {mp1 vt1 end}
//                     index8 := index7+1;        {mp1 vt1 otp}
//                     index9 := index8+1;        {mp2 vt1 start}
//                     index10 := index9+numword; {mp2 vt1 end}
//                     
//                     loop := 0;
//                     for count := 0 to numword_max do
//                     begin
//                        if(count<=index1) then
//                        begin
//                           for site := 1 to v_sites do
//                              if(v_dev_active[site]) then
//                                 vt_data[count,site] := Trunc(BANK_VT_VALUE[bankcount,loop,CHKVT0DRL,pre,site]*100);
//                        end
//                        else if(count=index2) then
//                        begin
//                           for site := 1 to v_sites do
//                              if(v_dev_active[site]) then
//                                 vt_data[count,site] := Trunc(OTP_VT_VALUE[bankcount,CHKVT0DRL,pre,site]*100);
//                        end
//                        else if((count>=index3) and (count<=index4)) then
//                        begin
//                           for site := 1 to v_sites do
//                              if(v_dev_active[site]) then
//                                 vt_data[count,site] := Trunc(BANK_VT_VALUE[bankcount,loop,CHKVT0DRL,post,site]*100);
//                        end
//                        else if(count=index5) then
//                        begin
//                           for site := 1 to v_sites do
//                              if(v_dev_active[site]) then
//                                 vt_data[count,site] := Trunc(OTP_VT_VALUE[bankcount,CHKVT0DRL,post,site]*100);
//                        end
//                        else if((count>=index6) and (count<=index7)) then
//                        begin
//                           for site := 1 to v_sites do
//                              if(v_dev_active[site]) then
//                                 vt_data[count,site] := Trunc(BANK_VT_VALUE[bankcount,loop,CHKVT1DRL,pre,site]*100);
//                        end
//                        else if(count=index8) then
//                        begin
//                           for site := 1 to v_sites do
//                              if(v_dev_active[site]) then
//                                 vt_data[count,site] := Trunc(OTP_VT_VALUE[bankcount,CHKVT1DRL,pre,site]*100);
//                        end
//                        else if((count>=index9) and (count<=index10)) then
//                        begin
//                           for site := 1 to v_sites do
//                              if(v_dev_active[site]) then
//                                 vt_data[count,site] := Trunc(BANK_VT_VALUE[bankcount,loop,CHKVT1DRL,post,site]*100);
//                        end
//                        else {if(count=numword_max) then}
//                        begin
//                           for site := 1 to v_sites do
//                              if(v_dev_active[site]) then
//                                 vt_data[count,site] := Trunc(OTP_VT_VALUE[bankcount,CHKVT1DRL,post,site]*100);
//                        end;
//                     
//                        if(loop=(numword+1)) then
//                           loop := 0
//                        else
//                           loop := loop+1;
//                     end; {for count}                       
// 
//                  end; {if blocktype/secttype}
//                  
//                  testnum := start_tnum+field_tnum+target_tnum+(bankcount<<4);
//               end; {case 5}
//            */
//           otherwise {
//              if(tistdscreenprint)  
// invalid wr_option for F021_WriteVT0BCC1OTP_func !!!" :  cout << "*** WARNING;) 
//           } 
//            
//         }   /* case wr_option */
//         
//         addr_loc = ADDR_RAM_MAILBOX;
//         msw_data = wr_flag_num; 
//         lsw_data = numword_max+1; 
//         WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                                  msw_data,hexvalue, bcd_format);
//         
//         for count = 0 to numword_max by 2 do
//         {
//            addr_loc = addr_loc+ADDR_RAM_INC;
//            msw_data = vt_data[count];  /*msword*/
//            lsw_data = vt_data[count+1];  /*lsword*/
//            WriteRamContentDec_32Bit(addr_loc,lsw_data, not hexvalue,
//                                     msw_data, not hexvalue, bcd_format);
//         } 
//            
//         logsites = v_dev_active;
//         tmp_results = v_dev_active;
//         F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results);
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//         
//         ttimer2 = timernread(ttimer2);
//         tt_timer = ttimer2;
//
//         writestring(tmpstr2,bankcount:1);
//         tmpstr2 = "_B" + tmpstr2;  /*_B#*/
//         tmpstr3 = tmpstr1 + tmpstr2;
//         tmpstr4 = tmpstr3 + "_TT";
//
//         TWTRealToRealMS(tt_timer,realval,unitval);
//         TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//               
//         if(tistdscreenprint)  
//            PrintResultBool(tmpstr3,testnum,tmp_results,GL_PLELL_FORMAT);
//               
//         if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//         {
//            faildetect = true;
//            F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
//            
//            if(TI_FlashCOFEna)  
//               F021_Update_COF_Inst_Str(tmpstr2,site_cof_inst_str,tmp_results);
//         } 
//         
//         if(faildetect)  
//            if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//               DevSetHoldStates(final_results);
//         
//         if(not v_any_dev_active)  
//            break;
//      }   /*for bankcount*/
//
//      Devsetholdstates(savesites);
//
//      ResultsRecordActive(final_results, S_NULL);
//      TestClose;
//
//      test_results = final_results;
//
//      if(TI_FlashCOFEna)  
//         F021_Save_COF_Info(tmpstr1,site_cof_inst_str,final_results);
//      
//      ttimer1 = timernread(ttimer1);
//      tt_timer = ttimer1;
//
//      tmpstr4 = tmpstr1 + "_TTT";
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//         DevSetHoldStates(final_results);
//
//   }   /*if v_any_dev_active*/
//
//   F021_WriteVT0BCC1OTP_func = v_any_dev_active;
//} 
//
//
//BoolS F021_ReadIDOTP_func(    BoolM test_results,
//                                 BoolS binout_ena)
//{
//   const IntS IND_OTPVER = 40; 
//   const IntS IND_CKSUMLEN = 41; 
//   const IntS IND_OTPCHKSUM_HI = 42; 
//   const IntS IND_OTPCHKSUM_LO = 43; 
//   const IntS IND_NUMSECT = 44; 
//   const IntS IND_NUMBANK = 45; 
//   const IntS IND_PKGID = 46; 
//   const IntS IND_MEMSIZE = 47; 
//   const IntS IND_ASIC_HI = 48; 
//   const IntS IND_ASIC_LO = 49; 
//   const IntS IND_LOT_HI = 50; 
//   const IntS IND_LOT_LO = 51; 
//   const IntS IND_FLWBYTE = 52; 
//   const IntS IND_WAFNUM = 53; 
//   const IntS IND_XPOS = 54; 
//   const IntS IND_YPOS = 55; 
//   const IntS IND_PSU_ESU = 56; 
//   const IntS IND_PVSU_EVSU = 57; 
//   const IntS IND_RVSU_PVACC = 58; 
//   const IntS IND_EXEZ_CVSU = 59; 
//   const IntS IND_PH_RH = 60; 
//   const IntS IND_PVH_PVH2 = 61; 
//   const IntS IND_EH_SEQ = 62; 
//   const IntS IND_VSTAT_SMFREQ = 63; 
//   const IntS IND_VHVESTART = 64; 
//   const IntS IND_VHVESTEP = 65; 
//   const IntS IND_VHVESTOP = 66; 
//   const IntS IND_MAXPP = 67; 
//   const IntS IND_MAXEP = 68; 
//   const IntS IND_PPW = 69; 
//   const IntS IND_EPW_HI = 70; 
//   const IntS IND_EPW_LO = 71; 
//   const IntS IND_VHVP = 72; 
//   const IntS IND_VHVE = 73; 
//   const IntS IND_VHVPV = 74; 
//   const IntS IND_VCG_VINH = 75; 
//   const IntS IND_VSL_VWL = 76; 
//   const IntS IND_VRD_VSA5 = 77; 
//   const IntS IND_APICHKSUM_HI = 78; 
//   const IntS IND_APICHKSUM_LO = 79; 
//   const IntS IND_BUSWIDTH = 80; 
//   const IntS IND_EEWIDTH = 81; 
//   const IntS IND_CPU1CPU2 = 82; 
//   const IntS IND_CPU3CPU4 = 83; 
//   const IntS IND_HWRESERVED1 = 84; 
//   const IntS IND_HWRESERVED2 = 85; 
//   const IntS IND_HWRESERVED3 = 86; 
//   const IntS IND_HWRESERVED4 = 87; 
//   const IntS IND_EFCHKSUM_HI = 88; 
//   const IntS IND_EFCHKSUM_LO = 89; 
//   const IntS IND_LPO_CAL = 90; 
//   const IntS IND_SPEEDBIN = 91; 
//   const IntS IND_FOSC = 92; 
//   const IntS IND_TRIMRESERVED1 = 93; 
//   const IntS IND_TRIMRESERVED2 = 94; 
//   const IntS IND_TRIMRESERVED3 = 95; 
//   const IntS IND_MP1REV = 96; 
//   const IntS IND_MP2REV = 97; 
//   const IntS IND_MP3REV = 98; 
//   const IntS IND_MP4FT1REV = 99; 
//   const IntS IND_MP5FT2REV = 100; 
//   const IntS IND_MP6FT3REV = 101; 
//   const IntS IND_FT4REV = 102; 
//   const IntS IND_FT5REV = 103; 
//
//   IntS bankcount,count,loop,row;
//   IntS site,rd_flag_num,length;
//   IntS start_tnum,testnum;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   FloatM tt_timer;
//   BoolM final_results,tmp_results;
//   BoolM savesites;
//   FloatS maxtime;
//   StringM temp_bcd;
//   StringS str1;
//   StringS tmpstr1,tmpstr2,tmpstr3;
//   IntS addr_loc,tmp_value;
//   IntS index_wd8_0,index_wd8_7;
//   IntS index_wd9_0,index_wd9_7;
//
//   if(v_any_dev_active)  
//   {
//      start_tnum = TNUM_OTP_RD_ID_MBOX;
//      maxtime = GL_F021_MAXTIME;
//      rd_flag_num = 0x4321;
//      numword     = 0;
//      numword_max = 127;
//      
//      savesites = v_dev_active;
//      final_results = v_dev_active;
//      SITE_LPO_TRIMMED = false;
//      
//      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//      {
//         testnum = start_tnum+(bankcount<<4);
//         tmp_results = v_dev_active;
//         F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results);
//
//         if(GL_DO_ESDA_WITH_SCRAM)  
//            Get_Flash_MBoxSpace_OTP_SCRAM;
//         
//         Get_MBoxSpace_FlagNum(msw_data,lsw_data);
//         
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//                /*if(lsw_data[site]<>data_flag_num) then
//                 tmp_results[site] := false;*/
//               if(msw_data[site]!=rd_flag_num)  
//               {
//                  tmp_results[site] = false;
//                  if(tistdscreenprint)  
//                     cout << "Site " << site:-4 << " Read Flag Not Matched " << 
//                             msw_data[site]:s_hex:-8 << " Expect of " << rd_flag_num:s_hex:-8 << endl;
//               } 
//            } 
//         
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//         
//         loop = 0;
//         row  = 0;
//         
//         for (count = numword;count <= numword_max;count++)
//         {
//            Get_MBoxSpace_RowX_WdX(row,loop,lsw_data);
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  OTP_ID_INFO_VAL[bankcount][count][site] = lsw_data[site];
//                   /*convert int number to hex string w/ 0x prefix*/
//                  writestring(temp_bcd[site],lsw_data[site]:s_hex:1);
//                   /*extract string w/o 0x prefix and prepend 0s as needed*/
//                   /*number "3" below is start position to extract*/
//                  length = len(temp_bcd[site]);
//                  writestring(temp_bcd[site],mid(temp_bcd[site],3,length-2));
//                  switch((length-2)) {
//                    case 1 : temp_bcd[site] = "000" + temp_bcd[site];
//                    case 2 : temp_bcd[site] = "00" + temp_bcd[site];
//                    case 3 : temp_bcd[site] = "0" + temp_bcd[site];
//                  }   /*case*/
//                  
//                  OTP_ID_INFO[bankcount][count][site]=temp_bcd[site];
//               }   /*if*/
//               
//            loop = loop+1;
//            if((loop mod 8)==0)  
//            {
//               loop = 0;
//               row  = row+1;
//            } 
//         }   /*for count*/
//
//         if(binout_ena)  
//            if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//               DevSetHoldStates(final_results);
//      }   /*for bankcount*/
//
//      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               FRM_OTP_BANK_EFSUM_HI_BCD[bankcount][site] = OTP_ID_INFO[bankcount][IND_EFCHKSUM_HI][site];
//               FRM_OTP_BANK_EFSUM_HI_VAL[bankcount][site] = OTP_ID_INFO_VAL[bankcount][IND_EFCHKSUM_HI][site];
//               FRM_OTP_BANK_EFSUM_LO_BCD[bankcount][site] = OTP_ID_INFO[bankcount][IND_EFCHKSUM_LO][site];
//               FRM_OTP_BANK_EFSUM_LO_VAL[bankcount][site] = OTP_ID_INFO_VAL[bankcount][IND_EFCHKSUM_LO][site];
//               if(tistdscreenprint and TI_FlashDebug)  
//                  cout << "Site " << site:-5 << " Bank" << bankcount:-2 << 
//                          " EFCHKSUM_MSW==" << FRM_OTP_BANK_EFSUM_HI_VAL[bankcount][site]:s_hex:6 << 
//                          " EFCHKSUM_LSW==" << FRM_OTP_BANK_EFSUM_LO_VAL[bankcount][site]:s_hex:6 << endl;
//            } 
//
//      devsetholdstates(savesites);
//      
//      if(tistdscreenprint)  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               cout << endl;
//               cout << "Site " << site:-5 << " OTP ID INFO" << endl;
//               for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//               {
//                  cout << "BANK " << bankcount:-4 << endl;
//                  loop = 0;
//                  row  = 0;
//                  for (count = numword;count <= numword_max;count++)
//                  {
//                     if((loop mod 8)==0)  
//                        cout << "Row " << row:-6;
//                     cout << OTP_ID_INFO[bankcount][count][site] << " ":4;
//                     loop = loop+1;
//                     if((loop mod 8)==0)  
//                     {
//                        cout << endl;
//                        loop = 0;
//                        row  = row+1;
//                     } 
//                  }   /*for count*/
//                  cout << endl;
//               }   /*for bankcount*/
//            }   /*if v_dev_active*/
//      }   /*if tistdscreenprint*/
//
//      
//      if(tistdscreenprint)  
//         cout << "Site":-6 << "ASIC#":-10 << "Rev":-6 << 
//                 "Lot#":-10 << "Wfr#":-6 << "XPos":-6 << "YPos":-6 << 
//                 "FlowByte":-10 << endl;
//
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            FRM_OTP_VERSION_BCD[site] = OTP_ID_INFO[0][IND_OTPVER][site];
//
//            FRM_OTP_PKGID_BCD[site]   = OTP_ID_INFO[0][IND_PKGID][site];
//            FRM_OTP_MEMSZ_BCD[site]   = OTP_ID_INFO[0][IND_MEMSIZE][site];
//
//            FRM_OTP_ASICHI_BCD[site]  = OTP_ID_INFO[0][IND_ASIC_HI][site];
//            FRM_OTP_ASICLO_BCD[site]  = OTP_ID_INFO[0][IND_ASIC_LO][site];
//            FRM_OTP_LOTHI_BCD[site]   = OTP_ID_INFO[0][IND_LOT_HI][site];
//            FRM_OTP_LOTLO_BCD[site]   = OTP_ID_INFO[0][IND_LOT_LO][site];
//
//            FRM_OTP_FLWBYTE_BCD[site] = OTP_ID_INFO[0][IND_FLWBYTE][site];
//            readstring("0x" + FRM_OTP_FLWBYTE_BCD[site]) + tmp_value;
//            FRM_OTP_FLWBYTE_VALUE[site] = tmp_value;
//            
//            FRM_OTP_WAFER_BCD[site]   = OTP_ID_INFO[0][IND_WAFNUM][site];
//            FRM_OTP_XPOS_BCD[site]    = OTP_ID_INFO[0][IND_XPOS][site];
//            FRM_OTP_YPOS_BCD[site]    = OTP_ID_INFO[0][IND_YPOS][site];
//
//            FRM_OTP_OTPCHKSUM_HI_BCD[site] = OTP_ID_INFO[0][IND_OTPCHKSUM_HI][site];
//            FRM_OTP_OTPCHKSUM_LO_BCD[site] = OTP_ID_INFO[0][IND_OTPCHKSUM_LO][site];
//            FRM_OTP_NUMSECT_BCD[site]      = OTP_ID_INFO[0][IND_NUMSECT][site];
//            FRM_OTP_NUMBANK_BCD[site]      = OTP_ID_INFO[0][IND_NUMBANK][site];
//            FRM_OTP_PSU_ESU_BCD[site]      = OTP_ID_INFO[0][IND_PSU_ESU][site];
//            FRM_OTP_PVSU_EVSU_BCD[site]    = OTP_ID_INFO[0][IND_PVSU_EVSU][site];
//            FRM_OTP_RVSU_PVACC_BCD[site]   = OTP_ID_INFO[0][IND_RVSU_PVACC][site];
//            FRM_OTP_EXEZ_CVSU_BCD[site]    = OTP_ID_INFO[0][IND_EXEZ_CVSU][site];
//            FRM_OTP_PH_RH_BCD[site]        = OTP_ID_INFO[0][IND_PH_RH][site];
//            FRM_OTP_PVH_PVH2_BCD[site]     = OTP_ID_INFO[0][IND_PVH_PVH2][site];
//            FRM_OTP_EH_SEQ_BCD[site]       = OTP_ID_INFO[0][IND_EH_SEQ][site];
//            FRM_OTP_VSTAT_SMFREQ_BCD[site] = OTP_ID_INFO[0][IND_VSTAT_SMFREQ][site];
//            FRM_OTP_VHVESTART_BCD[site]    = OTP_ID_INFO[0][IND_VHVESTART][site];
//            FRM_OTP_VHVESTEP_BCD[site]     = OTP_ID_INFO[0][IND_VHVESTEP][site];
//            FRM_OTP_VHVESTOP_BCD[site]     = OTP_ID_INFO[0][IND_VHVESTOP][site];
//            FRM_OTP_MAXPP_BCD[site]        = OTP_ID_INFO[0][IND_MAXPP][site];
//            FRM_OTP_MAXEP_BCD[site]        = OTP_ID_INFO[0][IND_MAXEP][site];
//            FRM_OTP_PPW_BCD[site]          = OTP_ID_INFO[0][IND_PPW][site];
//            FRM_OTP_EPW_HI_BCD[site]       = OTP_ID_INFO[0][IND_EPW_HI][site];
//            FRM_OTP_EPW_LO_BCD[site]       = OTP_ID_INFO[0][IND_EPW_LO][site];
//            FRM_OTP_VHVP_BCD[site]         = OTP_ID_INFO[0][IND_VHVP][site];
//            FRM_OTP_VHVE_BCD[site]         = OTP_ID_INFO[0][IND_VHVE][site];
//            FRM_OTP_VHVPV_BCD[site]        = OTP_ID_INFO[0][IND_VHVPV][site];
//            FRM_OTP_VCG_VINH_BCD[site]     = OTP_ID_INFO[0][IND_VCG_VINH][site];
//            FRM_OTP_VSL_VWL_BCD[site]      = OTP_ID_INFO[0][IND_VSL_VWL][site];
//            FRM_OTP_VRD_VSA5_BCD[site]     = OTP_ID_INFO[0][IND_VRD_VSA5][site];
//            FRM_OTP_APICHKSUM_HI_BCD[site] = OTP_ID_INFO[0][IND_APICHKSUM_HI][site];
//            FRM_OTP_APICHKSUM_LO_BCD[site] = OTP_ID_INFO[0][IND_APICHKSUM_LO][site];
//            FRM_OTP_BUSWIDTH_BCD[site]     = OTP_ID_INFO[0][IND_BUSWIDTH][site];
//            FRM_OTP_EEWIDTH_BCD[site]      = OTP_ID_INFO[0][IND_EEWIDTH][site];
//            FRM_OTP_CPU1CPU2_BCD[site]     = OTP_ID_INFO[0][IND_CPU1CPU2][site];
//            FRM_OTP_CPU3CPU4_BCD[site]     = OTP_ID_INFO[0][IND_CPU3CPU4][site];
//            FRM_OTP_LPO_CAL_BCD[site]      = OTP_ID_INFO[0][IND_LPO_CAL][site];
//            FRM_OTP_SPEEDBIN_BCD[site]     = OTP_ID_INFO[0][IND_SPEEDBIN][site];
//            FRM_OTP_FOSC_BCD[site]         = OTP_ID_INFO[0][IND_FOSC][site];
//            FRM_OTP_MP1REV_BCD[site]       = OTP_ID_INFO[0][IND_MP1REV][site];
//            FRM_OTP_MP2REV_BCD[site]       = OTP_ID_INFO[0][IND_MP2REV][site];
//            FRM_OTP_MP3REV_BCD[site]       = OTP_ID_INFO[0][IND_MP3REV][site];
//            FRM_OTP_MP4FT1REV_BCD[site]    = OTP_ID_INFO[0][IND_MP4FT1REV][site];
//            FRM_OTP_MP5FT2REV_BCD[site]    = OTP_ID_INFO[0][IND_MP5FT2REV][site];
//            FRM_OTP_MP6FT3REV_BCD[site]    = OTP_ID_INFO[0][IND_MP6FT3REV][site];
//            FRM_OTP_FT4REV_BCD[site]       = OTP_ID_INFO[0][IND_FT4REV][site];
//            FRM_OTP_FT5REV_BCD[site]       = OTP_ID_INFO[0][IND_FT5REV][site];
//            
//            if(GL_DO_LPO_TRIM)  
//            {
//               LPO_TRIMSAVED[site] = OTP_ID_INFO_VAL[0][IND_LPO_CAL][site];
//               if(LPO_TRIMSAVED[site] != 0xFFFF)  
//                  SITE_LPO_TRIMMED[site] = true;
//            } 
//
//            if(tistdscreenprint)  
//            {
//               tmpstr1 = concat(FRM_OTP_ASICHI_BCD[site],
//                                 mid(FRM_OTP_ASICLO_BCD[site],1,2));
//               tmpstr2 = mid(FRM_OTP_ASICLO_BCD[site],3,2);
//               tmpstr3 = concat(mid(FRM_OTP_LOTHI_BCD[site],2,3),
//                                 FRM_OTP_LOTLO_BCD[site]);
//               cout << site:-6 << tmpstr1:-10 << tmpstr2:-6 << 
//                       tmpstr3:-10 << FRM_OTP_WAFER_BCD[site]:-6 << 
//                       FRM_OTP_XPOS_BCD[site]:-6 << 
//                       FRM_OTP_YPOS_BCD[site]:-6 << 
//                       FRM_OTP_FLWBYTE_BCD[site]:-10 << endl;
//            } 
//         }   /*if v_dev_active*/
//
//       /*KChau 04/09/10 - added to use at mp3 for vhv ct upload*/
//      if(TITestType==MP3)  
//      {
//         VHV_PG_CT_TRIMSAVED =  OTP_ID_INFO_VAL[0][IND_VHVP];
//         VHV_ER_CT_TRIMSAVED =  OTP_ID_INFO_VAL[0][IND_VHVE];
//         VHV_PV_CT_TRIMSAVED =  OTP_ID_INFO_VAL[0][IND_VHVPV];
//         VHV_OTHER_CT_TRIMSAVED =  OTP_ID_INFO_VAL[0][IND_VCG_VINH];
//         VHV_ER_CT_STARTSAVED =  OTP_ID_INFO_VAL[0][IND_VHVESTART];
//         VHV_ER_CT_STEPSAVED =  OTP_ID_INFO_VAL[0][IND_VHVESTEP];
//         VHV_ER_CT_STOPSAVED =  OTP_ID_INFO_VAL[0][IND_VHVESTOP];
//         VHV_MAXPP_SAVED =  OTP_ID_INFO_VAL[0][IND_MAXPP];
//#if $FL_USE_NEW_VHV_TEMPL_ADDR  
//         VHV_PG_CT_TRIMSAVED_EMU =  OTP_ID_INFO_VAL[0][IND_VHVP];
//         VHV_ER_CT_TRIMSAVED_EMU =  OTP_ID_INFO_VAL[0][IND_VHVE];
//         VHV_PV_CT_TRIMSAVED_EMU =  OTP_ID_INFO_VAL[0][IND_VHVPV];
//         VHV_OTHER_CT_TRIMSAVED_EMU =  OTP_ID_INFO_VAL[0][IND_VCG_VINH];
//         VHV_ER_CT_STARTSAVED_EMU =  OTP_ID_INFO_VAL[0][IND_VHVESTART];
//         VHV_ER_CT_STEPSAVED_EMU =  OTP_ID_INFO_VAL[0][IND_VHVESTEP];
//         VHV_ER_CT_STOPSAVED_EMU =  OTP_ID_INFO_VAL[0][IND_VHVESTOP];
//#endif
//      } 
//
//      devsetholdstates(final_results);
//      
//       /*compare bank contents*/
//      tmp_results = v_dev_active;
//      for (bankcount = 1;bankcount <= F021_Flash.MAXBANK;bankcount++)
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               for (count = IND_OTPVER;count <= IND_CKSUMLEN;count++)
//                  if(OTP_ID_INFO[bankcount][count][site] != OTP_ID_INFO[0][count][site])  
//                  {
//                     tmp_results[site] = false;
//                     if(tistdscreenprint)  
//                        cout << "Site " << site:-5 << "OTP_ID_INFO[ "][count:-3][" ] mis-match" << endl;
//                  } 
//               
//               for (count = IND_PKGID;count <= IND_EFCHKSUM_LO;count++)
//                  if(OTP_ID_INFO[bankcount][count][site] != OTP_ID_INFO[0][count][site])  
//                  {
//                     tmp_results[site] = false;
//                     if(tistdscreenprint)  
//                        cout << "Site " << site:-5 << "OTP_ID_INFO[ "][count:-3][" ] mis-match" << endl;
//                  } 
//            }   /*if v_dev_active*/
//
//      ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//      test_results = final_results;
//
//      if(binout_ena)  
//         if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//            DevSetHoldStates(final_results);
//
//   }   /*if v_any_dev_active*/
//
//   F021_ReadIDOTP_func = v_any_dev_active;
//} 
//
//
//BoolS F021_ReadIDOTP_Pst_func(    BoolM test_results,
//                                 BoolS binout_ena)
//{
//   const IntS IND_OTPVER = 40; 
//   const IntS IND_CKSUMLEN = 41; 
//   const IntS IND_OTPCHKSUM_HI = 42; 
//   const IntS IND_OTPCHKSUM_LO = 43; 
//   const IntS IND_NUMSECT = 44; 
//   const IntS IND_NUMBANK = 45; 
//   const IntS IND_PKGID = 46; 
//   const IntS IND_MEMSIZE = 47; 
//   const IntS IND_ASIC_HI = 48; 
//   const IntS IND_ASIC_LO = 49; 
//   const IntS IND_LOT_HI = 50; 
//   const IntS IND_LOT_LO = 51; 
//   const IntS IND_FLWBYTE = 52; 
//   const IntS IND_WAFNUM = 53; 
//   const IntS IND_XPOS = 54; 
//   const IntS IND_YPOS = 55; 
//   const IntS IND_PSU_ESU = 56; 
//   const IntS IND_PVSU_EVSU = 57; 
//   const IntS IND_RVSU_PVACC = 58; 
//   const IntS IND_EXEZ_CVSU = 59; 
//   const IntS IND_PH_RH = 60; 
//   const IntS IND_PVH_PVH2 = 61; 
//   const IntS IND_EH_SEQ = 62; 
//   const IntS IND_VSTAT_SMFREQ = 63; 
//   const IntS IND_VHVESTART = 64; 
//   const IntS IND_VHVESTEP = 65; 
//   const IntS IND_VHVESTOP = 66; 
//   const IntS IND_MAXPP = 67; 
//   const IntS IND_MAXEP = 68; 
//   const IntS IND_PPW = 69; 
//   const IntS IND_EPW_HI = 70; 
//   const IntS IND_EPW_LO = 71; 
//   const IntS IND_VHVP = 72; 
//   const IntS IND_VHVE = 73; 
//   const IntS IND_VHVPV = 74; 
//   const IntS IND_VCG_VINH = 75; 
//   const IntS IND_VSL_VWL = 76; 
//   const IntS IND_VRD_VSA5 = 77; 
//   const IntS IND_APICHKSUM_HI = 78; 
//   const IntS IND_APICHKSUM_LO = 79; 
//   const IntS IND_BUSWIDTH = 80; 
//   const IntS IND_EEWIDTH = 81; 
//   const IntS IND_CPU1CPU2 = 82; 
//   const IntS IND_CPU3CPU4 = 83; 
//   const IntS IND_HWRESERVED1 = 84; 
//   const IntS IND_HWRESERVED2 = 85; 
//   const IntS IND_HWRESERVED3 = 86; 
//   const IntS IND_HWRESERVED4 = 87; 
//   const IntS IND_EFCHKSUM_HI = 88; 
//   const IntS IND_EFCHKSUM_LO = 89; 
//   const IntS IND_LPO_CAL = 90; 
//   const IntS IND_SPEEDBIN = 91; 
//   const IntS IND_FOSC = 92; 
//   const IntS IND_TRIMRESERVED1 = 93; 
//   const IntS IND_TRIMRESERVED2 = 94; 
//   const IntS IND_TRIMRESERVED3 = 95; 
//   const IntS IND_MP1REV = 96; 
//   const IntS IND_MP2REV = 97; 
//   const IntS IND_MP3REV = 98; 
//   const IntS IND_MP4FT1REV = 99; 
//   const IntS IND_MP5FT2REV = 100; 
//   const IntS IND_MP6FT3REV = 101; 
//   const IntS IND_FT4REV = 102; 
//   const IntS IND_FT5REV = 103; 
//
//   IntS bankcount,count,loop,row;
//   IntS site,rd_flag_num,length;
//   IntS start_tnum,testnum;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   FloatM tt_timer;
//   BoolM final_results,tmp_results;
//   FloatS maxtime;
//   StringM temp_bcd;
//   StringS str1;
//   StringS tmpstr1,tmpstr2,tmpstr3;
//   IntS addr_loc,tmp_value;
//   IntS maxbank;
//
//   if(v_any_dev_active)  
//   {
//      start_tnum = TNUM_OTP_RD_ID_MBOX;
//      maxtime = GL_F021_MAXTIME;
//      rd_flag_num = 0x4321;
//
//      if(TI_FlashDebug)  
//      {
//         numword     = 0;
//         numword_max = 127;
//      }
//      else
//      {
//         numword     = 40;
//         numword_max = 55;
//      } 
//         
//      final_results = v_dev_active;
//
//      if(TI_FlashDebug)  
//         maxbank = F021_Flash.MAXBANK;
//      else
//         maxbank = 0;
//      
//      for (bankcount = 0;bankcount <= maxbank;bankcount++)
//      {
//         testnum = start_tnum+(bankcount<<4);
//         tmp_results = v_dev_active;
//         F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results);
//
//         if(GL_DO_ESDA_WITH_SCRAM)  
//            Get_Flash_MBoxSpace_OTP_SCRAM;
//
//         if(TI_FlashDebug)  
//         {
//            Get_MBoxSpace_FlagNum(msw_data,lsw_data);
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                   /*if(lsw_data[site]<>data_flag_num) then
//                    tmp_results[site] := false;*/
//                  if(msw_data[site]!=rd_flag_num)  
//                  {
//                     tmp_results[site] = false;
//                     if(tistdscreenprint)  
//                        cout << "Site " << site:-4 << " Read Flag Not Matched " << 
//                                msw_data[site]:s_hex:-8 << " Expect of " << rd_flag_num:s_hex:-8 << endl;
//                  } 
//               } 
//         } 
//         
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//
//         if(TI_FlashDebug)  
//         {
//            loop = 0;
//            row  = 0;
//         }
//         else
//         {
//            loop = 0;
//            row  = 5;
//         } 
//            
//         for (count = numword;count <= numword_max;count++)
//         {
//            Get_MBoxSpace_RowX_WdX(row,loop,lsw_data);
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  OTP_ID_INFO_VAL[bankcount][count][site] = lsw_data[site];
//                   /*convert int number to hex string w/ 0x prefix*/
//                  writestring(temp_bcd[site],lsw_data[site]:s_hex:1);
//                   /*extract string w/o 0x prefix and prepend 0s as needed*/
//                   /*number "3" below is start position to extract*/
//                  length = len(temp_bcd[site]);
//                  writestring(temp_bcd[site],mid(temp_bcd[site],3,length-2));
//                  switch((length-2)) {
//                    case 1 : temp_bcd[site] = "000" + temp_bcd[site];
//                    case 2 : temp_bcd[site] = "00" + temp_bcd[site];
//                    case 3 : temp_bcd[site] = "0" + temp_bcd[site];
//                  }   /*case*/
//                  
//                  OTP_ID_INFO[bankcount][count][site]=temp_bcd[site];
//               }   /*if*/
//               
//            loop = loop+1;
//            if((loop mod 8)==0)  
//            {
//               loop = 0;
//               row  = row+1;
//            } 
//         }   /*for count*/
//
//         if(not TI_FlashDebug)  
//         {
//            loop = 0;
//            row  = 11;
//            for (count = IND_EFCHKSUM_HI;count <= IND_EFCHKSUM_LO;count++)
//            {
//               Get_MBoxSpace_RowX_WdX(row,loop,lsw_data);
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                  {
//                     OTP_ID_INFO_VAL[bankcount][count][site] = lsw_data[site];
//                      /*convert int number to hex string w/ 0x prefix*/
//                     writestring(temp_bcd[site],lsw_data[site]:s_hex:1);
//                      /*extract string w/o 0x prefix and prepend 0s as needed*/
//                      /*number "3" below is start position to extract*/
//                     length = len(temp_bcd[site]);
//                     writestring(temp_bcd[site],mid(temp_bcd[site],3,length-2));
//                     switch((length-2)) {
//                       case 1 : temp_bcd[site] = "000" + temp_bcd[site];
//                       case 2 : temp_bcd[site] = "00" + temp_bcd[site];
//                       case 3 : temp_bcd[site] = "0" + temp_bcd[site];
//                     }   /*case*/
//                     
//                     OTP_ID_INFO[bankcount][count][site]=temp_bcd[site];
//                  }   /*if*/
//               
//               loop = loop+1;
//            } 
//         } 
//
//         if(binout_ena)  
//            if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//               DevSetHoldStates(final_results);
//      }   /*for bankcount*/
//
//      for (bankcount = 0;bankcount <= maxbank;bankcount++)
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               FRM_OTP_BANK_EFSUM_HI_BCD[bankcount][site] = OTP_ID_INFO[bankcount][IND_EFCHKSUM_HI][site];
//               FRM_OTP_BANK_EFSUM_HI_VAL[bankcount][site] = OTP_ID_INFO_VAL[bankcount][IND_EFCHKSUM_HI][site];
//               FRM_OTP_BANK_EFSUM_LO_BCD[bankcount][site] = OTP_ID_INFO[bankcount][IND_EFCHKSUM_LO][site];
//               FRM_OTP_BANK_EFSUM_LO_VAL[bankcount][site] = OTP_ID_INFO_VAL[bankcount][IND_EFCHKSUM_LO][site];
//               if(tistdscreenprint and TI_FlashDebug)  
//                  cout << "Site " << site:-5 << " Bank" << bankcount:-2 << 
//                          " EFCHKSUM_MSW==" << FRM_OTP_BANK_EFSUM_HI_VAL[bankcount][site]:s_hex:6 << 
//                          " EFCHKSUM_LSW==" << FRM_OTP_BANK_EFSUM_LO_VAL[bankcount][site]:s_hex:6 << endl;
//            } 
//
//      if(tistdscreenprint)  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               cout << endl;
//               cout << "Site " << site:-5 << " OTP ID INFO" << endl;
//               for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//               {
//                  cout << "BANK " << bankcount:-4 << endl;
//                  if(TI_FlashDebug)  
//                  {
//                     loop = 0;
//                     row  = 0;
//                  }
//                  else
//                  {
//                     loop = 0;
//                     row  = 5;
//                  } 
//                     
//                  for (count = numword;count <= numword_max;count++)
//                  {
//                     if((loop mod 8)==0)  
//                        cout << "Row " << row:-6;
//                     cout << OTP_ID_INFO[bankcount][count][site] << " ":4;
//                     loop = loop+1;
//                     if((loop mod 8)==0)  
//                     {
//                        cout << endl;
//                        loop = 0;
//                        row  = row+1;
//                     } 
//                  }   /*for count*/
//                  cout << endl;
//               }   /*for bankcount*/
//            }   /*if v_dev_active*/
//      }   /*if tistdscreenprint*/
//
//      
//      if(tistdscreenprint)  
//         cout << "Site":-6 << "ASIC#":-10 << "Rev":-6 << 
//                 "Lot#":-10 << "Wfr#":-6 << "XPos":-6 << "YPos":-6 << 
//                 "FlowByte":-10 << endl;
//
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            FRM_OTP_VERSION_BCD[site] = OTP_ID_INFO[0][IND_OTPVER][site];
//
//            FRM_OTP_PKGID_BCD[site]   = OTP_ID_INFO[0][IND_PKGID][site];
//            FRM_OTP_MEMSZ_BCD[site]   = OTP_ID_INFO[0][IND_MEMSIZE][site];
//
//            FRM_OTP_ASICHI_BCD[site]  = OTP_ID_INFO[0][IND_ASIC_HI][site];
//            FRM_OTP_ASICLO_BCD[site]  = OTP_ID_INFO[0][IND_ASIC_LO][site];
//            FRM_OTP_LOTHI_BCD[site]   = OTP_ID_INFO[0][IND_LOT_HI][site];
//            FRM_OTP_LOTLO_BCD[site]   = OTP_ID_INFO[0][IND_LOT_LO][site];
//
//            FRM_OTP_FLWBYTE_BCD[site] = OTP_ID_INFO[0][IND_FLWBYTE][site];
//            readstring("0x" + FRM_OTP_FLWBYTE_BCD[site]) + tmp_value;
//            FRM_OTP_FLWBYTE_VALUE[site] = tmp_value;
//            
//            FRM_OTP_WAFER_BCD[site]   = OTP_ID_INFO[0][IND_WAFNUM][site];
//            FRM_OTP_XPOS_BCD[site]    = OTP_ID_INFO[0][IND_XPOS][site];
//            FRM_OTP_YPOS_BCD[site]    = OTP_ID_INFO[0][IND_YPOS][site];
//
//            if(TI_FlashDebug)  
//            {
//               FRM_OTP_OTPCHKSUM_HI_BCD[site] = OTP_ID_INFO[0][IND_OTPCHKSUM_HI][site];
//               FRM_OTP_OTPCHKSUM_LO_BCD[site] = OTP_ID_INFO[0][IND_OTPCHKSUM_LO][site];
//               FRM_OTP_NUMSECT_BCD[site]      = OTP_ID_INFO[0][IND_NUMSECT][site];
//               FRM_OTP_NUMBANK_BCD[site]      = OTP_ID_INFO[0][IND_NUMBANK][site];
//               FRM_OTP_PSU_ESU_BCD[site]      = OTP_ID_INFO[0][IND_PSU_ESU][site];
//               FRM_OTP_PVSU_EVSU_BCD[site]    = OTP_ID_INFO[0][IND_PVSU_EVSU][site];
//               FRM_OTP_RVSU_PVACC_BCD[site]   = OTP_ID_INFO[0][IND_RVSU_PVACC][site];
//               FRM_OTP_EXEZ_CVSU_BCD[site]    = OTP_ID_INFO[0][IND_EXEZ_CVSU][site];
//               FRM_OTP_PH_RH_BCD[site]        = OTP_ID_INFO[0][IND_PH_RH][site];
//               FRM_OTP_PVH_PVH2_BCD[site]     = OTP_ID_INFO[0][IND_PVH_PVH2][site];
//               FRM_OTP_EH_SEQ_BCD[site]       = OTP_ID_INFO[0][IND_EH_SEQ][site];
//               FRM_OTP_VSTAT_SMFREQ_BCD[site] = OTP_ID_INFO[0][IND_VSTAT_SMFREQ][site];
//               FRM_OTP_VHVESTART_BCD[site]    = OTP_ID_INFO[0][IND_VHVESTART][site];
//               FRM_OTP_VHVESTEP_BCD[site]     = OTP_ID_INFO[0][IND_VHVESTEP][site];
//               FRM_OTP_VHVESTOP_BCD[site]     = OTP_ID_INFO[0][IND_VHVESTOP][site];
//               FRM_OTP_MAXPP_BCD[site]        = OTP_ID_INFO[0][IND_MAXPP][site];
//               FRM_OTP_MAXEP_BCD[site]        = OTP_ID_INFO[0][IND_MAXEP][site];
//               FRM_OTP_PPW_BCD[site]          = OTP_ID_INFO[0][IND_PPW][site];
//               FRM_OTP_EPW_HI_BCD[site]       = OTP_ID_INFO[0][IND_EPW_HI][site];
//               FRM_OTP_EPW_LO_BCD[site]       = OTP_ID_INFO[0][IND_EPW_LO][site];
//               FRM_OTP_VHVP_BCD[site]         = OTP_ID_INFO[0][IND_VHVP][site];
//               FRM_OTP_VHVE_BCD[site]         = OTP_ID_INFO[0][IND_VHVE][site];
//               FRM_OTP_VHVPV_BCD[site]        = OTP_ID_INFO[0][IND_VHVPV][site];
//               FRM_OTP_VCG_VINH_BCD[site]     = OTP_ID_INFO[0][IND_VCG_VINH][site];
//               FRM_OTP_VSL_VWL_BCD[site]      = OTP_ID_INFO[0][IND_VSL_VWL][site];
//               FRM_OTP_VRD_VSA5_BCD[site]     = OTP_ID_INFO[0][IND_VRD_VSA5][site];
//               FRM_OTP_APICHKSUM_HI_BCD[site] = OTP_ID_INFO[0][IND_APICHKSUM_HI][site];
//               FRM_OTP_APICHKSUM_LO_BCD[site] = OTP_ID_INFO[0][IND_APICHKSUM_LO][site];
//               FRM_OTP_BUSWIDTH_BCD[site]     = OTP_ID_INFO[0][IND_BUSWIDTH][site];
//               FRM_OTP_EEWIDTH_BCD[site]      = OTP_ID_INFO[0][IND_EEWIDTH][site];
//               FRM_OTP_CPU1CPU2_BCD[site]     = OTP_ID_INFO[0][IND_CPU1CPU2][site];
//               FRM_OTP_CPU3CPU4_BCD[site]     = OTP_ID_INFO[0][IND_CPU3CPU4][site];
//               FRM_OTP_LPO_CAL_BCD[site]      = OTP_ID_INFO[0][IND_LPO_CAL][site];
//               FRM_OTP_SPEEDBIN_BCD[site]     = OTP_ID_INFO[0][IND_SPEEDBIN][site];
//               FRM_OTP_FOSC_BCD[site]         = OTP_ID_INFO[0][IND_FOSC][site];
//               FRM_OTP_MP1REV_BCD[site]       = OTP_ID_INFO[0][IND_MP1REV][site];
//               FRM_OTP_MP2REV_BCD[site]       = OTP_ID_INFO[0][IND_MP2REV][site];
//               FRM_OTP_MP3REV_BCD[site]       = OTP_ID_INFO[0][IND_MP3REV][site];
//               FRM_OTP_MP4FT1REV_BCD[site]    = OTP_ID_INFO[0][IND_MP4FT1REV][site];
//               FRM_OTP_MP5FT2REV_BCD[site]    = OTP_ID_INFO[0][IND_MP5FT2REV][site];
//               FRM_OTP_MP6FT3REV_BCD[site]    = OTP_ID_INFO[0][IND_MP6FT3REV][site];
//               FRM_OTP_FT4REV_BCD[site]       = OTP_ID_INFO[0][IND_FT4REV][site];
//               FRM_OTP_FT5REV_BCD[site]       = OTP_ID_INFO[0][IND_FT5REV][site];
//            } 
//            
//            if(tistdscreenprint)  
//            {
//               tmpstr1 = concat(FRM_OTP_ASICHI_BCD[site],
//                                 mid(FRM_OTP_ASICLO_BCD[site],1,2));
//               tmpstr2 = mid(FRM_OTP_ASICLO_BCD[site],3,2);
//               tmpstr3 = concat(mid(FRM_OTP_LOTHI_BCD[site],2,3),
//                                 FRM_OTP_LOTLO_BCD[site]);
//               cout << site:-6 << tmpstr1:-10 << tmpstr2:-6 << 
//                       tmpstr3:-10 << FRM_OTP_WAFER_BCD[site]:-6 << 
//                       FRM_OTP_XPOS_BCD[site]:-6 << 
//                       FRM_OTP_YPOS_BCD[site]:-6 << 
//                       FRM_OTP_FLWBYTE_BCD[site]:-10 << endl;
//            } 
//         }   /*if v_dev_active*/
//
//
//      ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//
//      test_results = final_results;
//
//   }   /*if v_any_dev_active*/
//
//   F021_ReadIDOTP_Pst_func = v_any_dev_active;
//} 
//
//BoolS F021_ReadLog1OTP_func(    BoolM test_results,
//                                   IntS rd_option)
//{
//   const IntS IND_W3_0 = 27; 
//   const IntS IND_W3_7 = 34; 
//   const IntS IND_W4_0 = 35; 
//   const IntS IND_W4_7 = 42; 
//   const IntS IND_W8_0 = 64; 
//   const IntS IND_W8_7 = 71; 
//   const IntS IND_W9_0 = 72; 
//   const IntS IND_W9_7 = 79; 
//
//   IntS bankcount,count,loop,row;
//   IntS site,rd_flag_num,length;
//   IntS start_tnum,testnum;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   FloatM tt_timer;
//   BoolM final_results,tmp_results;
//   BoolM savesites;
//   FloatS maxtime;
//   StringS str1,str2,str3;
//   IntS addr_loc,tmp_value;
//   IntS index_efchksum,index_fosc;
//   IntS index_lpo,index_mp1rev;
//   IntS index_wd8_7,index_wd8_0;
//   IntS index_wd9_7,index_wd9_0;
//   IntS wdnewline;
//
//   if(v_any_dev_active)  
//   {
//      start_tnum = TNUM_OTP_RD_LOG1_MBOX;
//      maxtime = GL_F021_MAXTIME;
//      rd_flag_num = 0x4321;
//
//      if(F021_Flash.DATAWIDTH == 144)  
//      {
//         switch(rd_option) {
//           case 0 :  
//                  numword     = 0;
//                  numword_max = 127;
//                break; 
//           case 1 :  
//                  numword     = IND_W8_0;  /*rd w8 & w9 only*/
//                  numword_max = IND_W9_7;
//                break; 
//           case 2 :  
//                  numword     = 0;
//                  numword_max = 31;
//                break; 
//           default:  
//              numword     = 0;
//              numword_max = 127;
//            break; 
//         }   /* case */
//         wdnewline = 8;
//          /*store W8/W9 info*/
//         index_wd8_7 = IND_W8_7;
//         index_wd8_0 = IND_W8_0;
//         index_wd9_7 = IND_W9_7;
//         index_wd9_0 = IND_W9_0;
//         str2 = " OTP W8_0 to W8_7 : ";
//         str3 = " OTP W9_0 to W9_7 : ";
//      }
//      else if(F021_Flash.DATAWIDTH == 64)  
//      {
//         switch(rd_option) {
//           case 0 :  
//                  numword     = 0;
//                  numword_max = 127;
//                break; 
//           case 1 :  
//                  numword     = IND_W3_0;  /*rd w3 & w4 only*/
//                  numword_max = IND_W4_7;
//                break;                   
//           case 2 :  
//                  numword     = 0;
//                  numword_max = 127;
//                break; 
//           default:  
//              numword     = 0;
//              numword_max = 127;
//            break; 
//         }   /* case */
//         wdnewline = 8;
//          /*store W3/W4 info*/
//         index_wd8_7 = IND_W3_7;
//         index_wd8_0 = IND_W3_0;
//         index_wd9_7 = IND_W4_7;
//         index_wd9_0 = IND_W4_0;
//         str2 = " OTP W3_0 to W3_7 : ";
//         str3 = " OTP W4_0 to W4_7 : ";
//      }
//      else
//      {
//         switch(rd_option) {
//           case 0 :  
//                  numword     = 0;
//                  numword_max = 127;
//                break; 
//           case 1 :  
//                  numword     = IND_W8_0;  /*rd w8 & w9 only*/
//                  numword_max = IND_W9_7;
//                break; 
//           case 2 :  
//                  numword     = 0;
//                  numword_max = 31;
//                break; 
//           default:  
//              numword     = 0;
//              numword_max = 127;
//            break; 
//         }   /* case */
//         wdnewline = 8;
//          /*store W8/W9 info*/
//         index_wd8_7 = IND_W8_7;
//         index_wd8_0 = IND_W8_0;
//         index_wd9_7 = IND_W9_7;
//         index_wd9_0 = IND_W9_0;
//         str2 = " OTP W8_0 to W8_7 : ";
//         str3 = " OTP W9_0 to W9_7 : ";
//      }   /*if datawidth*/
//   
//      
//      savesites = v_dev_active;
//      final_results = v_dev_active;
//      
//      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//      {
//         testnum = start_tnum+(bankcount<<4);
//         tmp_results = v_dev_active;
//         F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results);
//
//         if(GL_DO_ESDA_WITH_SCRAM)  
//            Get_Flash_MBoxSpace_OTP_SCRAM;
//         
//         Get_MBoxSpace_FlagNum(msw_data,lsw_data);
//         
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//                /*if(lsw_data[site]<>data_flag_num) then
//                 tmp_results[site] := false;*/
//               if(msw_data[site]!=rd_flag_num)  
//               {
//                  tmp_results[site] = false;
//                  if(tistdscreenprint)  
//                     cout << "Site " << site:-4 << " Read Flag Not Matched " << 
//                             msw_data[site]:s_hex:-8 << " Expect of " << rd_flag_num:s_hex:-8 << endl;
//               } 
//            } 
//         
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//
//         loop = 0;
//         if(rd_option==1)  
//            row = numword div wdnewline;
//         else
//            row  = 0;
//         
//         for (count = numword;count <= numword_max;count++)
//         {
//            Get_MBoxSpace_RowX_WdX(row,loop,lsw_data);
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//                  OTP_LOG1_INFO_VAL[bankcount][count][site]=lsw_data[site];
//
//            loop = loop+1;
//            if((loop mod wdnewline)==0)  
//            {
//               loop = 0;
//               row  = row+1;
//            } 
//         }   /*for count*/
//
//         if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//            Devsetholdstates(final_results);
//      }   /*for bankcount*/
//
//      test_results = final_results;
//
//      devsetholdstates(savesites);
//      
//      if(tistdscreenprint)  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               cout << endl;
//               cout << "Site " << site:-5 << " OTP DATA OFFSET LOG1 INFO" << endl;
//               for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//               {
//                  cout << "BANK " << bankcount:-4 << endl;
//                  loop = 0;
//                  if(rd_option==1)  
//                     row = numword div wdnewline;
//                  else
//                     row  = 0;
//                  
//                  for (count = numword;count <= numword_max;count++)
//                  {
//                     if((loop mod wdnewline)==0)  
//                        cout << "Row " << row:-6;
//                     cout << OTP_LOG1_INFO_VAL[bankcount][count][site]:s_hex:-6 << " ":2;
//                     loop = loop+1;
//                     if((loop mod wdnewline)==0)  
//                     {
//                        cout << endl;
//                        loop = 0;
//                        row  = row+1;
//                     } 
//                  }   /*for count*/
//                  cout << endl;
//               }   /*for bankcount*/
//            }   /*if v_dev_active*/
//      }   /*if tistdscreenprint*/
//
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//               cout << "Site" << site:-5 << str2;
//
//            loop = 0;
//            for (count = index_wd8_0;count <= index_wd8_7;count++)
//            {
//               writestring(str1,OTP_LOG1_INFO_VAL[0][count][site]:s_hex:1);
//               FRM_OTP_WD8[loop][site] = str1;
//               loop = loop+1;
//               if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//                  cout << " " << str1 << " ";
//            } 
//
//            if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//               cout << endl;
//
//            if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//               cout << "Site" << site:-5 << str3;
//            
//            loop = 0;
//            for (count = index_wd9_0;count <= index_wd9_7;count++)
//            {
//               writestring(str1,OTP_LOG1_INFO_VAL[0][count][site]:s_hex:1);
//               FRM_OTP_WD9[loop][site] = str1;
//               loop = loop+1;
//               if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//                  cout << " " << str1 << " ";
//            } 
//
//            if(tistdscreenprint and TI_FlashDebug and tiprintpass)  
//               cout << endl;
//         } 
//
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//         Devsetholdstates(final_results);
//
//   }   /*if v_any_dev_active*/
//
//   F021_ReadLog1OTP_func = v_any_dev_active;
//} 
//
//BoolS F021_ReadLog3OTP_func(    BoolM test_results,
//                                   IntS rd_option)
//{
//   IntS bankcount,count,loop,row;
//   IntS site,rd_flag_num,length;
//   IntS start_tnum,testnum;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   FloatM tt_timer;
//   BoolM final_results,tmp_results;
//   BoolM savesites;
//   FloatS maxtime;
//   StringS str1;
//   IntS addr_loc,tmp_value;
//   IntS index_efchksum,index_fosc;
//   IntS index_lpo,index_mp1rev;
//
//   if(v_any_dev_active)  
//   {
//      start_tnum = TNUM_OTP_RD_LOG3_MBOX;
//      maxtime = GL_F021_MAXTIME;
//      rd_flag_num = 0x4321;
//
//      switch(rd_option) {
//        case 0 :  
//               numword     = 0;
//               numword_max = 127;
//             break; 
//        case 1 :  
//               numword     = 120;   /*single/double bit error*/
//               numword_max = 127;
//             break; 
//        case 2 :  
//               numword     = 0;
//               numword_max = 31;
//             break; 
//        default:  
//           numword     = 0;
//           numword_max = 127;
//         break; 
//      }   /* case */
//      
//      savesites = v_dev_active;
//      final_results = v_dev_active;
//      
//      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//      {
//         testnum = start_tnum+(bankcount<<4);
//         tmp_results = v_dev_active;
//         F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results);
//
//         if(GL_DO_ESDA_WITH_SCRAM)  
//            Get_Flash_MBoxSpace_OTP_SCRAM;
//         
//         Get_MBoxSpace_FlagNum(msw_data,lsw_data);
//         
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//                /*if(lsw_data[site]<>data_flag_num) then
//                 tmp_results[site] := false;*/
//               if(msw_data[site]!=rd_flag_num)  
//               {
//                  tmp_results[site] = false;
//                  if(tistdscreenprint)  
//                     cout << "Site " << site:-4 << " Read Flag Not Matched " << 
//                             msw_data[site]:s_hex:-8 << " Expect of " << rd_flag_num:s_hex:-8 << endl;
//               } 
//            } 
//         
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//
//         loop = 0;
//         if(rd_option==1)  
//            row = numword div 8;
//         else
//            row  = 0;
//         
//         for (count = numword;count <= numword_max;count++)
//         {
//            Get_MBoxSpace_RowX_WdX(row,loop,lsw_data);
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//                  OTP_LOG3_INFO_VAL[bankcount][count][site]=lsw_data[site];
//
//            loop = loop+1;
//            if((loop mod 8)==0)  
//            {
//               loop = 0;
//               row  = row+1;
//            } 
//         }   /*for count*/
//
//         if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//            Devsetholdstates(final_results);
//      }   /*for bankcount*/
//         
//      test_results = final_results;
//
//      devsetholdstates(savesites);
//
//      if(tistdscreenprint)  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               cout << endl;
//               cout << "Site " << site:-5 << " OTP DATA OFFSET LOG3 INFO" << endl;
//               for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//               {
//                  cout << "BANK " << bankcount:-4 << endl;
//                  loop = 0;
//                  if(rd_option==1)  
//                     row  = numword div 8;
//                  else
//                     row  = 0;
//                  for (count = numword;count <= numword_max;count++)
//                  {
//                     if((loop mod 8)==0)  
//                        cout << "Row " << row:-6;
//                     cout << OTP_LOG3_INFO_VAL[bankcount][count][site]:s_hex:-6 << " ":2;
//                     loop = loop+1;
//                     if((loop mod 8)==0)  
//                     {
//                        cout << endl;
//                        loop = 0;
//                        row  = row+1;
//                     } 
//                  }   /*for count*/
//                  cout << endl;
//               }   /*for bankcount*/
//            }   /*if v_dev_active*/
//      }   /*if tistdscreenprint*/
//
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//         Devsetholdstates(final_results);
//
//   }   /*if v_any_dev_active*/
//
//   F021_ReadLog3OTP_func = v_any_dev_active;
//} 
//
//
// /*F021_RestoreOTPInfo_func is intended to use at MP3 after stresses tests which does*/
// /*re-write TI-OTP contents that was saved during flowcheck test*/
//BoolS F021_RestoreOTPInfo_func(    StringS tname,
//                                      BoolM test_results,
//                                      BoolS dlogonly)
//{
//   const  DATA_TARG_ARB = 0x0000AA00;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS IND_FLWBYTE = 52; 
//   const IntS IND_OTPCHKSUM_HI = 42; 
//   const IntS IND_OTPCHKSUM_LO = 43; 
//   const IntS IND_MP2REV = 97; 
//   const IntS IND_MP3REV = 98;    
//
//   BoolM tmp_results,final_results;
//   BoolM savesites,logsites;
//   BoolS binout_ena;
//   IntS testnum,length,flowbit;
//   IntS bank,count,loop,site,index;
//   IntS wr_flag_num,numword,numword_max;
//   IntS addr_loc,addr_msw,addr_lsw;
//   BoolS bcd_format,hexvalue;
//   IntM msw_data,lsw_data;
//   FloatS maxtime;
//   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
//   StringS fl_testname;
//   StringM site_cof_inst_str;
//
//   if(V_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ F021_RestoreOTPInfo_func +++++" << endl;
//   
//      final_results = V_dev_active;
//      savesites = V_dev_active;
//
//      wr_flag_num = 0x1234;
//      numword     = 0;
//      numword_max = 127;
//      bcd_format  = true;
//      hexvalue    = true;
//      maxtime     = GL_F021_MAXTIME;
//
//      writestring(tmpstr1,tname);
//      length = len(tmpstr1);
//      writestring(tmpstr1,mid(tmpstr1,2,length-6));
//      fl_testname = tname;
//
//      if(not dlogonly)  
//         TestOpen(fl_testname);
//
//       /*+++ clear good flowbit +++*/
//      switch(TITestType) {
//        case MP1 : flowbit = 0x0001;
//        case MP2 : flowbit = 0x0002;
//        case MP3 :  
//                 if(GL_DO_TNI_CODE)  
//                    flowbit = 0x0204;
//                 else
//                    flowbit = 0x0004;
//               break; 
//        default:  
//           flowbit = 0x0000;
//         break; 
//      }   /* case */
//      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               OTP_ID_INFO_VAL[bank][IND_FLWBYTE][site] = OTP_ID_INFO_VAL[bank][IND_FLWBYTE][site] | flowbit;
//               OTP_ID_INFO_VAL[bank][IND_OTPCHKSUM_HI][site] = 0xffff;
//               OTP_ID_INFO_VAL[bank][IND_OTPCHKSUM_LO][site] = 0xffff;
//               switch(TITestType) {
//                 case MP2 : OTP_ID_INFO_VAL[bank][IND_MP2REV][site] = 0xffff;
//                 case MP3 : OTP_ID_INFO_VAL[bank][IND_MP3REV][site] = 0xffff;
//               }   /* case */
//            } 
//      } 
//
//      PrintHeaderBool(GL_PLELL_FORMAT);
//
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//
//      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//      {
//         for (loop = 0;loop <= 3;loop++)
//         {
//             /*clear mp2/mp3  drl vt*/
//            if(loop==2)  
//            {
//               if(TITestType==MP2)  
//                  index = 1;
//               else if(TITestType==MP3)  
//                  index = 2;
//               for (count = 1;count <= 32;count++)
//               {
//                  OTP_BCC_INFO_INTVAL[bank][index] = 0xffff;
//                  index = index+4;
//               } 
//            } 
//               
//            tmp_results = V_dev_active;
//            logsites = V_dev_active;
//
//            addr_msw = ADDR_TIOTP_HI[bank];
//            addr_lsw = ADDR_TIOTP_LO[bank]+(loop*0x100);
//            TL_SetARBADDR(addr_msw,addr_lsw);
//            addr_msw = 0;
//            addr_lsw = (numword_max+1)*2;
//            TL_SetARBLENGTH(addr_msw,addr_lsw);
//            
//            testnum = TNUM_BANK_PROG_SM+DATA_TARG_ARB+(bank<<4);
//            addr_loc = ADDR_RAM_MAILBOX;
//            msw_data = wr_flag_num;  /*msword*/
//            lsw_data = numword_max+1;  /*lsword*/
//            WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                                     msw_data,hexvalue,bcd_format);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//            
//            for count = numword to numword_max by 2 do
//            {
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                  {
//                     switch(loop) {
//                       case 0 :  
//                              msw_data[site] = OTP_LOG1_INFO_VAL[bank][count][site];
//                              lsw_data[site] = OTP_LOG1_INFO_VAL[bank][count+1][site];
//                            break; 
//                       case 1 :  
//                              msw_data[site] = OTP_ID_INFO_VAL[bank][count][site];
//                              lsw_data[site] = OTP_ID_INFO_VAL[bank][count+1][site];
//                            break; 
//                       case 2 :  
//                              msw_data[site] = OTP_BCC_INFO_INTVAL[bank][count][site];
//                              lsw_data[site] = OTP_BCC_INFO_INTVAL[bank][count+1][site];
//                            break; 
//                       case 3 :  
//                              msw_data[site] = OTP_LOG3_INFO_VAL[bank][count][site];
//                              lsw_data[site] = OTP_LOG3_INFO_VAL[bank][count+1][site];
//                            break; 
//                     }   /* case */
//                  }   /*v_dev_active*/
//#if $GL_USE_DMLED_RAMPMT  
//    /*swizzle for shell endianness on blizzard*/
//               WriteRamContentDec_32Bit(addr_loc,msw_data,hexvalue,
//                                        lsw_data,hexvalue,bcd_format);
//#else   
//               WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                                        msw_data,hexvalue,bcd_format);
//#endif
//               addr_loc = addr_loc+ADDR_RAM_INC;
//            }   /*for count*/
//
//            F021_RunTestNumber(testnum,maxtime,spare_mstreal1,tmp_results);
//            Arrayandboolean(final_results,final_results,tmp_results,v_sites);
//
//            writestring(tmpstr2,bank:1);
//            tmpstr2 = "_B" + tmpstr2;  /*_B#*/
//            writestring(tmpstr4,loop:1);
//            tmpstr2 = "_REG" + tmpstr4;
//            tmpstr3 = tmpstr1 + tmpstr2;
//            tmpstr3 = tmpstr1 + tmpstr4;
//
//            if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//            {
//               if(not dlogonly)  
//                  F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
//            
//               if(TI_FlashCOFEna)  
//                  F021_Update_COF_Inst_Str(tmpstr2,site_cof_inst_str,tmp_results);
//            } 
//         
//            if(tistdscreenprint)  
//               PrintResultBool(tmpstr3,testnum,tmp_results,GL_PLELL_FORMAT);
//
//            if((not TIIgnoreFail) and (not TI_FlashCOFEna) and (not dlogonly))  
//               DevSetHoldStates(final_results);
//
//            if(not v_any_dev_active)  
//               break;
//         }   /*loop*/
//
//         if(not v_any_dev_active)  
//            break;
//      }   /*bank*/
//
//      if(not dlogonly)  
//      {
//         Devsetholdstates(savesites);
//         
//         ResultsRecordActive(final_results, S_NULL);
//         TestClose;
//      } 
//      
//      test_results = final_results;
//
//      if(TI_FlashCOFEna)  
//         F021_Save_COF_Info(tmpstr1,site_cof_inst_str,final_results);
//
//      TL_SetARBADDR(0,0);
//      TL_SetARBLENGTH(0,0);
//
//      if(tistdscreenprint and TI_FlashDebug)  
//         TL_DumpOTP;
//      
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna) and (not dlogonly))  
//         DevSetHoldStates(final_results);
//   }   /*if v_any_dev_active*/
//
//   F021_RestoreOTPInfo_func = v_any_dev_active;
//}   /* F021_RestoreOTPInfo_func */
//   
//void GoRestoreOTP_OnFail()
//{
//   IntS site,i,bank,tnum;
//   IntS1D testnum(4);
//   StringS1D str1(4);
//   BoolM savesites,logsites;
//   BoolM allsitefalse,results;
//
//   if((not TI_FlashCOFEna) and (not TIIgnoreFail))  
//   {
//      allsitefalse = false;
//      savesites = v_dev_active;
//      ArrayAndBoolean(logsites,GL_FLASH_SAVESITES,SITE_TO_RESTORE_OTP,v_sites);
//
//      if(not ArrayCompareBoolean(logsites,allsitefalse,v_sites))  
//      {
//         DevSetHoldStates(logsites);
//         powerupatvnom(dcsetup_loosevnom,norm_fmsu);
//         clockset(s_clock1a,false,GL_F021_PLLENA_SPEED1,
//                  v[vih_loose_osc_vnom],v[vil_loose]);
//         TIME.Wait(2ms);      
//         patternexecute(i,f021_shell_loadpat);
//         RAM_Upload_PMOS_TrimCode;
//         RAM_Upload_VHV_CT_TrimVal;
//         TL_RunTestNum(TNUM_OTP_ERS_PRECON,"");  /*erase otp w/o log tw*/
//         F021_RestoreOTPInfo_func(NULL_TestName,results,true);
//
//         DevSetHoldStates(savesites);
//      } 
//   }    
//}   /* GoRestoreOTP_OnFail */
//
//
//BoolS F021_ReadOTPInfo_func(    BoolM test_results)
//{
//   BoolM tmp_results,final_results;
//   BoolS binout_ena;
//   IntS rd_option;
//   FloatS ttimer1;
//
//   if(V_any_dev_active)  
//   {
//      timernstart(ttimer1);
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ F021_ReadOTPInfo_func +++++" << endl;
//   
//      final_results = V_dev_active;
//      tmp_results = V_dev_active;
//
//      if((TITestType==MP2) or (TITestType==MP3))  
//         rd_option = 0  ; /*read all locations for restore if needed*/
//      else
//         rd_option = 1;  /*read w8 & w9 only*/
//      if(TI_FlashDebug and tistdscreenprint)  
//         rd_option = 0;
//      F021_ReadLog1OTP_func(tmp_results,rd_option);
//      Arrayandboolean(final_results,final_results,tmp_results,v_sites);
//
//      binout_ena = true;
//      F021_ReadIDOTP_func(tmp_results,binout_ena);
//      Arrayandboolean(final_results,final_results,tmp_results,v_sites);
//      if(GL_DO_DRL0_USING_VT and (not GL_DO_DRL1_USING_VT))  
//         F021_ReadVT0BCC1OTP_func(tmp_results,binout_ena)
//          /*discard(F021_ReadVTOTP_func(tmp_results,binout_ena))*/
//      else
//         F021_ReadBCCOTP_func(tmp_results,binout_ena);
//      Arrayandboolean(final_results,final_results,tmp_results,v_sites);
//
//      rd_option = 0;
//      F021_ReadLog3OTP_func(tmp_results,rd_option);
//      Arrayandboolean(final_results,final_results,tmp_results,v_sites);
//
//      test_results = final_results;
//
//      if(tistdscreenprint)  
//         cout << "F021_ReadOTPInfo_func TT : " << timernread(ttimer1) << endl;
//   } 
//
//   F021_ReadOTPInfo_func = v_any_dev_active;
//}  
//
//void MBox_Upload_DieID()
//{
//   IntS site,length;
//   IntS wr_flag_num;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   IntS addr_loc,tmp_value;
//   StringS this_wfrid;
//   IntM xpos,ypos,final_flowbyte;
//   IntS asichi_bcdnum,asiclo_bcdnum;
//   IntS lothi_bcdnum,lotlo_bcdnum;
//   IntS wfr_bcdnum,flowbyte_bcdnum;
//   string[16] dummy_bcd;
//   BoolS bcd_format,hexvalue;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ MBox_Upload_DieID +++++" << endl;
//
//      wr_flag_num = 0x1234;
//      numword_max = 8;
//      bcd_format  = true;
//      hexvalue    = true;
//      
//      if IsProber  
//      {
//          /*this_wfrid := TWWaferID;*/
//         this_wfrid = prober.waferIDStr;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               xpos[site] = STPTWDevX[site];
//               ypos[site] = STPTWDevY[site];
//            } 
//      }
//      else
//      {
//         this_wfrid = "C-1234567-25";
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               xpos[site] = site;
//               ypos[site] = site+1;
//            } 
//      } 
//            
//       /*convert string or int to nonhex "bcd" int like drl vt*/
//      dummy_bcd = mid(this_wfrid,3,3);   /*parse 123*/
//      readstring(dummy_bcd,lothi_bcdnum);  /*nothexval 123*/
//            
//      dummy_bcd = mid(this_wfrid,6,4);   /*parse 4567*/
//      readstring(dummy_bcd,lotlo_bcdnum);  /*nothexval 4567*/
//      
//      dummy_bcd   = mid(this_wfrid,11,2);  /*parse 25*/
//      readstring(dummy_bcd,wfr_bcdnum);   /*nothex wfr#*/
//      
//      writestring(dummy_bcd,gl_asiclo:s_hex:1);
//      dummy_bcd = mid(dummy_bcd,5,2);  /*extract 2-digit lsb of gl_asiclo*/
//      readstring("0x" + dummy_bcd) + asiclo_bcdnum;
//      
//      dummy_bcd = GL_MP1_FLWBYTE;
//      readstring("0x" + dummy_bcd) + flowbyte_bcdnum;
//
//       /*added for fake repair*/
//      if(GL_DO_REPAIR and (GL_FAKEREP_COUNT == GL_FAKEREP_SAMPLING))  
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               final_flowbyte[site] = flowbyte_bcdnum&0xF7FF;
//      }
//      else
//      {
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               if((SITE_TO_REPAIR_FAST[site] and
//                   SITE_GOOD_REPAIR_FAST[site]) or
//                  (SITE_TO_REPAIR_SLOW[site] and
//                  SITE_GOOD_REPAIR_SLOW[site]))  
//                  final_flowbyte[site] = flowbyte_bcdnum&0xF7FF
//               else
//                  final_flowbyte[site] = flowbyte_bcdnum;
//            } 
//      } 
//      
//      addr_loc = ADDR_RAM_MAILBOX;
//       /*upload write flag (msw) and data length (lsw)*/
//      msw_data = wr_flag_num;  /*msword*/
//      lsw_data = numword_max;  /*lsword*/
//       /*upload to ram 32-bit write flag and data length*/
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//         
//       /*upload asiclo/silicon rev (msw), lothi (lsw)*/
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      msw_data = asiclo_bcdnum;
//      lsw_data = lothi_bcdnum;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,not hexvalue,
//                               msw_data,hexvalue,bcd_format);
//      
//       /*lotlo msw, wfr# lsw*/
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      msw_data = lotlo_bcdnum;
//      lsw_data = wfr_bcdnum;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,not hexvalue,
//                               msw_data,not hexvalue,bcd_format);
//         
//       /*x-coord msw, y-coord lsw*/
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      msw_data = xpos;
//      lsw_data = ypos;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,not hexvalue,
//                                  msw_data,not hexvalue,bcd_format);
//      
//       /*flowbyte (msw/lsw)*/
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      msw_data = final_flowbyte;
//      lsw_data = final_flowbyte;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//   } 
//   
//}   /* MBox_Upload_DieID */
//
//
//void MBox_Upload_PgmRev()
//{
//   IntS site,length;
//   IntS wr_flag_num;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   IntS addr_loc,tmp_value;
//   StringS this_wfrid;
//   IntM xpos,ypos,final_flowbyte;
//   IntS asichi_bcdnum,asiclo_bcdnum;
//   IntS lothi_bcdnum,lotlo_bcdnum;
//   IntS wfr_bcdnum,flowbyte_bcdnum;
//   string[16] dummy_bcd;
//   BoolS bcd_format,hexvalue;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ MBox_Upload_PgmRev +++++" << endl;
//
//      bcd_format  = true;
//      hexvalue    = true;
//      wr_flag_num = 0x1234;
//      numword_max = 1;
//      addr_loc = ADDR_RAM_MAILBOX;
//       /*upload write flag (msw) and data length (lsw)*/
//      msw_data = wr_flag_num;  /*msword*/
//      lsw_data = numword_max;  /*lsword*/
//       /*upload to ram 32-bit write flag and data length*/
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//         
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      msw_data = GL_PGMREV;
//      lsw_data = GL_PGMREV;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//   } 
//   
//}   /* MBox_Upload_PgmRev */
//
//
//void MBox_Upload_PkgMem()
//{
//   IntS site,length;
//   IntS wr_flag_num;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   IntS addr_loc,tmp_value;
//   StringS this_wfrid;
//   IntM xpos,ypos,final_flowbyte;
//   IntS asichi_bcdnum,asiclo_bcdnum;
//   IntS lothi_bcdnum,lotlo_bcdnum;
//   IntS wfr_bcdnum,flowbyte_bcdnum;
//   string[16] dummy_bcd;
//   BoolS bcd_format,hexvalue;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ MBox_Upload_PkgMem +++++" << endl;
//
//      bcd_format  = true;
//      hexvalue    = true;
//      wr_flag_num = 0x1234;
//      numword_max = 2;
//      addr_loc = ADDR_RAM_MAILBOX;
//       /*upload write flag (msw) and data length (lsw)*/
//      msw_data = wr_flag_num;  /*msword*/
//      lsw_data = numword_max;  /*lsword*/
//       /*upload to ram 32-bit write flag and data length*/
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//         
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      msw_data = GL_DEV_PKG_ID;
//      lsw_data = GL_DEV_MEMSZ;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//   } 
//}   /* MBox_Upload_PkgMem */
//
//void MBox_Upload_EFChkSum()
//{
//   IntS site,length;
//   IntS wr_flag_num;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   IntS addr_loc,tmp_value;
//   StringS this_wfrid;
//   IntM xpos,ypos,final_flowbyte;
//   IntS asichi_bcdnum,asiclo_bcdnum;
//   IntS lothi_bcdnum,lotlo_bcdnum;
//   IntS wfr_bcdnum,flowbyte_bcdnum;
//   string[16] dummy_bcd;
//   BoolS bcd_format,hexvalue;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ MBox_Upload_EFChkSum +++++" << endl;
//
//      bcd_format  = true;
//      hexvalue    = true;
//      wr_flag_num = 0x1234;
//      numword_max = 2;
//      addr_loc = ADDR_RAM_MAILBOX;
//       /*upload write flag (msw) and data length (lsw)*/
//      msw_data = wr_flag_num;  /*msword*/
//      lsw_data = numword_max;  /*lsword*/
//       /*upload to ram 32-bit write flag and data length*/
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//         
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      msw_data = EFCHKSUM_MSW;
//      lsw_data = EFCHKSUM_LSW;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//   } 
//}   /* MBox_Upload_EFChkSum */
//
//void MBox_Upload_EFChkSum_Pump_Trim()
//{
//   IntS site,length;
//   IntS wr_flag_num;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   IntS addr_loc,tmp_value;
//   StringS this_wfrid;
//   IntM xpos,ypos,final_flowbyte;
//   IntS asichi_bcdnum,asiclo_bcdnum;
//   IntS lothi_bcdnum,lotlo_bcdnum;
//   IntS wfr_bcdnum,flowbyte_bcdnum;
//   string[16] dummy_bcd;
//   BoolS bcd_format,hexvalue;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ MBox_Upload_EFChkSum_Pump_Trim +++++" << endl;
//
//      bcd_format  = true;
//      hexvalue    = true;
//      wr_flag_num = 0x1234;
//      numword_max = 5;
//      addr_loc = ADDR_RAM_MAILBOX;
//       /*upload write flag (msw) and data length (lsw)*/
//      msw_data = wr_flag_num;  /*msword*/
//      lsw_data = numword_max;  /*lsword*/
//       /*upload to ram 32-bit write flag and data length*/
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//      
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      msw_data = EFCHKSUM_MSW;
//      lsw_data = EFCHKSUM_LSW;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//
//       /*bgap/iref,fosc/vas5*/
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      msw_data = MAINBG_TRIMSAVED;
//      ArrayMultIntegerValue(msw_data,msw_data,0x100,v_sites);  /*lshift 8bit*/
//      ArrayAddInteger(msw_data,msw_data,MAINIREF_TRIMSAVED,v_sites);
//      lsw_data = FOSC_TRIMSAVED;
//      ArrayMultIntegerValue(lsw_data,lsw_data,0x100,v_sites);  /*lshift 8bit*/
//      ArrayAddInteger(lsw_data,lsw_data,VSA5CT_TRIMSAVED,v_sites);
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//
//       /*slopect/reserved*/
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      lsw_data = 0x00ff;
//      msw_data = VHV_SLPCT_TRIMSAVED;
//      ArrayMultIntegerValue(msw_data,msw_data,0x100,v_sites);  /*lshift 8bit*/
//      ArrayAddInteger(msw_data,msw_data,lsw_data,v_sites);
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//   } 
//}   /* MBox_Upload_EFChkSum_Pump_Trim */
//
//void MBox_Upload_FlwByte(IntS flwbyte_option)
//{
//   const IntS WR_FLWB_MP2_DRL = 1; 
//   const IntS WR_FLWB_MP2 = 2; 
//   const IntS WR_FLWB_MP3_DRL = 3; 
//   const IntS WR_FLWB_MP3 = 4; 
//   const IntS WR_FLWB_PREBI_DRL = 5; 
//   const IntS WR_FLWB_PREBI = 6; 
//   const IntS WR_FLWB_PSTBI = 7; 
//   const IntS WR_FLWB_FT2_TNI = 8; 
//   const IntS WR_FLWB_FT2 = 9; 
//
//   IntS site,length;
//   IntS wr_flag_num;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   IntS addr_loc,tmp_value;
//   IntM final_flowbyte;
//   IntS negatebit;
//   BoolS bcd_format,hexvalue;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ MBox_Upload_FlwByte +++++" << endl;
//
//      bcd_format  = true;
//      hexvalue    = true;
//      wr_flag_num = 0x1234;
//      numword_max = 1;
//
//      switch(flwbyte_option) {
//        case WR_FLWB_MP2_DRL   : negatebit = 0xFEFF;
//        case WR_FLWB_MP2       : negatebit = 0xFEFD;
//        case WR_FLWB_MP3_DRL   : negatebit = 0xFF7F;
//        case WR_FLWB_MP3       :  
//           if(GL_DO_TNI_CODE)  
//              negatebit = 0xFD7B;
//           else
//              negatebit = 0xFF7B;
//         break; 
//        case WR_FLWB_PREBI_DRL : negatebit = 0xFBFF;
//        case WR_FLWB_PREBI     : negatebit = 0xFBEF;
//        case WR_FLWB_PSTBI     : negatebit = 0xFFDF;
//        case WR_FLWB_FT2_TNI   :  
//           if(GL_DO_TNI_CODE)  
//              negatebit = 0xDFFF;
//           else
//              negatebit = 0xFFFF;
//         break; 
//        case WR_FLWB_FT2       :  
//           if(GL_DO_TNI_CODE)  
//              negatebit = 0x5FBF;
//           else
//              negatebit = 0x7FBF;
//         break; 
//        default:  
//           negatebit = 0xFFFF;
//           if(tistdscreenprint)  
//        case Invalid flwbyte_option entered !!!" :  cout << "*** WARNING;) 
//         break; 
//      }   /* case */
//      
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//            final_flowbyte[site] = FRM_OTP_FLWBYTE_VALUE[site]&negatebit;
//      
//      addr_loc = ADDR_RAM_MAILBOX;
//       /*upload write flag (msw) and data length (lsw)*/
//      msw_data = wr_flag_num;  /*msword*/
//      lsw_data = numword_max;  /*lsword*/
//       /*upload to ram 32-bit write flag and data length*/
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//         
//       /*flowbyte (msw/lsw)*/
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      msw_data = final_flowbyte;
//      lsw_data = final_flowbyte;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//   } 
//} 
//
//void MBox_Upload_LPO_CAL()
//{
//   IntS site,length;
//   IntS wr_flag_num;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   IntS addr_loc,tmp_value;
//   StringS this_wfrid;
//   IntM xpos,ypos,final_flowbyte;
//   IntS asichi_bcdnum,asiclo_bcdnum;
//   IntS lothi_bcdnum,lotlo_bcdnum;
//   IntS wfr_bcdnum,flowbyte_bcdnum;
//   string[16] dummy_bcd;
//   BoolS bcd_format,hexvalue;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ MBox_Upload_LPO_CAL +++++" << endl;
//
//      bcd_format  = true;
//      hexvalue    = true;
//      wr_flag_num = 0x1234;
//      numword_max = 1;
//      addr_loc = ADDR_RAM_MAILBOX;
//       /*upload write flag (msw) and data length (lsw)*/
//      msw_data = wr_flag_num;  /*msword*/
//      lsw_data = numword_max;  /*lsword*/
//       /*upload to ram 32-bit write flag and data length*/
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//         
//      addr_loc = addr_loc+ADDR_RAM_INC;
//      msw_data = LPO_TRIMSAVED;
//      lsw_data = LPO_TRIMSAVED;
//      WriteRamContentDec_32Bit(addr_loc,lsw_data,hexvalue,
//                               msw_data,hexvalue,bcd_format);
//   } 
//}   /* MBox_Upload_LPO_CAL */
//
//BoolS F021_Write_OTP_MBox_func(    StringS tname,
//                                      IntS wr_option,
//                                      BoolM test_results)
//{
//   const IntS WR_FLWB_MP2_DRL = 1; 
//   const IntS WR_FLWB_MP2 = 2; 
//   const IntS WR_FLWB_MP3_DRL = 3; 
//   const IntS WR_FLWB_MP3 = 4; 
//   const IntS WR_FLWB_PREBI_DRL = 5; 
//   const IntS WR_FLWB_PREBI = 6; 
//   const IntS WR_FLWB_PSTBI = 7; 
//   const IntS WR_FLWB_FT2_TNI = 8; 
//   const IntS WR_FLWB_FT2 = 9; 
//   const IntS WR_PGMREV_OPT = 10; 
//   const IntS WR_DIEID_OPT = 11; 
//   const IntS WR_PKGMEM_OPT = 12; 
//   const IntS WR_EFCHKSUM_OPT = 13; 
//   const IntS WR_LPO_CAL_OPT = 14; 
//   const IntS WR_OTP_CHKSUM_OPT = 20; 
//
//   IntS bankcount,site,length,count;
//   IntS wr_flag_num,start_tnum,testnum;
//   IntS numword,numword_max;
//   IntM msw_data,lsw_data;
//   FloatM tt_timer;
//   FloatS maxtime,ttimer1,ttimer2;
//   BoolM final_results,tmp_results;
//   BoolM logsites,savesites;
//   StringM temp_bcd;
//   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
//   IntS addr_loc,tmp_value;
//   StringS this_wfrid;
//   IntM xpos,ypos,final_flowbyte;
//   IntS asichi_bcdnum,asiclo_bcdnum;
//   IntS lothi_bcdnum,lotlo_bcdnum;
//   IntS wfr_bcdnum,flowbyte_bcdnum;
//   string[16] dummy_bcd;
//   BoolS bcd_format,hexvalue;
//   StringS fl_testname;
//   StringM site_cof_inst_str;
//   BoolS faildetect;
//   FloatM FloatSval;
//   TWunit unitval;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ F021_Write_OTP_MBox_func +++++" << endl;
//
//      switch(wr_option) {
//        case WR_PGMREV_OPT :  
//           switch(TITestType) {
//             case case MP1         : start_tnum = TNUM_OTP_WR_PGMREV_MBOX+(1<<23);
//             case case MP2         : start_tnum = TNUM_OTP_WR_PGMREV_MBOX+(1<<22);
//             case case MP3         : start_tnum = TNUM_OTP_WR_PGMREV_MBOX+(1<<21);
//             case case PreBurnIn   : start_tnum = TNUM_OTP_WR_PGMREV_MBOX+(1<<19);
//             case case PostBurnIn1 : start_tnum = TNUM_OTP_WR_PGMREV_MBOX+(1<<18);
//             case case FT2         : start_tnum = TNUM_OTP_WR_PGMREV_MBOX+(1<<17);
//            break;   /* case */
//        } 
//        WR_DIEID_OPT      : start_tnum = TNUM_OTP_WR_DIEID_FBYTE_MP1_MBOX;
//        WR_PKGMEM_OPT     : start_tnum = TNUM_OTP_WR_PKG_MEMSIZE_MBOX;
//        WR_EFCHKSUM_OPT   : start_tnum = TNUM_OTP_PROG_EFCHKSUM_PUMP_TRIM;
//        WR_LPO_CAL_OPT    : start_tnum = TNUM_OTP_PROG_LPO_CAL;
//        WR_OTP_CHKSUM_OPT : start_tnum = TNUM_OTP_PROG_CHKSUM_CBITS;
//
//         /*WR_FLWBYTE_MP2_DRL..WR_FLWB_FT2*/
//        otherwise           start_tnum = TNUM_OTP_WR_FLWBYTE_MBOX;
//      }   /* case */
//      
//        
//      maxtime = GL_F021_MAXTIME;
//
//      wr_flag_num = 0x1234;
//      bcd_format = true;
//      hexvalue   = true;
//      
//      fl_testname = tname;
//      writestring(tmpstr1,tname);
//      length = len(tmpstr1);
//      writestring(tmpstr1,mid(tmpstr1,2,length-6));  /*remove _Test*/
//      
//      timernstart(ttimer1);
//
//      TestOpen(fl_testname);
//
//      PrintHeaderBool(GL_PLELL_FORMAT);
//
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//
//      savesites = V_dev_active;
//      final_results = v_dev_active;
//
//      for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//      {
//         timernstart(ttimer2);
//         faildetect = false;
//
//         switch(wr_option) {
//           case WR_PGMREV_OPT     : MBox_Upload_PgmRev;
//           case WR_DIEID_OPT      : MBox_Upload_DieID;
//           case WR_PKGMEM_OPT     : MBox_Upload_PkgMem;
//           case WR_EFCHKSUM_OPT   : MBox_Upload_EFChkSum_Pump_Trim;
//           case WR_LPO_CAL_OPT    : MBox_Upload_LPO_CAL;
//           case WR_OTP_CHKSUM_OPT :  
//              ;  /*do nothing*/
//            break; 
//
//           default:  
//              MBox_Upload_FlwByte(wr_option);
//            break; 
//         }   /* case */
//           
//         testnum = start_tnum+(bankcount<<4);
//         
//         logsites = v_dev_active;
//         tmp_results = v_dev_active;
//         F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results);
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//
//         ttimer2 = timernread(ttimer2);
//         tt_timer = ttimer2;
//
//         writestring(tmpstr2,bankcount:1);
//         tmpstr2 = "_B" + tmpstr2;  /*_B#*/
//         tmpstr3 = tmpstr1 + tmpstr2;
//         tmpstr4 = tmpstr3 + "_TT";
//
//         TWTRealToRealMS(tt_timer,realval,unitval);
//         TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//               
//         if(tistdscreenprint)  
//            PrintResultBool(tmpstr3,testnum,tmp_results,GL_PLELL_FORMAT);
//               
//         if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//         {
//            faildetect = true;
//            F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
//            
//            if(TI_FlashCOFEna)  
//               F021_Update_COF_Inst_Str(tmpstr2,site_cof_inst_str,tmp_results);
//         } 
//         
//         if(faildetect)  
//            if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//               DevSetHoldStates(final_results);
//
//         if(not v_any_dev_active)  
//            break;
//      }   /*for bankcount*/
//
//      Devsetholdstates(savesites);
//
//      ResultsRecordActive(final_results, S_NULL);
//      TestClose;
//
//      test_results = final_results;
//
//      if(TI_FlashCOFEna)  
//         F021_Save_COF_Info(tmpstr1,site_cof_inst_str,final_results);
//      
//      ttimer1 = timernread(ttimer1);
//      tt_timer = ttimer1;
//
//      tmpstr4 = tmpstr1 + "_TTT";
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//         DevSetHoldStates(final_results);
//
//   }   /*if v_any_dev_active*/
//
//   F021_Write_OTP_MBox_func = v_any_dev_active;
//} 
//
//
//BoolS F021_OTP_WrEngRow_func(    BoolM test_results)
//{
//   const IntS TESTTYPE_OTPDATA = 0x7; 
//   const IntS TESTTYPE_FLWBITS = 0x9; 
//   const IntS WR_FLWB_MP2_DRL = 1; 
//   const IntS WR_FLWB_MP2 = 2; 
//   const IntS WR_FLWB_MP3_DRL = 3; 
//   const IntS WR_FLWB_MP3 = 4; 
//   const IntS WR_FLWB_PREBI_DRL = 5; 
//   const IntS WR_FLWB_PREBI = 6; 
//   const IntS WR_FLWB_PSTBI = 7; 
//   const IntS WR_FLWB_FT2_TNI = 8; 
//   const IntS WR_FLWB_FT2 = 9; 
//   const IntS WR_PGMREV_OPT = 10; 
//   const IntS WR_DIEID_OPT = 11; 
//   const IntS WR_PKGMEM_OPT = 12; 
//   const IntS WR_EFCHKSUM_OPT = 13; 
//   const IntS WR_LPO_CAL_OPT = 14; 
//   const IntS WR_OTP_CHKSUM_OPT = 20; 
//
//   FloatS tdelay;
//   BoolM savesites,logsites;
//   BoolM tmp_results,final_results;
//   IntS bankcount,site,opertype,pattype;
//   FloatS ttimer1,ttimer2;
//   FloatM tt_timer;
//   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
//   StringS tmpstr5;
//   IntS testnum,length;
//   FloatM FloatSval;
//   TWunit unitval;
//   StringS fl_testname;
//   FloatS maxtime;
//   StringM site_cof_inst_str;
//   IntS testtype_bits;
//   IntS wr_option;
//   IntM msw_data,lsw_data;
//   BoolM activesites,cofsites;
//
//   if(V_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ F021_OTP_WrEngRow_func +++++" << endl;
//
//      timernstart(ttimer1);      
//
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//
//      savesites = V_dev_active;
//      final_results = V_dev_active;
//      tmp_results = V_dev_active;
//
//       /*write pgm revision*/
//      wr_option = WR_PGMREV_OPT;
//      fl_testname = OTP_WrPgmRev_Test;
//      F021_Write_OTP_MBox_func(fl_testname,wr_option,tmp_results);
//      Arrayandboolean(final_results,final_results,tmp_results,v_sites);
//
//       /*write efuse chksum & pump trim*/
//      if((TITestType==MP1) and v_any_dev_active)  
//      {
//         wr_option = WR_EFCHKSUM_OPT;
//         fl_testname = OTP_WrEFChkSum_Test;
//         CalcChksum_FlashEfuse_func(SaveFlashProgString,lsw_data,msw_data);
//         F021_Write_OTP_MBox_func(fl_testname,wr_option,tmp_results);
//         Arrayandboolean(final_results,final_results,tmp_results,v_sites);
//      } 
//
//       /*write lpo cal*/
//      if(GL_DO_LPO_TRIM  and v_any_dev_active)  
//      {
//         wr_option = WR_LPO_CAL_OPT;
//         fl_testname = OTP_WrLPOCal_Test;
//         F021_Write_OTP_MBox_func(fl_testname,wr_option,tmp_results);
//         Arrayandboolean(final_results,final_results,tmp_results,v_sites);
//      } 
//      
//       /*write VT*/
//      if(v_any_dev_active)  
//      {
//         switch(TITestType) {
//           case wr_option = 1  :  MP1 ;
//           case wr_option = 2  :  MP2 ;
//           case wr_option = 3  :  MP3 ;
//           default: wr_option = 0;
//         }   /* case */
//
//         if(wr_option!=0)  
//         {
//            fl_testname = OTP_WrVT_Test;
//            if(GL_DO_DRL0_USING_VT and (not GL_DO_DRL1_USING_VT))  
//               F021_WriteVT0BCC1OTP_func(fl_testname,wr_option,tmp_results)
//                /*discard(F021_WriteVTOTP_func(fl_testname,wr_option,tmp_results))*/
//            else
//               F021_WriteBCCOTP_func(fl_testname,wr_option,tmp_results);
//            Arrayandboolean(final_results,final_results,tmp_results,v_sites);
//         } 
//      } 
//
//       /*write pkg/memsize*/
//      if(v_any_dev_active and ((TITestType==PreBurnIn) or ((TITestType==MP3) and (not GL_MP3PKG_FLOW))))  
//      {
//         fl_testname = OTP_WrPkgMem_Test;
//         wr_option   = WR_PKGMEM_OPT;
//         F021_Write_OTP_MBox_func(fl_testname,wr_option,tmp_results);
//         Arrayandboolean(final_results,final_results,tmp_results,v_sites);
//      } 
//
//       /*write flowbyte*/
//      if(v_any_dev_active)  
//      {
//         fl_testname = OTP_WrFlowByte_Test;
//         switch(TITestType) {
//           case wr_option = WR_DIEID_OPT  :  MP1 ;
//           case wr_option = WR_FLWB_MP2  :  MP2 ;
//           case wr_option = WR_FLWB_MP3  :  MP3 ;
//           case wr_option = WR_FLWB_PREBI  :  PreBurnIn ;
//           case wr_option = WR_FLWB_PSTBI  :  PostBurnIn1 ;
//           case wr_option = WR_FLWB_FT2  :  FT2 ;
//           default:  
//              wr_option = 0;
//              if(tistdscreenprint)  
//           case Invalid flow byte option for " << fl_testname :  cout << "*** WARNING;) 
//            break; 
//         }   /* case */
//
//         if(TI_FlashCOFEna)  
//         {
//             /*write flowbyte for good site only*/
//            activesites = v_dev_active;
//            cofsites = v_dev_active;
//
//             /*determine if any site failed previously.*/
//             /*if so, GL_F021_COF_PASS[site]=false, it was init true @beginning.*/
//             /*GL_FLASH_SAVESITES=v_dev_active @ beginning of flash flow*/
//            logsites = true;
//
//            if(not ArrayCompareBoolean(logsites,GL_F021_COF_PASS,v_sites))  
//            {
//                /*disable all sites & then enable individual site to bin out*/
//               logsites = false;
//               devsetholdstates(logsites);
//               
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               {
//                  if(GL_FLASH_SAVESITES[site] and
//                     (not GL_F021_COF_PASS[site]) and activesites[site])  
//                  {
//                     devsetholdstate(site,true);
//                     final_results[site] = false;
//                     activesites[site] = false;
//                     TestOpen(GL_F021_COF_1STFAILTEST[site]);
//                     ResultsRecordActive(activesites, S_NULL);
//                     TestClose;
//                     devsetholdstate(site,false);
//                     if(tistdscreenprint)  
//                        cout << "Site " << site:2 << " Re-BinOut 1st " << 
//                                "Failed Test " << GL_F021_COF_1STFAILTEST[site] << 
//                                " DISABLED !!!" << endl;
//                  }   /*if*/
//               }   /*for*/
//
//                /*re-enable sites for tw log*/
//               devsetholdstates(cofsites);
//               F021_Send_COF_Info_To_TW;
//               
//                /*disable failed sites so won"t allow to go through flowbyte write*/
//               devsetholdstates(activesites);
//            }   /*if not arraycompare*/
//         }   /*if ti_flashcofena*/
//         
//         if(wr_option>0)  
//         {
//            F021_Write_OTP_MBox_func(fl_testname,wr_option,tmp_results);
//            Arrayandboolean(final_results,final_results,tmp_results,v_sites);
//         } 
//      }   /*if write flowbyte*/
//
//       /*write otp chksum*/
//      if(v_any_dev_active)  
//      {
//         fl_testname = OTP_WrChksum_Test;
//         wr_option   = WR_OTP_CHKSUM_OPT;
//         F021_Write_OTP_MBox_func(fl_testname,wr_option,tmp_results);
//         Arrayandboolean(final_results,final_results,tmp_results,v_sites);
//      } 
//      
//   }   /*if V_any_dev_active*/
//
//   test_results = final_results;
//   
//   ttimer1 = timernread(ttimer1);
//   tt_timer = ttimer1;
//   
//   tmpstr4 = "OTP_WrEngRow_TTT";
//   TWTRealToRealMS(tt_timer,realval,unitval);
//   TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//
//   F021_OTP_WrEngRow_func = v_any_dev_active;
//} 
//         
//      
//BoolS GetShellInfo_func()
//{
//   IntS testnum,site,loop,addr;
//   IntM shellrev;
//   FloatS maxtime;
//   FloatM tt_timer;
//   BoolM final_results,logsites;
//   StringS fl_testname;
//   IntS fdlen1,fdlen2,fdlen3;
//   StringS str1,str2,str3,str4;
//   StringS1D labelarr(6);
//   StringM site_cof_inst_str;
//
//   if(v_any_dev_active)  
//   {
//       /*get shell revision info*/
//      maxtime = 1s;
//      shellrev = 0;
//      testnum = TNUM_SHELL_INFO;
//      final_results = v_dev_active;
//      logsites = v_dev_active;
//      
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//
//      fl_testname = ShellInfo_Test;
//      writestring(str1,fl_testname);
//
//      TestOpen(fl_testname);
//      
//      F021_RunTestNumber(testnum,maxtime,tt_timer,final_results);
//
//      addr = ADDR_RAM_SHELLREV;
//      GetRamContentDec_16bit(ramread_nburst_msw,addr,shellrev);
//      GL_SHELL_LIBREV = shellrev;
//       /*TestAPI rev*/
//      GetRamContentDec_16bit(ramread_nburst_lsw,addr,shellrev);
//      GL_SHELL_TAPIREV = shellrev;
//       /*FlashAPI rev*/
//      addr = (ADDR_RAM_SHELLREV+4);
//      GetRamContentDec_16bit(ramread_nburst_msw,addr,shellrev);
//      GL_SHELL_FAPIREV = shellrev;
//       /*Config rev*/
//      GetRamContentDec_16bit(ramread_nburst_lsw,addr,shellrev);
//      GL_SHELL_CONFIGREV = shellrev;
//       /*Support files rev*/
//      addr = (ADDR_RAM_SHELLREV+8);
//      GetRamContentDec_16bit(ramread_nburst_msw,addr,shellrev);
//      GL_SHELL_SUPPORTREV = shellrev;
//      
//      ResultsRecordActive(final_results, S_NULL);
//      TestClose;
//      
//      if(not ArrayCompareBoolean(logsites,final_results,v_sites))  
//      {
//         F021_Log_FailPat_To_TW(str1,final_results,fl_testname);
//
//         if(TI_FlashCOFEna)  
//         {
//            F021_Update_COF_Inst_Str(str1,site_cof_inst_str,final_results);
//            F021_Save_COF_Info("",site_cof_inst_str,final_results);
//         } 
//      } 
//
//      if(tistdscreenprint)  
//      {
//         fdlen1 = 30;
//         fdlen2 = 12;
//         fdlen3 = 12;
//         str3 = " ";
//         str4 = "     --     ";  /*12*/
//         labelarr[0] = "SHELL_LIBREV";
//         labelarr[1] = "SHELL_TAPIREV";
//         labelarr[2] = "SHELL_FAPIREV";
//         labelarr[3] = "SHELL_CONFIGREV";
//         labelarr[4] = "SHELL_SUPPORTREV";
//         labelarr[5] = "STDLIB_REV";
//         PrintHeaderBool(GL_PLELL_FORMAT);
//         for (loop = 0;loop <= 5;loop++)
//         {
//            cout << labelarr[loop]:-fdlen1 << str3 << testnum:s_hex:fdlen2 << str3 << str4 << str3 << str4 << str3;
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            {
//               if(v_dev_active[site])  
//               {
//                  switch(loop) {
//                    case 0 : cout << GL_SHELL_LIBREV[site]:s_hex:fdlen3 << str3;
//                    case 1 : cout << GL_SHELL_TAPIREV[site]:s_hex:fdlen3 << str3;
//                    case 2 : cout << GL_SHELL_FAPIREV[site]:s_hex:fdlen3 << str3;
//                    case 3 : cout << GL_SHELL_CONFIGREV[site]:s_hex:fdlen3 << str3;
//                    case 4 : cout << GL_SHELL_SUPPORTREV[site]:s_hex:fdlen3 << str3;
//                    case 5 : cout << GL_VLC_LIBREV:fdlen3 << str3;
//                  }   /* case */
//               }
//               else
//                  cout << "X":fdlen3 << str3;
//            } 
//            cout << endl;
//         }   /*for loop*/
//         PrintResultBool(str1,testnum,final_results,GL_PLELL_FORMAT);
//         cout << endl;
//      }   /*tistdscreenprint*/
//      
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//         Devsetholdstates(final_results);
//   } 
//   
//   GetShellInfo_func = v_any_dev_active;
//}   /* GetShellInfo_func */
//
//
//BoolS F021_FlowCheck_func(    BoolM test_results)
//{
//   IntS site,count;
//   BoolM tmp_results,final_results;
//   BoolM logsites,savesites;
//   StringS expflwbyte1,expflwbyte2,expflwbyte3;
//   StringS actflwbyte;
//   IntS1D actflwbit(16);
//   IntS tmpint;
//   FloatS ttimer1,ttimer2;
//   FloatM tt_timer;
//   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
//   StringS tmpstr5;
//   FloatM FloatSval;
//   TWunit unitval;
//   StringS fl_testname;
//   StringM site_cof_inst_str;
//
//   if(v_any_dev_active)  
//   {
//      timernstart(ttimer1);
//      
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//
//      savesites = V_dev_active;
//      logsites = V_dev_active;
//      tmp_results = V_dev_active;
//      final_results = V_dev_active;
//      GL_FLASH_RETEST = false;
//      GL_FLASH_RETEST_GEC = false;
//
//      fl_testname = FlowCheck_Test;      
//      TestOpen(fl_testname);
//
//      F021_ReadOTPInfo_func(final_results);
//      
//       /*Bit Definition        */
//       /*15              RSV   */
//       /*14              RSV   */
//       /*13  FT3 TNI     EXE   */
//       /*12              BIR   } {use this bit for ft2 vlct*/
//       /*11  MP1 Repair  REP   */
//       /*10  FT1 DRL     FUNC3 */
//       /*9   MP3 TNI     FUNC2 */
//       /*8   MP2 DRL     FUNC1 */
//       /*7   MP3 DRL     DRL   */
//       /*6               FT3   */
//       /*5               FT2   } {use this for post-burnin fusion*/
//       /*4               FT1   */
//       /*3               MP4   */
//       /*2               MP3   */
//       /*1               MP2   */
//       /*0               MP1   */
//
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//      {
//         if(v_dev_active[site])  
//         {
//            actflwbyte = FRM_OTP_FLWBYTE_BCD[site];
//            readstring("0x" + actflwbyte) + tmpint;   /*convert to int/hex*/
//            for (count = 0;count <= 15;count++)
//               actflwbit[count] = (tmpint&((0x1)<<count))>>count;  /*extract bit*/
//
//            switch(TITestType) {
//              case MP1 :  
//                       toupper(actflwbyte);
//                       if((actflwbyte==GL_MP1_FLWBYTE) or
//                          (actflwbyte==GL_MP1REP_FLWBYTE))  
//                          tmp_results[site] = true
//                       else
//                          tmp_results[site] = false;
//                     break;   /*mp1*/
//              
//              case MP2 :  
//                        /*check bits that must have correct value*/
//                       if((actflwbit[0]==0) and
//                          (actflwbit[2]==1) and (actflwbit[3]==1) and
//                          (actflwbit[4]==1) and (actflwbit[5]==1) and
//                          (actflwbit[6]==1) and (actflwbit[7]==1) and
//                          (actflwbit[9]==1) and
//                          (actflwbit[10]==1) and
//                          (actflwbit[12]==1) and (actflwbit[13]==1) and
//                          (actflwbit[14]==1) and (actflwbit[15]==1))  
//                        
//                           /*check bit1,8 for re-test. if bit1=0 then must bit8=0*/
//                          if((actflwbit[8]==0) and (actflwbit[1]==0))  
//                           
//                             GL_FLASH_RETEST[site] = true;
//                             GL_FLASH_RETEST_GEC[site] = true;
//                             tmp_results[site] = true;
//                           
//                          else if((actflwbit[8]==0) and (actflwbit[1]==1))  
//                           
//                             GL_FLASH_RETEST[site] = true;
//                             tmp_results[site] = true;
//                           
//                          else if((actflwbit[8]==1) and (actflwbit[1]==0))  
//                           
//                             tmp_results[site] = false;
//                             if(tistdscreenprint)  
//              case cout << "***WARNING: FLWBIT 8 MP2DRL NOT AS EXPECTED ***" << endl;
//                           break; 
//                        
//                       else
//                        
//                          tmp_results[site] = false;
//                        break; 
//                     break;   /*mp2*/
//                          
//              case MP3 :  
//                        /*check bits that must have correct value*/
//                       if((actflwbit[0]==0) and 
//                          (actflwbit[3]==1) and
//                          (actflwbit[4]==1) and (actflwbit[5]==1) and
//                          (actflwbit[6]==1) and 
//                          (actflwbit[10]==1) and
//                          (actflwbit[12]==1) and (actflwbit[13]==1) and
//                          (actflwbit[14]==1) and (actflwbit[15]==1))  
//                       {
//                           /*check mp2 bits*/
//                          if(GL_SKIP_MP2_FLASHFLOW)  
//                          {
//                             if((actflwbit[1]!=1) or (actflwbit[8]!=1))  
//                                tmp_results[site] = false;
//                          }
//                          else
//                          {
//                             if((actflwbit[1]!=0) or (actflwbit[8]!=0))  
//                                tmp_results[site] = false;
//                          } 
//                          
//                           /*check bit2,7 for re-test. if bit2=0 then must bit7=0*/
//                           /*then bit9 for mp3tni*/
//                          if((actflwbit[7]==0) and (actflwbit[2]==0))  
//                          {
//                             GL_FLASH_RETEST[site] = true;
//                             GL_FLASH_RETEST_GEC[site] = true;
//                             tmp_results[site] = true;
//                          }
//                          else if((actflwbit[7]==0) and (actflwbit[2]==1))  
//                          {
//                             GL_FLASH_RETEST[site] = true;
//                             tmp_results[site] = true;
//                          }
//                          else if((actflwbit[7]==1) and (actflwbit[2]==0))  
//                          {
//                             tmp_results[site] = false;
//                             if(tistdscreenprint)  
//                                cout << "***WARNING: FLWBIT 7 MP3DRL NOT AS EXPECTED ***" << endl;
//                          } 
//                          
//                          if((actflwbit[9]==0) and (actflwbit[2]==0))  
//                          {
//                             if(GL_DO_TNI_CODE)  
//                                tmp_results[site] = true;
//                             else
//                                tmp_results[site] = false;
//                          }
//                          else if((actflwbit[9]==0) and (actflwbit[2]==1))  
//                          {
//                             tmp_results[site] = false;
//                             if(tistdscreenprint)  
//                                cout << "***WARNING: FLWBIT 9 MP3TNI NOT AS EXPECTED ***" << endl;
//                          }
//                          else if((actflwbit[9]==1) and (actflwbit[2]==0))  
//                          {
//                             if(GL_DO_TNI_CODE)  
//                             {
//                                tmp_results[site] = false;
//                                if(tistdscreenprint)  
//                                   cout << "***WARNING: FLWBIT 9 MP3TNI NOT AS EXPECTED ***" << endl;
//                             } 
//                          } 
//                       }
//                       else
//                       {
//                          tmp_results[site] = false;
//                       } 
//                    }   /*mp3*/
//              
//              PreBurnIn : {
//                        /*check bits that must have correct value*/
//                       if((actflwbit[0]==0) and
//                          (actflwbit[2]==0) and (actflwbit[3]==1) and
//                          (actflwbit[5]==1) and
//                          (actflwbit[6]==1) and (actflwbit[7]==0) and
//                          (actflwbit[12]==1) and (actflwbit[13]==1) and
//                          (actflwbit[14]==1) and (actflwbit[15]==1))  
//                       {
//                           /*check MP2 bits*/
//                          if(GL_SKIP_MP2_FLASHFLOW)  
//                          {
//                             if((actflwbit[1]!=1) or (actflwbit[8]!=1))  
//                                tmp_results[site] = false;
//                          }
//                          else
//                          {
//                             if((actflwbit[1]!=0) or (actflwbit[8]!=0))  
//                                tmp_results[site] = false;
//                          } 
//                          
//                           /*check bit4,10 for re-test. if bit4=0, then bit10=0*/
//                           /*then bit9 for mp3tni*/
//
//                          if((actflwbit[10]==0) and (actflwbit[4]==0))  
//                          {
//                             GL_FLASH_RETEST[site] = true;
//                             GL_FLASH_RETEST_GEC[site] = true;
//                             tmp_results[site] = true;
//                          }
//                          else if((actflwbit[10]==0) and (actflwbit[4]==1))  
//                          {
//                             GL_FLASH_RETEST[site] = true;
//                             tmp_results[site] = true;
//                          }
//                          else if((actflwbit[10]==1) and (actflwbit[4]==0))  
//                          {
//                             tmp_results[site] = false;
//                             if(tistdscreenprint)  
//                                cout << "***WARNING: FLWBIT 10 FT1DRL NOT AS EXPECTED ***" << endl;
//                          } 
//
//                          if(GL_DO_TNI_CODE)  
//                          {
//                             if(actflwbit[9]==1)  
//                             {
//                                tmp_results[site] = false;
//                                if(tistdscreenprint)  
//                                   cout << "***WARNING: FLWBIT 9 MP3TNI NOT AS EXPECTED ***" << endl;
//                             } 
//                          }
//                          else
//                          {
//                             if(actflwbit[9]==0)  
//                             {
//                                tmp_results[site] = false;
//                                if(tistdscreenprint)  
//                                   cout << "***WARNING: FLWBIT 9 MP3TNI NOT AS EXPECTED ***" << endl;
//                             } 
//                          } 
//                       }
//                       else
//                       {
//                          tmp_results[site] = false;
//                       } 
//                    }   /*ft1*/
//                          
//              PostBurnIn1 : {
//                        /*check bits that must have correct value*/
//                       if((actflwbit[0]==0) and 
//                          (actflwbit[2]==0) and (actflwbit[3]==1) and
//                          (actflwbit[4]==0) and (actflwbit[5]==1) and
//                          (actflwbit[6]==1) and 
//                          (actflwbit[7]==0) and
//                          (actflwbit[10]==0) and (actflwbit[13]==1) and
//                          (actflwbit[14]==1) and (actflwbit[15]==1))  
//                       {
//                          tmp_results[site] = true;
//                           /*check MP2 bits*/
//                          if(GL_SKIP_MP2_FLASHFLOW)  
//                          {
//                             if((actflwbit[1]!=1) or (actflwbit[8]!=1))  
//                                tmp_results[site] = false;
//                          }
//                          else
//                          {
//                             if((actflwbit[1]!=0) or (actflwbit[8]!=0))  
//                                tmp_results[site] = false;
//                          } 
//                          
//                           /*check bit12=0*/
//                          if(actflwbit[12]==0)  
//                          {
//                             GL_FLASH_RETEST_GEC[site] = true;
//                             GL_FLASH_RETEST[site] = true;
//                          } 
//
//                          if(GL_DO_TNI_CODE)  
//                          {
//                             if(actflwbit[9]==1)  
//                             {
//                                tmp_results[site] = false;
//                                if(tistdscreenprint)  
//                                   cout << "***WARNING: FLWBIT 9 MP3TNI NOT AS EXPECTED ***" << endl;
//                             } 
//                          }
//                          else
//                          {
//                             if(actflwbit[9]==0)  
//                             {
//                                tmp_results[site] = false;
//                                if(tistdscreenprint)  
//                                   cout << "***WARNING: FLWBIT 9 MP3TNI NOT AS EXPECTED ***" << endl;
//                             } 
//                          } 
//                       }
//                       else
//                       {
//                          tmp_results[site] = false;
//                       } 
//                    }   /*ft2*/
//
//              FT2 : {
//                        /*check bits that must have correct value*/
//                       if((actflwbit[0]==0) and 
//                          (actflwbit[2]==0) and (actflwbit[3]==1) and
//                          (actflwbit[4]==0) and (actflwbit[5]==0) and
//                          (actflwbit[7]==0) and
//                          (actflwbit[10]==0) and 
//                          (actflwbit[12]==0) and 
//                          (actflwbit[14]==1))  
//                       {
//                          tmp_results[site] = true;
//                          
//                           /*check mp2 bits*/
//                          if(GL_SKIP_MP2_FLASHFLOW)  
//                          {
//                             if((actflwbit[1]!=1) or (actflwbit[8]!=1))  
//                                tmp_results[site] = false;
//                          }
//                          else
//                          {
//                             if((actflwbit[1]!=0) or (actflwbit[8]!=0))  
//                                tmp_results[site] = false;
//                          } 
//                          
//                          if(GL_DO_TNI_CODE)  
//                          {
//                             if(actflwbit[9]==1)  
//                             {
//                                tmp_results[site] = false;
//                                if(tistdscreenprint)  
//                                   cout << "***WARNING: FLWBIT 9 MP3TNI NOT AS EXPECTED ***" << endl;
//                             } 
//                          }
//                          else
//                          {
//                             if(actflwbit[9]==0)  
//                             {
//                                tmp_results[site] = false;
//                                if(tistdscreenprint)  
//                                   cout << "***WARNING: FLWBIT 9 MP3TNI NOT AS EXPECTED ***" << endl;
//                             } 
//                          } 
//                          
//                           /*check bit6=0, if so then must be bit13=0*/
//                          if(GL_DO_TNI_CODE)  
//                          {
//                             if(actflwbit[13]==0)  
//                                GL_FLASH_RETEST[site] = true;
//                             
//                             if((actflwbit[6]==0) and (actflwbit[13]==0) and (actflwbit[15]==0))  
//                             {
//                                GL_FLASH_RETEST_GEC[site] = true;
//                             }
//                             else if((actflwbit[6]==0) and (actflwbit[13]==1))  
//                             {
//                                tmp_results[site] = false;
//                                if(tistdscreenprint)  
//                                   cout << "***WARNING: FLWBIT 13 FT3TNI NOT AS EXPECTED ***" << endl;
//                             } 
//                          }
//                          else
//                          {
//                             if((actflwbit[6]==0) and (actflwbit[13]==1) and (actflwbit[15]==0))  
//                             {
//                                GL_FLASH_RETEST[site] = true;
//                                GL_FLASH_RETEST_GEC[site] = true;
//                             }
//                             else if((actflwbit[6]==0) and (actflwbit[13]==0))  
//                             {
//                                tmp_results[site] = false;
//                                if(tistdscreenprint)  
//                                   cout << "***WARNING: FLWBIT 13 FT3TNI NOT AS EXPECTED ***" << endl;
//                             } 
//                          } 
//                       }
//                       else
//                       {
//                          tmp_results[site] = false;
//                       } 
//                    }   /*ft3*/
//
//              otherwise
//                    {
//                       tmp_results[site] = false;
//                       if(tistdscreenprint)  
//                          cout << "***WARNING: INVALID TITestType ***" << endl;
//                    } 
//            }   /*case*/
//
//                          
//             /*check to see if repaired: bit11*/
//            if(actflwbit[11]==0)  
//            {
//               tmpstr1 = "FL_REPAIRED_UNIT";
//               TWPDLDatalogTextSite("OTP_FLWBIT11",tmpstr1,site,TWMinimumData);
//               if(tistdscreenprint)  
//                  cout << "Site " << site:2 << " Flash Repaired" << endl;
//            } 
//
//            if(TIStdScreenPrint and GL_FLASH_RETEST[site])  
//               cout << "Site " << site:4 << " FLASH RETEST ENABLE " << endl;
//            
//         }   /*if v_dev_active*/
//      }   /*for site*/
//
//      devsetholdstates(savesites);
//   
//      ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//      test_results = final_results;
//
//      ResultsRecordActive(final_results, S_NULL);
//      TestClose;
//
//      tmpstr3 = "OTP_FlowCheck";
//      if(not ArrayCompareBoolean(logsites,final_results,v_sites))  
//      {
//         F021_Log_FailPat_To_TW(tmpstr3,final_results,fl_testname);
//
//         if(TI_FlashCOFEna)  
//         {
//            F021_Update_COF_Inst_Str(tmpstr3,site_cof_inst_str,final_results);
//            F021_Save_COF_Info("",site_cof_inst_str,final_results);
//         } 
//      } 
//      
//      ttimer1 = timernread(ttimer1);
//      tt_timer = ttimer1;
//
//      tmpstr4 = tmpstr3 + "_TTT";
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//
//      if(tistdscreenprint)  
//      {
//         PrintHeaderBool(GL_PLELL_FORMAT);
//         PrintResultBool(tmpstr3,0,final_results,GL_PLELL_FORMAT);
//         cout << "   TT " << ttimer1 << endl;
//         cout << endl;
//      }   /*if tistdscreenprint*/
//
//       /*log initial otp info to tw*/
//      F021_Log_OTP_To_TW;
//      
//      if(not TIIgnoreFail)  
//         Devsetholdstates(final_results);
//      
//   }   /*v_any_dev_active*/
//
//   F021_FlowCheck_func = v_any_dev_active;
//} 
//   
//
 /*init global var BAK_EFSTR,MAIN_EFSTR*/
void F021_InitFLEfuseStr()
{
   IntS maxbank;
   StringM tmpstr1,hdpstr;
   BoolS debugprint;

    /*build individual string from LSB-MSB*/
    /*bank str*/
   tmpstr1 = "00000000000000000000000000000000";

    /*HDPUMP -- efuse bit vbgsten=0, vbgtrim[5]=1, vbgtrim[0]=6, vosc[5]=8, vosc[0]=13*/
    /*ireftrim[4]=15, ireftrim[0]=19, ireftrim[5]=21, vhvslopect[3]=22, vhvslopect[0]=25*/
    /*vsa5ct[3]=26, vsa5ct[0]=29*/
   hdpstr = "000000000000000000000000000000";

   debugprint = false;
   if(tistdscreenprint and debugprint)  
      cout << "INIT FLASH EFUSE STRING LSB-MSB : MAIN/BANK" << endl;
      
   BANK_EFSTR = "";
    /*lsb-msb*/
   for (maxbank = 0;maxbank <= F021_Flash.MAXBANK;++maxbank)
      BANK_EFSTR = BANK_EFSTR + tmpstr1;

    /*--- HDPUMP ---*/
   MAINBG_EFSTR = hdpstr;
   
   if(tistdscreenprint and debugprint)  
   {
      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
      {
         cout << "Site : " << *si << endl;
         cout << BANK_EFSTR[*si] << endl;
         cout << MAINBG_EFSTR[*si] << endl;
      } 
   }
}   /* F021_InitFLEfuseStr */

void SaveMbgEfuseTrimString(IntS trimValue, SITE whichSite)
{
   StringS soft_str;
   IntS t_str_length;
   StringS error_message;
   
   soft_str = IntToBinStr(trimValue, GL_MAINBG_MAXEFUSE, true);
   t_str_length = soft_str.Length();
   
   if(t_str_length > GL_MAINBG_MAXEFUSE)  
   {
      IO.Print(error_message, "ERROR: BG Trim Solution Efuse Bits exceed %d. PROGRAM ISSUE -- NEED TO CONTACT LBE !!!", 
               GL_MAINBG_MAXEFUSE);      
      ERR.ReportError(ERR_GENERIC_CRITICAL, error_message, t_str_length, whichSite, UTL_VOID);
   } 

   int bg_index = 1;   /*bgap5*/  //this was 2...but thinking Pascal does 1-based string positions
   
   for (int count = 0;count < GL_MAINBG_MAXEFUSE;count++)
   {
      MAINBG_EFSTR[whichSite][bg_index] = soft_str[count];  /*bg0 1st,bg5 last*/
      ++bg_index;
   } 
}   /* SaveMbgEfuseTrimString */

// PickBestIndex will find the array index with the value 
// closest to the target. It does this by offsetting the 
// trimCurve by the target. This should set the target area
// to 0. Then, doing an absolute value will produce a V-shape
// with the minimum value being the closest to the target.
IntM PickBestCode (FloatM1D trimCurve, FloatS target)
{
   trimCurve -= double(target); 
   trimCurve = MATH.Abs(trimCurve);
   FloatM1D extremes = MATH.Xtrm(trimCurve);
   return (IntM(extremes[3]));
}

 /*meas and trim bgap w/o using vrd override*/
TMResultM F021_MainBG_SoftTrim_Direct_func(BoolS charTrimEna)
{
   const IntS MIN_CODE = 0;
   const IntS MAX_CODE = 63;
   const IntS MAXITER = 64; 
   
   IntM trim_alarms = 0; // used to test if the trim worked
   Sites pretrim_pass_sites, trim_sites;
   FloatS tdelay;
   IntS testnum; 
   Sites savesites = ActiveSites;
   TMResultM tmp_results,final_results;
   FloatS ttimer1, maxtime;
   StringS fl_testname, twstr;
   FloatS target_meas_value,target_meas_delta;
   FloatM novride_meas_value;
   PinM testpad;
   FloatM delta_value;
   IntS tcrnum;
   TPModeType tcrmode;
   FloatS llim,ulim;
   IntS TRIMENAKEY;
   IntM TrimValue,BGValue,IRValue,FOSCValue;
   bool any_site_active = true;
   

   if(tistdscreenprint)  
      cout << "+++++ F021_MainBG_SoftTrim_Direct +++++" << endl;

   maxtime = GL_F021_PARAM_MAXTIME;

   TIME.StartTimer();     

// :TODO: Come back and add this later, for now, leave off
//   if(TI_FlashCOFEna)  
//      F021_Init_COF_Inst_Str(site_cof_inst_str);

   tmp_results = TM_NOTEST;
   final_results = TM_NOTEST;
   TrimValue = 0;

   /*+++++ STEP #1 +++++*/
   /*get non-override measurement and store in meas_value*/

   RAM_Clear_SoftTrim_All();

   fl_testname = "MainBG_PreTrim_Test";
   
   tcrnum  = 124;
   tcrmode = ProgMode;  /*to select relax limit, actual is readmode*/
   testnum = TNUM_PUMP_MAINBG;
   testpad = FLTP2; 
   ulim    = TCR.TP2_ULim[tcrnum][tcrmode];
   llim    = TCR.TP2_LLim[tcrnum][tcrmode];
   tdelay = 10ms;

   F021_TurnOff_AllTPADS();
//   novride_meas_value = DoVIMeasure(testpad, tcrnum, tcrmode, testnum, maxtime, tdelay);
   
   /*Test and TW log for non-override meas_value*/
   final_results = TIDlog.Value(novride_meas_value, testpad, llim, ulim, novride_meas_value.GetUnits(),
                                "MBG_PRETRIM", UTL_VOID, UTL_VOID, true, TWMinimumData);
   
// :TODO: come back and fix this fail logging
//   logsites = v_dev_active;      
//   if(not ArrayCompareBoolean(logsites,final_results,v_sites))  
//   {
//      F021_Log_FailPat_To_TW(tmpstr4,final_results,fl_testname);
//      
//      if(TI_FlashCOFEna)  
//      {
//         tmpstr4 = "_" + tmpstr4;
//         F021_Update_COF_Inst_Str(tmpstr4,site_cof_inst_str,final_results);
//      } 
//   } 
   
   if((not RunAllTests) and (not TI_FlashCOFEna))   // RunAllTests was tiignorefail...is this the way we want to handle it?
   {
      pretrim_pass_sites = ActiveSites;
      pretrim_pass_sites.DisableFailingSites(final_results.Equal(TM_PASS));
      any_site_active = SetActiveSites(pretrim_pass_sites);
   }
   
    /*+++++ STEP #2 +++++*/
   if(any_site_active)  
   {
      trim_sites = ActiveSites;
      BoolM softtrim_ena;
      softtrim_ena = true;
      
       /*calculate target delta*/
      target_meas_value = MainBG_Target;
      
       /*set trim delta limit. Use this limit to determine site to trimmed.*/
       /*this limit is tighter than BG_tolerance limit.*/
      target_meas_delta = BG_Adapt_Delta_AbsLim;

      fl_testname = "MainBG_Trim_Test";
      
       /*compare non-override value vs target*/
      delta_value = target_meas_value - novride_meas_value;
      
       /*+++ Calc delta +++*/
      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
      {
         if(MATH.Abs(delta_value[*si]) <= target_meas_delta)  
         {
            MAINBG_TRIMSAVED[*si] = TrimValue[*si];
            trim_sites -= *si; // this site found its trim, so remove it
            softtrim_ena[*si] = false;
         } 
         
         if(tistdscreenprint)  
         {
            cout << "Site" << *si << 
               "  Target :" << target_meas_value << 
               "  Measured (NOVRD) : " << novride_meas_value[*si] << 
               "  Target Delta : " << target_meas_delta << 
               "  Delta : " << delta_value[*si] << endl;
            if(softtrim_ena[*si])  
               cout << "   ENABLE SOFTTRIM  " << endl;
            else
               cout << "   NO NEED SOFTTRIM " << endl;
         } 
      }  
      /*+++ end Calc delta +++*/

       /*+++++ STEP #3 +++++*/
      // disable sites that don't need to trim
      if(SetActiveSites(trim_sites))  
      {
         TRIMENAKEY = 0xAA55;
         IRValue = 0;
         FOSCValue = 0;
         
         if (charTrimEna) // run every code so we can see what the curve looks like
         {
            FloatM1D trim_curve(MAX_CODE+1, 0.);
            for (int code=MIN_CODE; code <= MAX_CODE; ++code)
            {
               BGValue = code;
               RAM_Upload_SoftTrim(TRIMENAKEY, BGValue, IRValue, FOSCValue, FOSCValue, FOSCValue);
//               trim_curve.SetValue(code, DoVIMeasure(testpad, tcrnum, tcrmode, testnum, maxtime, tdelay));
               TIDlog.Value(trim_curve[code], testpad, UTL_VOID, UTL_VOID, trim_curve[code].GetUnits(), 
                            "MainBG_Trim_Curve_Code_" + IntS(code), UTL_VOID, UTL_VOID, false, TWMinimumData);
            }
            IntM best_code;
            best_code = PickBestCode(trim_curve, target_meas_value);
            MAINBG_TRIMSAVED = best_code;
            TrimValue = best_code;
            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
               SaveMbgEfuseTrimString(TrimValue[*si], *si); 
         } else // not charTrimEna
         {
            // The BG trim looks to use a 2s-complement number coding. This means a 
            // linear ramp in terms of output is not a linear ramp numerically. So, we'll
            // use a linear look-up table to make the search code much less complicated.
            int num_codes = MAX_CODE - MIN_CODE +1;
            IntS1D lookup_table(num_codes, 0);
            
            int i;
            int j = 0;
            // first section is the 'negative' numbers from half scale and up
            for (i = num_codes/2; i <= MAX_CODE; ++i, ++j)
               lookup_table[j] = i;
            // now go back and get 0 to half scale
            for (i = 0; i < num_codes/2; ++i, ++j);
               lookup_table[j] = i;

            SearchMod my_search;
            my_search.SASearchBegin(double(MIN_CODE), double(MAX_CODE), target_meas_delta, target_meas_value, MAXITER);
            my_search.SkipMinMax(true);            
            
            IntS loop = 0;
            FloatM meas_value;
            FloatM table_index;
            while (my_search.searchNotDone)
            {
               table_index = my_search.xForceValueMS;
               // The xForceValueMS is based upon a line from 0-63, so it is basically
               // just an index in our lookup_table. We have 
               // to look that up in the lookup table since the actual code isn't
               // linear since it is 2s complement
               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
                  BGValue[*si] = lookup_table[MATH.LegacyRound(table_index[*si])];
                  
               RAM_Upload_SoftTrim(TRIMENAKEY,BGValue,IRValue,FOSCValue,FOSCValue,FOSCValue);
//               meas_value = DoVIMeasure(testpad, tcrnum, tcrmode, testnum, maxtime, tdelay);
      
               loop = loop+1;
               twstr = "MBG_SOFT_" + loop;
               TIDlog.Value(BGValue, testpad, MIN_CODE, MAX_CODE, UTL_VOID, twstr + "CODE",
                            UTL_VOID, UTL_VOID, false, TWMinimumData); // debug only, really, so no TW
               TIDlog.Value(meas_value, testpad, llim, ulim, meas_value.GetUnits(),
                            twstr, UTL_VOID, UTL_VOID, true, TWMinimumData);
               
               my_search.SearchNext(meas_value);
            }
            
            trim_alarms = my_search.m_searchAlarmMS;
            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
            {
               if (trim_alarms[*si] == SearchMod::TARGET_FOUND)
               {
                  // we trimmed properly, save the value 
                  // remember that the actual trim code lives in the lookup_table and the 
                  // xForceValueMS is just the index
                  MAINBG_TRIMSAVED[*si] = lookup_table[MATH.LegacyRound(my_search.xForceValueMS[*si])];
                  TrimValue[*si] = MAINBG_TRIMSAVED[*si];
                  SaveMbgEfuseTrimString(TrimValue[*si], *si); 
                  
                  // The VLCT conditions for SITE_TO_FTRIM of true were:
                  // soft_found - this is covered by the trim alarms above
                  // softtrim_ena - this was covered by deactivating sites above 
                  //             (if you get here, softtrim_ena would have been true in the VLCT program)
                  // final_results - It had to have passed the pre-trim...which we deactivated failing sites above
                  SITE_TO_FTRIM[*si] = true;
               }
            }        
            // test if we found a real trim or we had search errors
            tmp_results = TIDlog.Value(trim_alarms, testpad, 0, 0, "",
                         "MAINBG_TRIMCODE_FOUND", UTL_VOID, UTL_VOID, true, TWMinimumData);
         
            final_results = DLOG.AccumulateResults(final_results, tmp_results);
         } // end else charTrimEna
         // I moved this test here. It was in the BuildEfuseString routine, but it made
         // more sense to do it at the end for all trimmed sites
         TIDlog.Value(TrimValue, testpad, MIN_CODE, MAX_CODE, UTL_VOID, "MBG_SOL", 
                     UTL_VOID, UTL_VOID, true, TWMinimumData);
                     
         if(tistdscreenprint)
         {
            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
               cout << "Site " << *si << "Final Soft Efuse Pump String : " << MAINBG_EFSTR[*si] << endl;
         }
         
         // Trim clean up
         RAM_Clear_SoftTrim_All();
         FloatM ret_timer;
         F021_RunTestNumber(TNUM_ALWAYS_PASS,1s,ret_timer);
      } // end trim for those sites that needed it      
   }  // if we have active sites that passed pre-trim
     
   // Need to reactivate sites that we started test with for final logging   
   RunTime.SetActiveSites(savesites);
   ttimer1 = TIME.StopTimer();
   
   TIDlog.Value(ttimer1, UTL_VOID, 0., UTL_VOID, "ms", "MainBG_Trim_TTT", 
                 UTL_VOID, UTL_VOID, true, TWMinimumData);
   
// :TODO: Come back and add this.
//   logsites = v_dev_active;      
//   if(not ArrayCompareBoolean(logsites,final_results,v_sites))  
//   {
//      F021_Log_FailPat_To_TW(tmpstr1,final_results,fl_testname);
//      if(TI_FlashCOFEna)  
//         F021_Save_COF_Info("",site_cof_inst_str,final_results);
//   }      

   return (final_results);
} 

//BoolS F021_MainBG_SoftTrim_func(    BoolS adapttrim_ena,
//                                       BoolS chartrim_ena,
//                                  BoolM test_results)
//{
//   const IntS TRIMMAXITER = 10; 
//
//   FloatS tdelay,tdelay2;
//   IntS site,testnum,count;
//   BoolM savesites,activesites,logsites;
//   BoolM tmp_results,final_results,alldisable;
//   FloatS ttimer1,ttimer2,maxtime;
//   FloatM tt_timer;
//   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
//   FloatM FloatSval;
//   TWunit unitval;
//   StringS fl_testname;
//   FloatM target_meas_value,target_meas_delta;
//   FloatM target_abs_delta;
//   FloatM novride_meas_value,ovride_meas_value;
//   FloatM tmp_meas_value;
//   PinM testpad,cntrlpad;
//   FloatM delta_value,tmp_delta;
//   FloatM1D vbg_meas_value(65);
//   FloatM1D vbg_meas_delta(65);
//   IntS bg_efmax,soft_index,bg_index;
//   StringS1D interim_soft_str(65);
//   BoolM soft_found,softtrim_ena;
//   IntM soft_iteration;
//   IntS index,iteration;
//   BoolM trimup,trimdown;
//   BoolS trimup_only,chartrim,chardebug;
//   BoolS savebool;
//   FloatS delta_tolerance;
//   StringS soft_str,patlabel;
//   IntM1D adapt_iteration(65);
//   StringM1D adapt_soft_str(65);
//   BoolM adapt_trimup,adapt_trimdown;
//   FloatM derived_vbg;
//   StringM site_cof_inst_str;
//   IntS tcrnum;
//   TPModeType tcrmode;
//   FloatS llim,ulim;
//   IntS minloop,maxloop,midloop,loop,tmpint,i;
//   IntS MAXITERATION,TRIMENAKEY;
//   IntM TrimValue,BGValue,IRValue,FOSCValue;
//
//   if(V_any_dev_active)  
//   {
//      if(tistdscreenprint)  
//         cout << "+++++ F021_MainBG_SoftTrim +++++" << endl;
//
//      tdelay = 5ms;
//      maxtime = GL_F021_MAXTIME;
//      bg_efmax = GL_MAINBG_MAXEFUSE;
//      patlabel = "MAIN_VBG";
//      chardebug = false;  /*set if want to measure VBG for debug only*/
//
//      timernstart(ttimer1);      
//
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//
//      tmp_results = V_dev_active;
//      final_results = V_dev_active;
//      trimup = false;
//      trimdown = false;
//      soft_found = false;
//      softtrim_ena = false;
//
//       /*+++++ STEP #4 +++++*/
//       /*get non-override measurement and store in meas_value*/
//      if(v_any_dev_active)  
//      {
//         fl_testname = MainBG_VRD_Novride_Test;      
//         TestOpen(fl_testname);
//         
//         tcrnum  = 117;
//         tcrmode = ProgMode;  /*to select relax limit, actual is readmode*/
//         testnum = TNUM_PUMP_VREAD;
//         testpad = FLTP1;
//         ulim    = TCR.TP1_ULim[tcrnum][tcrmode];
//         llim    = TCR.TP1_LLim[tcrnum][tcrmode];
//         tdelay2 = 10ms;
//         
//#if $TP3_TO_TP5_PRESENT  
//          /*disable tp3 during trim*/
//         savebool = TCR.TP3_Ena[tcrnum];
//         TCR.TP3_Ena[tcrnum] = false;
//#endif         
//         F021_Set_TPADS(tcrnum,tcrmode);
//         F021_RunTestNumber_PMEX(testnum,maxtime,tmp_results);
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//         TIME.Wait(tdelay2);
//         discard(F021_Meas_TPAD_PMEX(testpad,tcrnum,tcrmode,
//                 llim,ulim,novride_meas_value,tmp_results));
//          /*bin out site not passing relaxed limits*/
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//         
//         ResultsRecordActive(final_results, S_NULL);
//         TestClose;
//         
//         Disable(s_pmexit);
//         F021_TurnOff_AllTPads;
//
//#if $TP3_TO_TP5_PRESENT  
//          /*restore tp3*/
//         TCR.TP3_Ena[tcrnum] = savebool;
//#endif         
//          /*TW log for non-override meas_value*/
//         tmpstr4 = "MBG_VRD_NOOVERRIDE";
//         TWTRealToRealMS(novride_meas_value,realval,unitval);
//         TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//         
//         if(tistdscreenprint)  
//         {
//            PrintHeaderParam(GL_PLELL_FORMAT);
//            PrintResultParam(tmpstr4,testnum,tmp_results,llim,ulim,novride_meas_value,GL_PLELL_FORMAT);
//         } 
//         
//         logsites = v_dev_active;      
//         if(not ArrayCompareBoolean(logsites,final_results,v_sites))  
//         {
//            F021_Log_FailPat_To_TW(tmpstr4,final_results,fl_testname);
//            
//            if(TI_FlashCOFEna)  
//            {
//               tmpstr4 = "_" + tmpstr4;
//               F021_Update_COF_Inst_Str(tmpstr4,site_cof_inst_str,final_results);
//            } 
//         } 
//         
//         if((not tiignorefail) and (not TI_FlashCOFEna))  
//            Devsetholdstates(final_results);
//      }   /*if v_any_dev_active step#4*/
//
//
//       /*+++++ STEP #1-3 +++++*/
//      if(v_any_dev_active)  
//      {
//         fl_testname = MainBG_VRD_Target_Test;      
//         TestOpen(fl_testname);
//         
//         tcrnum  = 97;
//         tcrmode = ReadMode;
//         testnum = TNUM_MAINBG_FORCE_MEASVRD0;
//         testpad = FLTP1;
//         ulim    = TCR.TP1_ULim[tcrnum][tcrmode];
//         llim    = TCR.TP1_LLim[tcrnum][tcrmode];
//         tdelay2 = 10ms;
//         
//          /*get virgin measurement and store in target_meas_value*/
//         F021_TurnOff_AllTpads;
//         TIME.Wait(tdelay);
//         F021_RunTestNumber_PMEX(testnum,maxtime,tmp_results);
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//         TIME.Wait(tdelay);
//         F021_Set_TPADS(tcrnum,tcrmode);
//         TIME.Wait(tdelay2);
//         discard(F021_Meas_TPAD_PMEX(testpad,tcrnum,tcrmode,
//                 llim,ulim,target_meas_value,tmp_results));
//          /*bin out site not passing relaxed limits*/
//          /*ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);} {KChau 10/29/09 -- temp bypass*/
//         
//         ResultsRecordActive(final_results, S_NULL);
//         TestClose;
//         
//         Disable(s_pmexit);
//         F021_TurnOff_AllTPads;
//         
//          /*TW log for virgin target_meas_value*/
//         tmpstr4 = "MBG_VRD_TARGET";
//         TWTRealToRealMS(target_meas_value,realval,unitval);
//         TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//         
//         if(tistdscreenprint)  
//         {
//            PrintHeaderParam(GL_PLELL_FORMAT);
//            PrintResultParam(tmpstr4,testnum,tmp_results,llim,ulim,target_meas_value,GL_PLELL_FORMAT);
//         } 
//         
//         logsites = v_dev_active;      
//         if(not ArrayCompareBoolean(logsites,final_results,v_sites))  
//         {
//            F021_Log_FailPat_To_TW(tmpstr4,final_results,fl_testname);
//            
//            if(TI_FlashCOFEna)  
//            {
//               tmpstr4 = "_" + tmpstr4;
//               F021_Update_COF_Inst_Str(tmpstr4,site_cof_inst_str,final_results);
//            } 
//         } 
//         
//         if((not tiignorefail) and (not TI_FlashCOFEna))  
//            Devsetholdstates(final_results);
//
//      }   /*if v_any_dev_active*/
//         
//       /*calculate target delta*/
//      delta_tolerance = BG_tolerance;
//      ArrayMultTrealValue(target_abs_delta,target_meas_value,delta_tolerance,v_sites);
//
//       /*set trim delta limit. Use this limit to determine site to trimmed.*/
//       /*this limit is tighter than BG_tolerance limit.*/
//      target_meas_delta = BG_Adapt_Delta_AbsLim;
//
//      
//       /*+++++ STEP #5 +++++*/
//      if(v_any_dev_active)  
//      {
//         fl_testname = MainBG_Trim_Test;
//         TestOpen(fl_testname);
//         
//          /*compare non-override value vs target*/
//         savesites = V_dev_active;
//         softtrim_ena = V_dev_active;
//         delta_value = 99V;
//         
//         minloop = 1;
//         maxloop = 64;
//         midloop = round((minloop+maxloop)/2);
//         MAXITERATION = trunc(2**bg_efmax);
//         
//         for (loop = minloop;loop <= maxloop;loop++)
//            adapt_iteration[loop] = loop;
//
//          /*+++ Calc delta +++*/
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         {
//            if(v_dev_active[site])  
//            {
//               delta_value[site] = target_meas_value[site]-novride_meas_value[site];
//
//               if(abs(delta_value[site]) <== target_meas_delta[site])  
//               {
//                  soft_found[site] = true;
//                  softtrim_ena[site] = false;
//               } 
//               
//               if(softtrim_ena[site])  
//               {
//                  if(delta_value[site] < target_meas_delta[site])  
//                     trimdown[site] = true;
//                  else
//                     trimup[site] = true;
//               } 
//               
//               if(tistdscreenprint)  
//                  cout << "Site" << site:-5 << 
//                     "  Target :" << target_meas_value[site]:4:3 << 
//                     "  Measured (NonOVRD) : " << novride_meas_value[site]:4:3 << 
//                     "  Target Delta : " << target_meas_delta[site]:4:3 << 
//                     "  Delta : " << delta_value[site]:4:3 << endl;
//
//                /*formula for non-adaptive and adaptive discrete soft trim*/
//                /*derived_VBG = (1.21/novride_meas_value)*target_meas_value*/
//                /*trim down iteration = ((round((derived_VBG-1.161v)/0.003))+16)*/
//                /*trim up iteration = round(derived_VBG-1.209v)/0.003 */
//
//                /*+++ Calc trim solution +++*/
//               if(softtrim_ena[site])  
//               {
//          if(not chartrim_ena)  
//                  {
//                     if(trimdown[site])  
//                     {
//                        adapt_iteration[1][site] = round(((target_meas_value[site]-novride_meas_value[site])/MainBG_Adapt_Delta_ULim)+32);
//                     }
//                     else  /*trimup*/
//                     {
//                        adapt_iteration[1][site] = round((target_meas_value[site]-novride_meas_value[site])/MainBG_Adapt_Delta_ULim);
//                     }   /*if trimdown/trimup*/
//                     
//                     if(tistdscreenprint)  
//                        cout << "Site" << site:-5 << " Base Calc Trim Sol==" << adapt_iteration[1][site]:-5 << endl;
//                     
//                      /*-- checking if valid solution --*/
//                     if((adapt_iteration[1][site]>==0) and (adapt_iteration[1][site]<==MAXITERATION))  
//                     {
//                        if((adapt_iteration[1][site]==0) or (adapt_iteration[1][site]==64) or
//                           (adapt_iteration[1][site]==MAXITERATION))  
//                        {
//                           softtrim_ena[site] = false;
//                           soft_found[site]   = true;
//                        }
//                        else
//                        {
//                            /*populate +/- lsb increment based on minloop,maxloop*/
//                           tmpint = TRIMMAXITER div 2;
//                           if((trimup[site]) and ((adapt_iteration[1][site]>==16) and (adapt_iteration[1][site]<==31)))  
//                           {
//                              adapt_iteration[1][site] = 15;
//                              for (loop = 2;loop <= tmpint;loop++)
//                                 adapt_iteration[loop][site] = adapt_iteration[1][site]-(loop-1);
//                              
//                              adapt_iteration[tmpint+1][site] = 48;
//                              i = 1;
//                              for (loop = (tmpint+2);loop <= TRIMMAXITER;loop++)
//                              {
//                                 adapt_iteration[loop][site] = adapt_iteration[tmpint+1][site]+i;
//                                 i = i+1;
//                              } 
//                           }
//                           else
//                           {
//                              for (loop = 2;loop <= tmpint;loop++)
//                              {
//                                 adapt_iteration[loop][site] = adapt_iteration[1][site]+(loop-1);
//                                 if(adapt_iteration[loop][site]>==MAXITERATION)  
//                                    adapt_iteration[loop][site] = adapt_iteration[1][site];
//                              } 
//
//                              i = 1;
//                              for (loop = (tmpint+1);loop <= TRIMMAXITER;loop++)
//                              {
//                                 adapt_iteration[loop][site] = adapt_iteration[1][site]-i;
//                                 i = i+1;
//                                 if(adapt_iteration[loop][site]<0)  
//                                    adapt_iteration[loop][site] = adapt_iteration[1][site];
//                              } 
//                           } 
//                        } 
//                     }
//                     else
//                     {   /*--- Invalid trim solution, not trim-able ---*/
//                        softtrim_ena[site]  = false;
//                        soft_found[site]    = false;
//                        final_results[site] = false;
//                        if(tistdscreenprint)  
//                           cout << "Site " << site:-5 << " Invalid trim solution <<  not trim-able !!!" << endl;
//                     } 
//                  }
//                  else  /*chartrim_ena*/
//                  {
//                     if(tistdscreenprint)  
//                     {
//                        if(trimdown[site])  
//                           cout << "Site " << site:-5 << "Calculate Trim Solution == " << round(((target_meas_value[site]-novride_meas_value[site])/MainBG_Adapt_Delta_ULim)+32));
//                        else
//                           cout << "Site " << site:-5 << "Calculate Trim Solution == " << round(((target_meas_value[site]-novride_meas_value[site])/MainBG_Adapt_Delta_ULim)) << endl;
//                     } 
//                  } 
//               }   /*if softtrim_ena*/
//                /*+++ end Calc trim solution +++*/
//            }   /*if v_dev_active*/
//         }   /*for site*/
//          /*+++ end Calc delta +++*/
//
//         Devsetholdstates(softtrim_ena);
//
//          /*+++++ STEP #6 +++++*/
//         if(v_any_dev_active)  
//         {
//            activesites = V_dev_active;
//         
//             /*+++++++ NON-ADAPTIVE TRIM +++++++*/
//            if(false )   /*not adapttrim_ena*/
//            {
//               tmpstr4 = "MBG_VRD_SOL";
//               soft_iteration = adapt_iteration[1];
//               TWPDLDataLogVariable(tmpstr4,soft_iteration, TWMinimumData);
//            }
//            else
//            {
//                            /*+++++++ DISCRETE ADAPTIVE TRIM +++++++*/
//               if(tistdscreenprint)  
//                  cout << "STARTING ADAPTIVE DISCRETE TRIM ... " << endl;
//               
//               TRIMENAKEY = 0xAA55;
//               IRValue = 0;
//               FOSCValue = 0;
//               
//               tcrnum  = 117;
//               tcrmode = ProgMode;  /*to select relax limit, actual is readmode*/
//               testnum = TNUM_PUMP_VREAD;
//               testpad = FLTP1;
//               ulim    = TCR.TP1_ULim[tcrnum][tcrmode];
//               llim    = TCR.TP1_LLim[tcrnum][tcrmode];
//               
//#if $TP3_TO_TP5_PRESENT  
//                /*disable tp3 during trim*/
//               savebool = TCR.TP3_Ena[tcrnum];
//               TCR.TP3_Ena[tcrnum] = false;
//#endif
//               if(not chartrim_ena)  
//                  maxloop = TRIMMAXITER;
//               
//               for (loop = minloop;loop <= maxloop;loop++)
//               {
//                  BGValue = adapt_iteration[loop];
//                  RAM_Upload_SoftTrim(TRIMENAKEY,BGValue,IRValue,FOSCValue,FOSCValue,FOSCValue);
//                  F021_Set_TPADS(tcrnum,tcrmode);
//                  F021_RunTestNumber_PMEX(testnum,maxtime,tmp_results);
//                  TIME.Wait(tdelay2);
//                  discard(F021_Meas_TPAD_PMEX(testpad,tcrnum,tcrmode,
//                          llim,ulim,tmp_meas_value,tmp_results));
//                  Disable(s_pmexit);
//                  F021_TurnOff_AllTPads;
//          f021_runtestnumber(tnum_always_pass,2s,spare_mstreal1,spare_msbool1);
//                  
//                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  {
//                     if(v_dev_active[site])  
//                     {
//                        tmp_delta[site] = tmp_meas_value[site]-target_meas_value[site];
//                        if(loop==minloop)  
//                        {
//                           TrimValue[site]   = adapt_iteration[loop][site];
//                           delta_value[site] = tmp_delta[site];
//                        }
//                        else
//                        {
//                           if(abs(tmp_delta[site]) < abs(delta_value[site]))  
//                           {
//                               /*update and store iteration with smallest delta found*/
//                              TrimValue[site]   = adapt_iteration[loop][site];
//                              delta_value[site] = tmp_delta[site];
//                           } 
//                        } 
//
//            if(tistdscreenprint and TI_FlashDebug)  
//            {
//               cout << "Site " << site:-5 << " Loop==" << loop:-4 << " VRD soft==" << tmp_meas_value[site]:-5:3 << 
//                                   "  SoftTrim==" << adapt_iteration[loop][site]:-5 << "  tmp_delta==" << tmp_delta[site]:-5:3 << 
//                                   "  delta_value==" << delta_value[site]:-5:3 << "  TrimValue==" << TrimValue[site]:-5 << endl;
//            } 
//            
//                        if((abs(delta_value[site]) <== target_meas_delta[site]) or (loop==maxloop))  
//                        {
//                           soft_found[site] = true;
//               activesites[site] = false;
//               if(TrimValue[site]==64)  
//                  TrimValue[site] = 0;
//               MAINBG_TRIMSAVED[site] = TrimValue[site];
//                           writestring(soft_str,TrimValue[site]:s_binary:1);
//                           tmpint = len(soft_str);
//               soft_str = mid(soft_str,3,tmpint-2);
//                           tmpint = len(soft_str);
//                           
//                           if(tmpint>GL_MAINBG_MAXEFUSE)  
//                           {
//                              if(tistdscreenprint)  
//                              {
//                                 cout << "*** ERROR: BG Trim Solution Efuse Bits exceed " << GL_MAINBG_MAXEFUSE << endl;
//                                 cout << "*** PROGRAM ISSUE -- NEED CONTACT LBE !!!" << endl;
//                                 cout << "PROGRAM WILL ABORT NOW" << endl;
//                              } 
//                              cout << "*** ERROR: BG Trim Solution Efuse Bits exceed " << GL_MAINBG_MAXEFUSE << endl;
//                              cout << "*** PROGRAM ISSUE -- NEED CONTACT LBE !!!" << endl;
//                              cout << "PROGRAM WILL ABORT NOW" << endl;
//                              pause;
//                              stop;
//                           } 
//                           
//                           while((len(soft_str))<GL_MAINBG_MAXEFUSE) do
//                              soft_str = "0" + soft_str;   /*bg5=msb,bg0=lsb*/
//                           
//                           bg_index = 2;   /*bgap5*/
//                           
//                           tmpint = len(soft_str);
//                           
//                           for (count = 1;count <= tmpint;count++)
//                           {
//                              MAINBG_EFSTR[site][bg_index] = soft_str[count];  /*bg0 1st,bg5 last*/
//                              bg_index = bg_index+1;
//                           } 
//                           
//                           iteration = TrimValue[site];
//                           tmpstr4 = "MBG_VRD_SOL";
//                           TWPDLDatalogVariableSite(tmpstr4,iteration,site,TWMinimumData);
//                           
//                           if(tistdscreenprint)  
//                           {
//                              cout << "Site " << site:5 << "  Soft Iteration " << loop:-3 << 
//                                      " Target == " << target_meas_value[site]:-5:3 << 
//                                      " Measured == " << tmp_meas_value[site]:-5:3 << 
//                                      " Delta == " << delta_value[site]:-5:3 << 
//                                      " Soft Sol == " << TrimValue[site]:-5 << endl;
//                              cout << "  Final Soft Efuse Pump String : " << MAINBG_EFSTR[site] << endl;
//                           }   /*if tistdscreenprint*/
//                        }   /*if delta_value*/
//                        
//                     }   /*if v_dev_active*/
//                  }   /*for site*/
//
//                  writestring(tmpstr2,loop:1);
//                  tmpstr4 = "MBG_VRD_SOFT_" + tmpstr2;
//                  TWTRealToRealMS(tmp_meas_value,realval,unitval);
//                  TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//                  
//                   /*tmpstr4 := concat("MBG_VRD_SOFT_",tmpstr2);
//                   tmpstr4 := concat(tmpstr4,"_SOL");
//                   Arraycopyinteger(soft_iteration,adapt_iteration[loop],v_sites);
//                   TWPDLDatalogVariableMS(tmpstr4,soft_iteration, TWMinimumData);*/
//                  
//                   /*disable site found trim*/
//                  devsetholdstates(activesites);
//                  
//                  if(not v_any_dev_active)  
//                     break;
//                  
//               }   /*for loop*/
//
//#if $TP3_TO_TP5_PRESENT  
//                /*restore tp3*/
//               TCR.TP3_Ena[tcrnum] = savebool;
//#endif
//            }   /*+++++++ DISCRETE ADAPTIVE TRIM +++++++*/
//
//         }   /*if v_any_dev_active STEP #6*/
//         
//           /*re-activate savesites*/
//         Devsetholdstates(savesites);
//
//         Arrayandboolean(final_results,final_results,soft_found,v_sites);
//         Arrayandboolean(final_results,final_results,savesites,v_sites);
//         
//         ResultsRecordActive(final_results, S_NULL);
//         TestClose;
//         
//         
//          /*update site that is trimable, non-trimable, virgin*/
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//                /*good trimable site*/
//               if(softtrim_ena[site] and soft_found[site] and final_results[site])  
//                  SITE_TO_FTRIM[site] = true;
//                /*else
//                   SITE_TO_FTRIM[site] := false;*/
//            } 
//
//     RAM_Clear_SoftTrim_All;
//     f021_runtestnumber(tnum_always_pass,1s,spare_mstreal1,spare_msbool1);
//
//      }   /*+++++ STEP #5 +++++*/
//      
//      ttimer1 = timernread(ttimer1);
//      tt_timer = ttimer1;
//
//      tmpstr1 = "MainBG_Trim";
//      tmpstr4 = tmpstr1 + "_TTT";
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//      
//      logsites = v_dev_active;      
//      if(not ArrayCompareBoolean(logsites,final_results,v_sites))  
//      {
//         F021_Log_FailPat_To_TW(tmpstr1,final_results,fl_testname);
//         if(TI_FlashCOFEna)  
//            F021_Save_COF_Info("",site_cof_inst_str,final_results);
//      } 
//
//      if(tistdscreenprint)  
//      {
//         PrintHeaderBool(GL_PLELL_FORMAT);
//         PrintResultBool(tmpstr1,0,final_results,GL_PLELL_FORMAT);
//         cout << "   TT " << ttimer1 << endl;
//         cout << endl;
//      } 
//
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//         Devsetholdstates(final_results);         
//
//      test_results = final_results;
//
//   }   /*v_any_dev_active*/
//
//   F021_MainBG_SoftTrim_func = v_any_dev_active;
//} 

void SaveMirefEfuseTrimString(IntS trimValue, SITE whichSite)
{
   StringS soft_str;
   IntS t_str_length;
   StringS error_message;
   
   soft_str = IntToBinStr(trimValue, GL_MAINIREF_MAXEFUSE, true);
   t_str_length = soft_str.Length();
   
   if(t_str_length > GL_MAINIREF_MAXEFUSE)  
   {
      IO.Print(error_message, "ERROR: Main Iref Trim Solution Efuse Bits exceed %d. PROGRAM ISSUE -- NEED TO CONTACT LBE !!!", 
               GL_MAINIREF_MAXEFUSE);      
      ERR.ReportError(ERR_GENERIC_CRITICAL, error_message, t_str_length, whichSite, UTL_VOID);
   } 

   int iref_index = 15;   /*iref4*/  // was 16, but think pascal is 1-based strings, not 0
   
   for (int count = 1;count < GL_MAINIREF_MAXEFUSE;count++)
   {
      MAINBG_EFSTR[whichSite][iref_index] = soft_str[count];  /*iref4 1st*/
      ++iref_index;
   } 
   MAINBG_EFSTR[whichSite][21] = soft_str[0]; /*iref5*/
}   /* SaveMirefEfuseTrimString */

TMResultM F021_MainIREF_SoftTrim_func(BoolS charTrimEna)
{
   const IntS MIN_CODE = 0;
   const IntS MAX_CODE = 63;
   const IntS MAXITER = 64; 


   FloatS tdelay2;
   IntS testnum;
   Sites savesites = ActiveSites;
   Sites pass_pretrim_sites, trim_sites;
   TMResultM tmp_results,final_results;
   FloatS ttimer1,maxtime;
   StringS twstr;
   StringS fl_testname;
   FloatS target_meas_value,target_meas_delta;
   FloatM ovride_meas_value;
   FloatM ovride_meas_delta;
   PinM testpad;
   IntS tcrnum;
   TPModeType tcrmode;
   FloatS llim,ulim;
   IntS TRIMENAKEY;
   IntM TrimValue,BGValue,IRValue,FOSCValue;
   IntM trim_alarms;
   bool any_site_active = true;


   if(tistdscreenprint)  
      cout << "+++++ F021_MainIREF_SoftTrim +++++" << endl;

   maxtime = GL_F021_PARAM_MAXTIME;

   TIME.StartTimer();      

//   if(TI_FlashCOFEna)  
//      F021_Init_COF_Inst_Str(site_cof_inst_str);

   tmp_results = TM_NOTEST;
   final_results = TM_NOTEST;
   TrimValue = 0;


    /*+++++ STEP #1 +++++*/
   fl_testname = "MainIREF_Ovride_Test";

    /*get virgin measurement*/
   tcrnum  = 125;
   tcrmode = ProgMode;  /*to select relax limit, actual is readmode*/
   testnum = TNUM_MAINICMP10U_MEAS;
   testpad = FLTP1;
   ulim    = TCR.TP1_ULim[tcrnum][tcrmode];
   llim    = TCR.TP1_LLim[tcrnum][tcrmode];
   tdelay2 = 10ms;
   
   TRIMENAKEY = 0xAA55;
   BGValue = MAINBG_TRIMSAVED;
   FOSCValue = 0;
   IRValue = 0;
   
   RAM_Upload_SoftTrim(TRIMENAKEY,BGValue,IRValue,FOSCValue,FOSCValue,FOSCValue);
   F021_TurnOff_AllTPADS();
//   ovride_meas_value = DoVIMeasure(testpad, tcrnum, tcrmode, testnum, maxtime, tdelay2);
    /*bin out site not passing relaxed limits*/
   final_results = TIDlog.Value(ovride_meas_value, testpad, llim, ulim, ovride_meas_value.GetUnits(),
                                "MAINIREF_OVERRIDE", UTL_VOID, UTL_VOID, true, TWMinimumData);

// :TODO: Figure out something with this fail logging   
//   logsites = v_dev_active;      
//   if(not ArrayCompareBoolean(logsites,final_results,v_sites))  
//   {
//      F021_Log_FailPat_To_TW(tmpstr4,final_results,fl_testname);
//      
//      if(TI_FlashCOFEna)  
//      {
//         tmpstr4 = "_" + tmpstr4;
//         F021_Update_COF_Inst_Str(tmpstr4,site_cof_inst_str,final_results);
//      } 
//   } 
   
   if((not RunAllTests) and (not TI_FlashCOFEna)) 
   {
      pass_pretrim_sites = ActiveSites;
      pass_pretrim_sites.DisableFailingSites(final_results.Equal(TM_PASS));
      any_site_active = SetActiveSites(pass_pretrim_sites);
   }
   
    /*+++++ STEP #2 +++++*/
   if(any_site_active)  
   {
       /*compare override value vs target*/
      fl_testname = "MainIREF_Trim_Test";
      trim_sites = ActiveSites;
      
      target_meas_value = Main_Icmp10_Target;
      target_meas_delta = Iref_Adapt_Delta_AbsLim;
       /*calculate target delta*/
      BoolM softtrim_ena;
      softtrim_ena = true;
      
       /*+++ Calc delta +++*/
      ovride_meas_delta = target_meas_value - ovride_meas_value;
      
      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
      {
         if(MATH.Abs(ovride_meas_delta[*si])<=MATH.Abs(target_meas_delta))  
         {
            softtrim_ena[*si] = false;
            trim_sites -= *si;
            MAINIREF_TRIMSAVED[*si] = TrimValue[*si];
         } 
         
         if(tistdscreenprint)  
         {
            cout << "Site" << *si << 
               "  Target :" << target_meas_value << 
               "  Measured (OVRD) : " << ovride_meas_value[*si] << 
               "  Target Delta : " << target_meas_delta << 
               "  Delta : " << ovride_meas_delta[*si] << endl;
            if(softtrim_ena[*si])  
               cout << "   ENABLE SOFTTRIM  " << endl;
            else
               cout << "   NO NEED SOFTTRIM " << endl;
         } 
      }   /*for site*/
       /*+++ end Calc delta +++*/

       /*+++++ STEP #3 +++++*/
      if(SetActiveSites(trim_sites))  
      {
         if (charTrimEna) // run every code so we can see what the curve looks like
         {
            FloatM1D trim_curve(MAX_CODE+1, 0.);
            for (int code=MIN_CODE; code <= MAX_CODE; ++code)
            {
               IRValue = code;
               RAM_Upload_SoftTrim(TRIMENAKEY, BGValue, IRValue, FOSCValue, FOSCValue, FOSCValue);
//               trim_curve.SetValue(code, DoVIMeasure(testpad, tcrnum, tcrmode, testnum, maxtime, tdelay2));
               TIDlog.Value(trim_curve[code], testpad, UTL_VOID, UTL_VOID, trim_curve[code].GetUnits(), 
                            "MainIref_Trim_Curve_Code_" + IntS(code), UTL_VOID, UTL_VOID, false, TWMinimumData);
            }
            IntM best_code;
            best_code = PickBestCode(trim_curve, target_meas_value);
            MAINIREF_TRIMSAVED = best_code;
            TrimValue = best_code;
            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
               SaveMirefEfuseTrimString(TrimValue[*si], *si);
               
         } else // not charTrimEna
         {
            SearchMod my_search;
            my_search.SASearchBegin(double(MIN_CODE), double(MAX_CODE), target_meas_delta, target_meas_value, MAXITER);
            my_search.SkipMinMax(true);            
            
            IntS loop = 0;
            FloatM meas_value;
            FloatM float_code;
            
            while (my_search.searchNotDone)
            {
               float_code = my_search.xForceValueMS;
               IRValue = MATH.LegacyRound(float_code);
                  
               RAM_Upload_SoftTrim(TRIMENAKEY,BGValue,IRValue,FOSCValue,FOSCValue,FOSCValue);
//               meas_value = DoVIMeasure(testpad, tcrnum, tcrmode, testnum, maxtime, tdelay2);
      
               loop = loop+1;
               twstr = "MIREF_SOFT_" + loop;
               TIDlog.Value(BGValue, testpad, MIN_CODE, MAX_CODE, UTL_VOID, twstr + "CODE",
                            UTL_VOID, UTL_VOID, false, TWMinimumData); // debug only, really, so no TW
               TIDlog.Value(meas_value, testpad, llim, ulim, meas_value.GetUnits(),
                            twstr, UTL_VOID, UTL_VOID, true, TWMinimumData);
               
               my_search.SearchNext(meas_value);
            }

            trim_alarms = my_search.m_searchAlarmMS;
            IntS temp_int;
            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
            {
               if (trim_alarms[*si] == SearchMod::TARGET_FOUND)
               {
                  // we trimmed properly, save the value 
                  MAINIREF_TRIMSAVED[*si] = int(MATH.LegacyRound(my_search.xForceValueMS[*si]));
                  TrimValue[*si] = MAINIREF_TRIMSAVED[*si];
                  SaveMirefEfuseTrimString(TrimValue[*si], *si); 
                  
                  // The VLCT conditions for SITE_TO_FTRIM of true were:
                  // soft_found - this is covered by the trim alarms above
                  // softtrim_ena - this was covered by deactivating sites above 
                  //             (if you get here, softtrim_ena would have been true in the VLCT program)
                  // final_results - It had to have passed the pre-trim...which we deactivated failing sites above
                  SITE_TO_FTRIM[*si] = true;
               }
            }        
            // test if we found a real trim or we had search errors
            tmp_results = TIDlog.Value(trim_alarms, testpad, 0, 0, "",
                         "MAINIREF_TRIMCODE_FOUND", UTL_VOID, UTL_VOID, true, TWMinimumData);
         
            final_results = DLOG.AccumulateResults(final_results, tmp_results);
         } // end else charTrimEna
         TIDlog.Value(TrimValue, testpad, MIN_CODE, MAX_CODE, UTL_VOID, "MIREF_SOL", 
                     UTL_VOID, UTL_VOID, true, TWMinimumData);
         if (tistdscreenprint)
         {
            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
               cout << "Site " << *si << "Final Soft Efuse Pump String : " << MAINBG_EFSTR[*si] << endl;
         }
         
         // Trim clean up
         RAM_Clear_SoftTrim_All();
         FloatM ret_timer;
         F021_RunTestNumber(TNUM_ALWAYS_PASS,1s,ret_timer);
      } // end trim for those sites that needed it
   }   /*+++++ STEP #2 +++++*/
   
   RunTime.SetActiveSites(savesites);
   ttimer1 = TIME.StopTimer();

   twstr = "MainIREF_Trim_TTT";
   TIDlog.Value(ttimer1, UTL_VOID, 0., UTL_VOID, UTL_VOID, twstr,
                UTL_VOID, UTL_VOID, true, TWMinimumData);
   
// :TODO: This
//   logsites = v_dev_active;      
//   if(not ArrayCompareBoolean(logsites,final_results,v_sites))  
//   {
//      F021_Log_FailPat_To_TW(tmpstr1,final_results,fl_testname);
//      if(TI_FlashCOFEna)  
//      {
//         tmpstr1 = "_" + tmpstr1;
//         F021_Save_COF_Info(tmpstr1,site_cof_inst_str,final_results);
//      } 
//   } 

   return (final_results);
} 

//BoolS F021_FOSC_SoftTrim_func(    BoolM test_results)
//{
//   const IntS IND_FOSC = 9; 
//   const IntS FOSC_MAXEFUSE = 6; 
//
//   BoolM final_results,tmp_results;
//   BoolM savesites,activesites;
//   IntS testnum,site,addr,i;
//   StringS tname;
//   StringS current_shell,str1,str2,str3,str5;
//   FloatS tdelay,maxtime,ttimer1;
//   IntM trimsol,fvalhi,fvallo,freqval;
//   FloatM tt_timer;
//   FloatM FloatSval;
//   TWunit unitval;
//   IntM bgval,irval,foscval;
//   IntM slpct,vsa5ct;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ F021_FOSC_SoftTrim_func +++++" << endl;
//      
//      timernstart(ttimer1);
//
//      testnum = 0x10210000;  /*TNUM_PUMP_FOSC_AUTOTRIM*/
//      maxtime = GL_F021_BANK_MAXTIME;
//
//      bgval = MAINBG_TRIMSAVED;
//      irval = MAINIREF_TRIMSAVED;
//      slpct = VHV_SLPCT_TRIMSAVED;
//      vsa5ct = VSA5CT_TRIMSAVED;
//      foscval = 0;
//      RAM_Upload_SoftTrim(0xAA55,bgval,irval,foscval,slpct,vsa5ct);
//
//       /*RAM_Clear_SoftTrim_All;*/
//      ClockStopFreeRun(s_clock1a);
//      TIME.Wait(2ms);
//      F021_RunTestNumber(testnum,maxtime,spare_mstreal1,final_results);
//
//      Get_TLogSpace_TRIMSOL(trimsol);
//      Get_TLogSpace_MeasFreq(fvalhi,fvallo);
//      
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            freqval[site] = (fvalhi[site]<<16) + fvallo[site];   /*in khz*/
//            if(GL_DO_FOSC_TRIM)  
//            {
//               if(trimsol[site] != 0)  
//                  SITE_TO_FTRIM[site] = true;
//               FOSC_TRIMSAVED[site] = trimsol[site];
//               writestring(str5,trimsol[site]:s_binary:1);
//               str5 = mid(str5,3,(len(str5))-2);
//               
//               if((len(str5)) > FOSC_MAXEFUSE)  
//               {
//                  if(tistdscreenprint)  
//                  {
//                     cout << "*** ERROR: FOSC Trim Solution Efuse Bits exceed " << FOSC_MAXEFUSE << endl;
//                     cout << "*** PROGRAM ISSUE -- NEED CONTACT LBE !!!" << endl;
//                     cout << "PROGRAM WILL ABORT NOW" << endl;
//                  }
//                  else
//                  {
//                     cout << "*** ERROR: FOSC Trim Solution Efuse Bits exceed " << FOSC_MAXEFUSE << endl;
//                     cout << "*** PROGRAM ISSUE -- NEED CONTACT LBE !!!" << endl;
//                     cout << "PROGRAM WILL ABORT NOW" << endl;
//                  } 
//                  pause;
//                  stop;
//               } 
//               
//               while((len(str5)) < FOSC_MAXEFUSE) do
//                  str5 = "0" + str5;
//               
//               for (i = 1;i <= FOSC_MAXEFUSE;i++)
//                  MAINBG_EFSTR[site][IND_FOSC+(i-1)] = str5[i];  /*ef_vosctrm[5] 1st*/
//               
//               if(tistdscreenprint)  
//                  cout << "  Final Soft Efuse Pump String : " << MAINBG_EFSTR[site] << endl;
//            } 
//            
//            if(tistdscreenprint and TI_FlashDebug)  
//               readramaddress(site,0,0xff);
//         } 
//
//      ttimer1 = timernread(ttimer1);
//      tt_timer = ttimer1;
//
//      str1 = "FOSC_TRIM_TT";
//      str2 = "FOSC_TRIM_SOL";
//      str3 = "FOSC_TRIM_FREQ";
//
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(str1, unitval,realval,TWMinimumData);
//      TWPDLDataLogVariable(str2,trimsol, TWMinimumData);
//      TWPDLDataLogVariable(str3,freqval, TWMinimumData);
//      
//      if(tistdscreenprint)  
//      {
//         PrintHeaderBool(GL_PLELL_FORMAT);
//         PrintResultInt(str2,testnum,trimsol,0,0,GL_PLELL_FORMAT);
//         PrintResultInt(str3,testnum,freqval,0,0,GL_PLELL_FORMAT);
//         cout << "   TT " << ttimer1 << endl;
//         cout << endl;
//      } 
//   } 
//
//   F021_FOSC_SoftTrim_func = v_any_dev_active;
//}   /* F021_FOSC_SoftTrim_func */

TMResultM F021_VHV_SLOPECT_SoftTrim_func(IntM &ret_ctval)
{
   const IntS MININD = 0x0; 
   const IntS MAXIND = 0xF;
   const IntS IND_SLPCT = 23; 
   const IntS OPPSTEP = 15; 

   TMResultM final_results;
   IntS testnum,addr;
   IntM slpct;
   IntS tcrnum,tcrnum_src;
   IntM trim_alarms;
   TPModeType tcrmode,tcrmode_src;
   StringS twstr;
   FloatS ttimer1,maxtime,tdelay;
   FloatS llim,ulim,target,max_delta;
   FloatS toler;
   FloatM meas_val;
   PinM testpad;
   IntM ctval;
   IntM bgval,irval,foscval;
   IntM lsw_data,msw_data;
   BoolS bcd_format,hexvalue;
   BoolS logena;


   if(tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ F021_VHV_SLOPECT_SoftTrim_func +++++" << endl;

   bgval = MAINBG_TRIMSAVED;
   irval = MAINIREF_TRIMSAVED;
   foscval = FOSC_TRIMSAVED;
   msw_data = 0;
   RAM_Upload_SoftTrim(0xAA55,bgval,irval,foscval,msw_data,msw_data);

   logena = true;  /*log to tw*/
   maxtime = GL_F021_PARAM_MAXTIME;
   tdelay = 10ms;
   bcd_format = true;
   hexvalue = true;
   addr = ADDR_RAM_SLOPECT_TRIM;
   ctval = 0;
   
   tcrnum  = 115;
   tcrmode = ProgMode;
   testpad = FLTP1;
   testnum = TNUM_PUMP_VHVPROG;
   
   target = VHV_Prog_SlopeCT_Target;
   toler = VHV_Prog_SlopeCT_Toler;
   max_delta = target*toler;
   llim = target-max_delta;
   ulim = target+max_delta;

   CloneTCR_To_TCR128(tcrmode,tcrmode,tcrnum);

   TCR.TP1_LLim[tcrnum][tcrmode] = llim;
   TCR.TP1_ULim[tcrnum][tcrmode] = ulim;

   final_results = TM_NOTEST;
   
   TIME.StartTimer();
   
   lsw_data = foscval << 8; /*format fosc, lshift 8bit*/
   F021_TurnOff_AllTPADS();

   SearchMod my_search;
   // need the FloatM below to make sure we use the proper function version
   my_search.LinearSearchBegin(double(MININD), double(MAXIND), FloatM(1.0), target, max_delta);
   
   IntS i = 0;
   while (my_search.searchNotDone)
   {
      slpct = IntM(my_search.xForceValueMS);
      msw_data = slpct;
      WriteRamContentDec_32Bit(addr, lsw_data, hexvalue, msw_data, hexvalue, bcd_format);
      TL_EngOvride_VHV_PG_CT(0x1FF);
      
      F021_Set_TPADS(tcrnum,tcrmode);
#if $TP3_TO_TP5_PRESENT  
STDDisconnect(FLTP3);
#endif
      F021_RunTestNumber_PMEX(testnum,maxtime);
      TIME.Wait(tdelay);
      meas_val = F021_Meas_TPAD_PMEX(testpad,tcrnum,tcrmode);
      F021_TurnOff_AllTPADS();
      
      twstr = "VHV_PG_SLPCT_SFT_" + i;
      TIDlog.Value(meas_val, testpad, llim, ulim, meas_val.GetUnits(), twstr, 
                   UTL_VOID, UTL_VOID, logena, TWMinimumData);
      
      ++i;
      my_search.SearchNext(meas_val);
   }
   
   trim_alarms = my_search.m_searchAlarmMS;
   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
   {
      if (trim_alarms[*si] == SearchMod::TARGET_FOUND)
      {
         ctval[*si] = int(my_search.xForceValueMS[*si]);
      }
   }
   
   /* final check to see if w/i tolerance limit */
   msw_data = ctval;
   WriteRamContentDec_32Bit(addr,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
   TL_EngOvride_VHV_PG_CT(0x1FF);

   F021_Set_TPADS(tcrnum,tcrmode);
#if $TP3_TO_TP5_PRESENT  
STDDisconnect(FLTP3);
#endif
   
   F021_RunTestNumber_PMEX(testnum,maxtime);
   TIME.Wait(tdelay);
   meas_val = F021_Meas_TPAD_PMEX(testpad,tcrnum,tcrmode);
   F021_TurnOff_AllTPADS();
   
   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
   {
      // hardcoded silliness setting ctval to 0
      if (meas_val[*si] < 1V) 
      {
         ctval[*si] = 0;
      }
      // can't make this an else because there could be a ctval of 0
      // because it didn't find it's trim code
      if (ctval[*si] != 0)
      {
         SITE_TO_FTRIM[*si] = true;
      }
      
      VHV_SLPCT_TRIMSAVED[*si] = ctval[*si];
      StringS soft_str = IntToBinStr(ctval[*si], GL_VHV_SLPCT_MAXEFUSE, true);
      IntS t_str_length = soft_str.Length();
      
      if (t_str_length > GL_VHV_SLPCT_MAXEFUSE)
      {
         StringS error_message;
         IO.Print(error_message, "ERROR: VHV SLOPECT Trim Solution Efuse Bits exceed %d. PROGRAM ISSUE -- NEED TO CONTACT LBE !!!",
                  GL_VHV_SLPCT_MAXEFUSE);
         ERR.ReportError(ERR_GENERIC_CRITICAL, error_message, t_str_length, *si, UTL_VOID);
      }
         
      MAINBG_EFSTR[*si].Replace(IND_SLPCT, GL_VHV_SLPCT_MAXEFUSE, soft_str);

      if(tistdscreenprint)  
         cout << "Site" << *si << " Final Soft Efuse Pump String : " << MAINBG_EFSTR[*si] << endl;
   }
   
   twstr = "VHV_PG_SLPCT_TRIM_SOL";
   TIDlog.Value(ctval, testpad, MININD, MAXIND, "", twstr, 
                   UTL_VOID, UTL_VOID, true, TWMinimumData);
   
   twstr = "VHV_PG_SLPCT_TRIM_NM";
   // note: check against target only -- I guess this means only check against lower limit....
   // This check is the only thing that warranted device pass/fail that I noticed.
   final_results = TIDlog.Value(meas_val, testpad, llim, UTL_VOID, meas_val.GetUnits(), twstr, 
                   UTL_VOID, UTL_VOID, true, TWMinimumData);
                   
   if(tistdscreenprint and TI_FlashDebug)   
      ReadRamAddress(addr,addr+ADDR_RAM_INC);

   ttimer1 = TIME.StopTimer();
   twstr = "VHV_PG_SLPCT_TRIM_TTT";
   TIDlog.Value(ttimer1, UTL_VOID, 0., UTL_VOID, "s", twstr, 
                   UTL_VOID, UTL_VOID, logena, TWMinimumData);

   RestoreTCR_Fr_TCR128(tcrmode,tcrmode,tcrnum);

   ret_ctval = ctval;
   return (final_results);
   
}   /* F021_VHV_SLOPECT_SoftTrim_func */

TMResultM F021_VSA5CT_SoftTrim_func(IntM &ret_ctval)
{
   const IntS MININD = 0x0; 
   const IntS MAXIND = 0xF;
   const IntS IND_VSA5CT = 27; 

   TMResultM final_results;
   IntS testnum,addr;
   IntM slpctval;
   IntS tcrnum,tcrnum_src;
   IntM trim_alarms;
   TPModeType tcrmode,tcrmode_src;
   StringS twstr;
   FloatS ttimer1,maxtime,tdelay;
   FloatS llim,ulim,target,max_delta;
   FloatS toler;
   FloatM meas_val;
   PinM testpad;
   IntM ctval;
   IntM bgval,irval,foscval;
   IntM lsw_data,msw_data;
   BoolS bcd_format,hexvalue;
   BoolS logena;


   if(tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ F021_VSA5CT_SoftTrim_func +++++" << endl;

   bgval = MAINBG_TRIMSAVED;
   irval = MAINIREF_TRIMSAVED;
   foscval = FOSC_TRIMSAVED;
   slpctval = VHV_SLPCT_TRIMSAVED;
   msw_data = 0;
   ctval = 0;
   RAM_Upload_SoftTrim(0xAA55,bgval,irval,foscval,slpctval,msw_data);

   logena = true;  /*log to tw*/
   maxtime = GL_F021_PARAM_MAXTIME;
   tdelay = 10ms;
   bcd_format = true;
   hexvalue = true;
   addr = ADDR_RAM_SLOPECT_TRIM;
   
   tcrnum  = 118;
   tcrmode = ReadMode;
   testpad = FLTP1;
   testnum = TNUM_PUMP_VSA5_READ;
   
   target = VSA5_Read_Target;
   toler = VSA5CT_Toler;
   max_delta = target*toler;
   llim = target-max_delta;
   ulim = target+max_delta;

   CloneTCR_To_TCR128(tcrmode,tcrmode,tcrnum);

   TCR.TP1_LLim[tcrnum][tcrmode] = llim;
   TCR.TP1_ULim[tcrnum][tcrmode] = ulim;

   final_results = TM_NOTEST;

   TIME.StartTimer();

   lsw_data = foscval << 8; /*lshift 8bit*/
   F021_TurnOff_AllTPADS();
   
   SearchMod my_search;
   // need the FloatM below to make sure we use the proper function version
   my_search.LinearSearchBegin(double(MININD), double(MAXIND), FloatM(1.0), target, max_delta);
   
   IntS i = 0;
   IntM val;
   while (my_search.searchNotDone)
   {
      val = IntM(my_search.xForceValueMS);
      val <<= 8; // shift over val
      msw_data = val + slpctval;
      WriteRamContentDec_32Bit(addr, lsw_data, hexvalue, msw_data, hexvalue, bcd_format);
      
      F021_Set_TPADS(tcrnum,tcrmode);
      F021_RunTestNumber_PMEX(testnum,maxtime);
      TIME.Wait(tdelay);
      meas_val = F021_Meas_TPAD_PMEX(testpad,tcrnum,tcrmode);
      F021_TurnOff_AllTPADS();
      
      twstr = "VSA5CT_SFT_" + i;
      TIDlog.Value(meas_val, testpad, llim, ulim, meas_val.GetUnits(), twstr, 
                   UTL_VOID, UTL_VOID, logena, TWMinimumData);
      
      ++i;
      my_search.SearchNext(meas_val);
   }
   
   trim_alarms = my_search.m_searchAlarmMS;
   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
   {
      if (trim_alarms[*si] == SearchMod::TARGET_FOUND)
      {
         ctval[*si] = int(my_search.xForceValueMS[*si]);
      }
   }
   
   /* final check to see if w/i tolerance limit */
   msw_data = ctval << 8; /*lshift 8bit*/
   msw_data += slpctval;
   WriteRamContentDec_32Bit(addr,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);

   F021_Set_TPADS(tcrnum,tcrmode);  
   F021_RunTestNumber_PMEX(testnum,maxtime);
   TIME.Wait(tdelay);
   meas_val = F021_Meas_TPAD_PMEX(testpad,tcrnum,tcrmode);
   F021_TurnOff_AllTPADS();
   
   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
   {
      // hardcoded silliness setting ctval to 0
      if (meas_val[*si] < 1V) 
      {
         ctval[*si] = 0;
      }
      // can't make this an else because there could be a ctval of 0
      // because it didn't find it's trim code
      if (ctval[*si] != 0)
      {
         SITE_TO_FTRIM[*si] = true;
      }
      
      VSA5CT_TRIMSAVED[*si] = ctval[*si];
      StringS soft_str = IntToBinStr(ctval[*si], GL_VSA5CT_MAXEFUSE, true);
      IntS t_str_length = soft_str.Length();
      
      if (t_str_length > GL_VSA5CT_MAXEFUSE)
      {
         StringS error_message;
         IO.Print(error_message, "ERROR: VSA5CT Trim Solution Efuse Bits exceed %d. PROGRAM ISSUE -- NEED TO CONTACT LBE !!!",
                  GL_VSA5CT_MAXEFUSE);
         ERR.ReportError(ERR_GENERIC_CRITICAL, error_message, t_str_length, *si, UTL_VOID);
      }
         
      MAINBG_EFSTR[*si].Replace(IND_VSA5CT, GL_VSA5CT_MAXEFUSE, soft_str);

      if(tistdscreenprint)  
         cout << "Site" << *si << " Final Soft Efuse Pump String : " << MAINBG_EFSTR[*si] << endl;
   }
   
   twstr = "VSA5CT_TRIM_SOL";
   TIDlog.Value(ctval, testpad, MININD, MAXIND, "", twstr, 
                   UTL_VOID, UTL_VOID, true, TWMinimumData);
   
   twstr = "VSA5CT_TRIM_NM";
   // note: check against target only -- I guess this means only check against lower limit....
   // This check is the only thing that warranted device pass/fail that I noticed.
   final_results = TIDlog.Value(meas_val, testpad, llim, UTL_VOID, meas_val.GetUnits(), twstr, 
                   UTL_VOID, UTL_VOID, true, TWMinimumData);
                   
   if(tistdscreenprint and TI_FlashDebug)   
      ReadRamAddress(addr,addr+ADDR_RAM_INC);

   ttimer1 = TIME.StopTimer();
   twstr = "VSA5CT_TRIM_TTT";
   TIDlog.Value(ttimer1, UTL_VOID, 0., UTL_VOID, "s", twstr, 
                   UTL_VOID, UTL_VOID, logena, TWMinimumData);

   RestoreTCR_Fr_TCR128(tcrmode,tcrmode,tcrnum);

   ret_ctval = ctval;
   return (final_results);
   
}   /* F021_VSA5CT_SoftTrim_func */



//void ProgramFlashTrim(      StringS tname1, StringS  tname2,
//                                StringS tname3,
//                                StringM progChainStr,
//                                StringM initChainStr)
//{
//   IntS site;
//   BoolM savesites;
//   BoolM restoreDevActive;
//   BoolM progTrimResults;
//   BoolM progResults;
//   BoolM readResults;
//   BoolM margResults;
//   BoolM postReadResults;
//   FloatS ttimer1,ttimer2;
//   BoolM logsites;
//   StringS tmpstr3;
//   StringM readChainStr;
//   StringM site_cof_inst_str;
//   BoolS save_redund,save_wrp;
//   BoolS save_rdp;
//   twdatatype save_sendtw;
//   BoolM save_prerd;
//   IntM eferrcode;
//
//   timernstart(ttimer1);
//
//    /*KChau 12/21/07 - added savesites to later use for re-activate failed*/
//    /*sites if TIIgnoreFail is true.*/
//   savesites =  V_Dev_Active;
//   restoreDevActive =  V_Dev_Active;
//   progTrimResults =  V_Dev_Active;
//   
//    /*disable site don"t need to blow efuse*/
//   for (site = 1;site <= V_Sites;site++)
//      if(V_Dev_Active[site] and (not SITE_TO_FTRIM[site]))  
//         DevSetHoldState(site, false); 
//   
//   if(v_any_dev_active)  
//   {
//      timernstart(ttimer2);
//      
//      save_redund = progData.redundancy;
//      save_wrp    = progData.writeProtect;
//      save_rdp    = progData.readProtect;
//      save_sendtw = progData.sendTWData;
//      save_prerd = progData.rowPreRead;
//
//      if(GL_EFUSE_RD_CODEOPTION != "")  
//      {
//         readData.codeOption = GL_EFUSE_RD_CODEOPTION;
//      }
//      else
//      {
//         readData.codeOption = "F021";
//         if(tistdscreenprint)  
//         {
//            cout << endl;
//            cout << "!!! WARNING: GL_EFUSE_RD_CODEOPTION is not defined !!!" << endl;
//            cout << "!!! Setting it to "F021" not using SCRAM option    !!!" << endl;
//            cout << endl;
//         } 
//      } 
//         
//      if(GL_EFUSE_PG_CODEOPTION != "")  
//      {
//         progData.codeOption = GL_EFUSE_PG_CODEOPTION;
//      }
//      else
//      {
//         progData.codeOption = "F021";
//         if(tistdscreenprint)  
//         {
//            cout << endl;
//            cout << "!!! WARNING: GL_EFUSE_PG_CODEOPTION is not defined !!!" << endl;
//            cout << "!!! Setting it to "F021" no ECC & not using SCRAM option !!!" << endl;
//            cout << endl;
//         } 
//      } 
//      
//      progData.redundancy   = true;
//      progData.writeProtect = false;
//      progData.readProtect  = false;
//      progData.sendTWData   = TWExtendedData;
//      progData.rowPreRead =  false;  /*tjt*/
//
//      PowerUpAtEfuseRead(DCsetup_LooseVEfuseP, NORM_FMSU);
//      ClockSet(S_CLOCK1A, false, FreqArr[ DMA ],
//                  v[vih_loose_osc_VEfuseP],v[vil_loose], s_pogopin);
//      TIME.Wait(2ms);
//   
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//      
//      logsites = v_dev_active;
//      
//      TestOpen(tname1);   /*FTrimProg_st*/
//      ProgramFuseROM(NonMBist,progChainStr,initChainStr,progResults);      
//      ResultsRecordActive(progResults, S_NULL);
//      TestClose;
//
//      writestring(tmpstr3,tname1);
//      if(not ArrayCompareBoolean(logsites,progResults,v_sites))  
//      {
//         F021_Log_FailPat_To_TW(tmpstr3,progResults,tname1);
//         
//         if(TI_FlashCOFEna)  
//         {
//            F021_Update_COF_Inst_Str(tmpstr3,site_cof_inst_str,progResults);
//            F021_Save_COF_Info("",site_cof_inst_str,progResults);
//         } 
//      } 
//
//      if(tistdscreenprint)  
//      {
//         PrintHeaderBool(GL_PLELL_FORMAT);
//         PrintResultBool(tmpstr3,0,progResults,GL_PLELL_FORMAT);
//         cout << "   TT " << timernread(ttimer2) << endl;
//      } 
//
//       /*+++++*/
//      timernstart(ttimer2);
//      
//      TestOpen(tname2);  /*FTrimPostRead_st*/
//      
//      PowerUpAtEfuseRead(DCsetup_LooseVEfuseR, NORM_FMSU);
//      ClockSet(S_CLOCK1A, false, FreqArr[ DMA ],
//                  v[vih_loose_osc_VEfuseR],v[vil_loose], s_pogopin);
//      TIME.Wait(2ms);
//      
//      ReadFuseROM(NonMBist, MgN, progChainStr,readChainStr,readResults);
//      
//      eferrcode = readData.errorCode;
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//            if((eferrcode[site] == 0x15) or (eferrcode[site] == 0x5))  
//               readResults[site] = false;
//
//      ResultsRecordActive(ReadResults, S_NULL);
//      TestClose; 
//
//      postReadResults =  readResults;
//      
//      writestring(tmpstr3,tname2);
//      if(not ArrayCompareBoolean(logsites,readResults,v_sites))  
//      {
//         F021_Log_FailPat_To_TW(tmpstr3,readResults,tname2);
//         
//         if(TI_FlashCOFEna)  
//         {
//            F021_Update_COF_Inst_Str(tmpstr3,site_cof_inst_str,readResults);
//            F021_Save_COF_Info("",site_cof_inst_str,readResults);
//         } 
//      }          
//
//      if(tistdscreenprint)  
//      {
//         PrintHeaderBool(GL_PLELL_FORMAT);
//         PrintResultBool(tmpstr3,0,readResults,GL_PLELL_FORMAT);
//         cout << "   TT " << timernread(ttimer2) << endl;
//      } 
//
//
//       /*+++++*/
//      timernstart(ttimer2);
//      
//      TestOpen(tname3);  /*FTrimPostReadMg_st*/
//
//      PowerUpAtEfuseRead(DCsetup_LooseVEfuseR, NORM_FMSU);
//      ClockSet(S_CLOCK1A, false, FreqArr[ DMA ],
//                  v[vih_loose_osc_VEfuseR],v[vil_loose], s_pogopin);
//      TIME.Wait(2ms);
//
//      ReadFuseROM(NonMBist, Mg1A, progChainStr,margFlashChainStr,margResults);
//
//      eferrcode = readData.errorCode;
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//            if((eferrcode[site] == 0x15) or (eferrcode[site] == 0x5))  
//               margResults[site] = false;
//
//      ResultsRecordActive(margResults, S_NULL);
//      TestClose;
//
//      ArrayANDBoolean(postReadResults,postReadResults,margResults,V_Sites);
//
//      writestring(tmpstr3,tname3);
//      if(not ArrayCompareBoolean(logsites,margResults,v_sites))  
//      {
//         F021_Log_FailPat_To_TW(tmpstr3,margResults,tname3);
//         
//         if(TI_FlashCOFEna)  
//         {
//            F021_Update_COF_Inst_Str(tmpstr3,site_cof_inst_str,margResults);
//            F021_Save_COF_Info("",site_cof_inst_str,margResults);
//         } 
//      }          
//
//      if(tistdscreenprint)  
//      {
//         PrintHeaderBool(GL_PLELL_FORMAT);
//         PrintResultBool(tmpstr3,0,margResults,GL_PLELL_FORMAT);
//         cout << "   TT " << timernread(ttimer2) << endl;
//      } 
//
//      for (site = 1;site <= V_Sites;site++)
//         if V_Dev_Active[site]  
//            if (not progResults[site]) or (not postReadResults[site])  
//               progTrimResults[site] = false;
//      
//      if(tistdscreenprint)  
//      {
//         PrintHeaderBool(GL_PLELL_FORMAT);
//         PrintResultBool("ProgramFlashTrim",0,progTrimResults,GL_PLELL_FORMAT);
//         cout << "   TT " << timernread(ttimer1) << endl;
//      } 
//
//      ArrayANDBoolean(restoreDevActive,restoreDevActive, progTrimResults, V_Sites); 
//      
//      if((not tiignorefail) and (not TI_FlashCOFEna))  
//         DevSetHoldStates(restoreDevActive);
//      else
//         DevSetHoldStates(savesites);   /*KChau 12/21/07 - added to re-activate*/
//                                        /*sites that failed efuse blow/trim*/
//
//      progData.redundancy   = save_redund;
//      progData.writeProtect = save_wrp;
//      progData.readProtect  = save_rdp;
//      progData.sendTWData   = save_sendtw;
//      progData.rowPreRead = save_prerd;
//   }   /*if v_any_dev_active*/
//   
//}   /* ProgramFlashTrim */
//
//BoolS F021_IPMOS_SoftTrim_func()
//{
//   const IntS EVENNUM = 0; 
//   const IntS ODDNUM = 1; 
//   const IntS MINITER = 1; 
//   const IntS MAXITER = 5; 
//
//   BoolM savesites,activesites,logsites,sitetotrim;
//   BoolM tmp_results,final_results,meas_results;
//   BoolM enasites,trim_valid;
//   IntS1D tnum_ipmos; /* :MANUAL FIX REQUIRED: array dimensions are : EVENNUM..ODDNUM */
//   FloatM2D ival_pre,ival_pst; /* :MANUAL FIX REQUIRED: array dimensions are : 0..7,EVENNUM..ODDNUM */
//   FloatM2D ratio_pre,ratio_pst; /* :MANUAL FIX REQUIRED: array dimensions are : 0..7,EVENNUM..ODDNUM */
//   IntM2D tcode_pre,tcode_pst,index_pre,index_pst; /* :MANUAL FIX REQUIRED: array dimensions are : 0..7,EVENNUM..ODDNUM */
//   StringM2D trim_code_str; /* :MANUAL FIX REQUIRED: array dimensions are : 0..7,EVENNUM..ODDNUM */
//   FloatM calratio,tmptrimratio,ratio;
//   IntM trimcode,index,msw_val,lsw_val;
//   IntM tmptrimindex,tmptrimcode,orgtrimcode;
//   IntM1D sftindex; /* :MANUAL FIX REQUIRED: array dimensions are : MINITER..MAXITER */
//   array[0..7,EVENNUM..ODDNUM,MINITER..MAXITER] of FloatM sftival; /* No SV type for > 2 dimensional arrays :MANUAL FIX REQUIRED: */
//   FloatM meas_val,tt_timer,delta,tmpdelta;
//   IntS testnum,tcrnum,bank,site,loop,iteration,i,j,k;
//   TPModeType tcrmode;
//   FloatS maxtime,tdelay,tdelay2,ttimer1;
//   PinM testpad;
//   FloatS llim,ulim,Ifactor; 
//   BoolS even_ena,odd_ena,debugprint,sbool1;
//   StringS str1,str2,str3,str4,str5,logstr;
//   StringS tmpefstr;
//   StringS fl_testname;
//   FloatM FloatSval;
//   TWunit unitval;
//   IntS minloop,maxloop;
//
//    /*++++++++++++++++*/
//   procedure GetTrimCode_Index_On_Ratio; /* didn"t match any chunk types, FIX */
//   var
//      IntS i;
//   
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            if(calratio[site]>IREF_PMOSRATIO[0])  
//            {
//               trimcode[site] = IREF_PMOSCODE[0];  /*out of range so set to code 0*/
//               index[site] = 0;
//               trim_valid[site] = false;
//               if(tistdscreenprint)  
//                  cout << "Site" << site:-5 << " Calculate Ratio==" << calratio[site] << " Out Of Range ***" << endl;
//            }
//            else
//            {
//               if((calratio[site]<==IREF_PMOSRATIO[0]) and (calratio[site]>IREF_PMOSRATIO[1]))  
//                  i = 0;
//               else if((calratio[site]<==IREF_PMOSRATIO[1]) and (calratio[site]>IREF_PMOSRATIO[2]))  
//                  i = 1            ;
//               else if((calratio[site]<==IREF_PMOSRATIO[2]) and (calratio[site]>IREF_PMOSRATIO[3]))  
//                  i = 2;
//               else if((calratio[site]<==IREF_PMOSRATIO[3]) and (calratio[site]>IREF_PMOSRATIO[4]))  
//                  i = 3;
//               else if((calratio[site]<==IREF_PMOSRATIO[4]) and (calratio[site]>IREF_PMOSRATIO[5]))  
//                  i = 4;
//               else if((calratio[site]<==IREF_PMOSRATIO[5]) and (calratio[site]>IREF_PMOSRATIO[6]))  
//                  i = 5;
//               else if((calratio[site]<==IREF_PMOSRATIO[6]) and (calratio[site]>IREF_PMOSRATIO[7]))  
//                  i = 6;
//               else if((calratio[site]<==IREF_PMOSRATIO[7]) and (calratio[site]>IREF_PMOSRATIO[8]))  
//                  i = 7;
//               else if((calratio[site]<==IREF_PMOSRATIO[8]) and (calratio[site]>IREF_PMOSRATIO[9]))  
//                  i = 8;
//               else if((calratio[site]<==IREF_PMOSRATIO[9]) and (calratio[site]>IREF_PMOSRATIO[10]))  
//                  i = 9;
//               else if((calratio[site]<==IREF_PMOSRATIO[10]) and (calratio[site]>IREF_PMOSRATIO[11]))  
//                  i = 10;
//               else if((calratio[site]<==IREF_PMOSRATIO[11]) and (calratio[site]>IREF_PMOSRATIO[12]))  
//                  i = 11;
//               else if((calratio[site]<==IREF_PMOSRATIO[12]) and (calratio[site]>IREF_PMOSRATIO[13]))  
//                  i = 12;
//               else if((calratio[site]<==IREF_PMOSRATIO[13]) and (calratio[site]>IREF_PMOSRATIO[14]))  
//                  i = 13;
//               else if((calratio[site]<==IREF_PMOSRATIO[14]) and (calratio[site]>IREF_PMOSRATIO[15]))  
//                  i = 14;
//               else if((calratio[site]<==IREF_PMOSRATIO[15]) and (calratio[site]>IREF_PMOSRATIO[16]))  
//                  i = 15;
//               else if((calratio[site]<==IREF_PMOSRATIO[16]) and (calratio[site]>IREF_PMOSRATIO[17]))  
//                  i = 16;
//               else if((calratio[site]<==IREF_PMOSRATIO[17]) and (calratio[site]>IREF_PMOSRATIO[18]))  
//                  i = 17;
//               else if((calratio[site]<==IREF_PMOSRATIO[18]) and (calratio[site]>IREF_PMOSRATIO[19]))  
//                  i = 18;
//               else if((calratio[site]<==IREF_PMOSRATIO[19]) and (calratio[site]>IREF_PMOSRATIO[20]))  
//                  i = 19;
//               else if((calratio[site]<==IREF_PMOSRATIO[20]) and (calratio[site]>IREF_PMOSRATIO[21]))  
//                  i = 20;
//               else if((calratio[site]<==IREF_PMOSRATIO[21]) and (calratio[site]>IREF_PMOSRATIO[22]))  
//                  i = 21;
//               else if((calratio[site]<==IREF_PMOSRATIO[22]) and (calratio[site]>IREF_PMOSRATIO[23]))  
//                  i = 22;
//               else if((calratio[site]<==IREF_PMOSRATIO[23]) and (calratio[site]>IREF_PMOSRATIO[24]))  
//                  i = 23;
//               else if((calratio[site]<==IREF_PMOSRATIO[24]) and (calratio[site]>IREF_PMOSRATIO[25]))  
//                  i = 24;
//               else if((calratio[site]<==IREF_PMOSRATIO[25]) and (calratio[site]>IREF_PMOSRATIO[26]))  
//                  i = 25;
//               else if((calratio[site]<==IREF_PMOSRATIO[26]) and (calratio[site]>IREF_PMOSRATIO[27]))  
//                  i = 26;
//               else if((calratio[site]<==IREF_PMOSRATIO[27]) and (calratio[site]>IREF_PMOSRATIO[28]))  
//                  i = 27;
//               else if((calratio[site]<==IREF_PMOSRATIO[28]) and (calratio[site]>IREF_PMOSRATIO[29]))  
//                  i = 28;
//               else if((calratio[site]<==IREF_PMOSRATIO[29]) and (calratio[site]>IREF_PMOSRATIO[30]))  
//                  i = 29;
//               else if((calratio[site]<==IREF_PMOSRATIO[30]) and (calratio[site]>IREF_PMOSRATIO[31]))  
//                  i = 30;
//               else 
//                  i = 31;
//               
//           trimcode[site] = IREF_PMOSCODE[i];
//           index[site] = i;
//            } 
//            
//            if(tistdscreenprint and debugprint)  
//               cout << "Site:" << site:-5 << " Calc Ratio == " << calratio[site]:-5:3 << 
//                       " Trim Code == " << trimcode[site]:s_hex:-5 << " Index == " << index[site]:-5 << endl;
//         }   /*v_dev_active*/
//   }   /* GetTrimCode_Index_On_Ratio */
//    /*++++++++++++++++*/
//   procedure GetTrimCode_Ratio_On_SftIndex; /* didn"t match any chunk types, FIX */
//   var
//      IntS i;
//   {
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            i = sftindex[j][site];
//            trimcode[site] = IREF_PMOSCODE[i];
//            ratio[site] = IREF_PMOSRATIO[i];
//            if(tistdscreenprint and debugprint)  
//               cout << "Site:" << site:-5 << " Ratio == " << ratio[site]:-5:3 << 
//                       " Trim Code == " << trimcode[site]:s_hex:-5 << " Index == " << i:-5 << endl;
//         } 
//   }   /* GetTrimCode_Ratio_On_SftIndex */
//    /*++++++++++++++++*/
//   procedure DoIMeasure; /* didn"t match any chunk types, FIX */
//   {
//      F021_TurnOff_AllTPADS;
//      F021_Set_TPADS(tcrnum,tcrmode);
//      TIME.Wait(tdelay2);
//      F021_RunTestNumber_PMEX(testnum,maxtime,tmp_results);
//      TIME.Wait(tdelay);
//      F021_Meas_TPAD_PMEX(testpad,tcrnum,tcrmode,llim,ulim,meas_val,meas_results);
//      F021_TurnOff_AllTPADS;
//      Disable(s_pmexit);
//   }       
//    /*++++++++++++++++*/
//   Procedure PrintResultTrimCode; /* didn"t match any chunk types, FIX */
//   var
//      IntS fdlen1,fdlen2,fdlen3,fdlen4,decpt;
//      StringS pstr1,pstr2,pstr3,pstr4,pstr5;
//      StringS unitstr;
//      IntS unitlen;
//      FloatS FloatSvalue;
//      FloatS FloatSvalue;
//   {
//      pstr1 = "------------------------------";  /*30*/
//      pstr2 = "----------";  /*10*/
//      pstr3 = " "; 
//      fdlen1 = 30;
//      fdlen2 = 10;
//      fdlen3 = 10;
//      fdlen4 = 8;
//      decpt  = 2;
//
//      if(GL_PLELL_FORMAT)  
//      {
//         cout << endl;
//         cout << str2:-fdlen1 << pstr3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         {
//            writestring(pstr4,site:1);
//            pstr4 = "Site" + pstr4;
//            cout << pstr4:-fdlen2 << pstr3;
//         } 
//         cout << endl;
//         
//         cout << pstr1 << pstr3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            cout << pstr2 << pstr3;
//         cout << endl;
//
//         pstr5 = "PMOS Iref Pre";
//         cout << pstr5:-fdlen1 << pstr3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               trealvalue = ival_pre[bank][loop][site];
//               GetTreal_Unit_Info(trealvalue,realvalue,unitlen,unitstr);
//               cout << realvalue:(fdlen3-unitlen):decpt << unitstr << pstr3;
//            }
//            else
//               cout << "X":fdlen3 << pstr3;
//         cout << endl;
//
//         pstr5 = "Calculate Ratio";
//         cout << pstr5:-fdlen1 << pstr3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               cout << ratio_pre[bank][loop][site]:fdlen3:decpt << pstr3);
//            else
//               cout << "X":fdlen3 << pstr3;
//         cout << endl;
//
//         pstr5 = "Soft Trim Ratio";
//         cout << pstr5:-fdlen1 << pstr3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               cout << ratio_pst[bank][loop][site]:fdlen3:decpt << pstr3);
//            else
//               cout << "X":fdlen3 << pstr3;
//         cout << endl;
//
//         pstr5 = "Soft Trim Code";
//         cout << pstr5:-fdlen1 << pstr3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               cout << tcode_pst[bank][loop][site]:fdlen3 << pstr3);
//            else
//               cout << "X":fdlen3 << pstr3;
//         cout << endl;
//
//         pstr5 = "PMOS Iref Soft";
//         cout << pstr5:-fdlen1 << pstr3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               trealvalue = ival_pst[bank][loop][site];
//               GetTreal_Unit_Info(trealvalue,realvalue,unitlen,unitstr);
//               cout << realvalue:(fdlen3-unitlen):decpt << unitstr << pstr3;
//            }
//            else
//               cout << "X":fdlen3 << pstr3;
//         cout << endl;
//
//         pstr5 = "Target Iref";
//         cout << pstr5:-fdlen1 << pstr3;
//         trealvalue = IPMOS_Trim_Target;
//         GetTreal_Unit_Info(trealvalue,realvalue,unitlen,unitstr);
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               cout << realvalue:(fdlen3-unitlen):decpt << unitstr << pstr3);
//            else
//               cout << "X":fdlen3 << pstr3;
//         cout << endl;
//
//         pstr5 = "Trim Result";
//         cout << pstr5:-fdlen1 << pstr3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               if(trim_valid[site])  
//                  cout << "PASS":fdlen3 << pstr3);
//               else
//                  cout << "FAIL**":fdlen3 << pstr3;
//            }
//            else
//               cout << "X":fdlen3 << pstr3;
//         cout << endl;
//
//         cout << endl;
//      }  /*if paral_format*/
//      else
//      {  /*serial_format*/
//         cout << endl;
//         cout << "TestName ":-fdlen1 << pstr3 << "Iref Pre":-fdlen2 << pstr3 << "Calc Ratio" << pstr3 << 
//                 "Trim Ratio" << pstr3 << "Trim Code" << pstr3 << "Iref Pst" << pstr3 << "TargetIref" << pstr3 << "TrimResult" << endl;
//         cout << pstr1 << pstr3 << pstr2 << pstr3 << pstr2 << pstr3 << pstr2 << pstr3 << pstr2 << pstr3 << pstr2 << pstr3 << pstr2 << pstr3 << pstr2 << endl;
//
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               writestring(pstr4,site:1);
//               pstr4 = "_Site" + pstr4;
//               pstr4 = str2 + pstr4;
//               cout << pstr4:-fdlen1 << pstr3;
//               trealvalue = ival_pre[bank][loop][site];
//               GetTreal_Unit_Info(trealvalue,realvalue,unitlen,unitstr);
//               cout << realvalue:(fdlen3-unitlen):decpt << unitstr << pstr3 << 
//                     ratio_pre[bank][loop][site]:fdlen3:decpt << pstr3 << ratio_pst[bank][loop][site]:fdlen3:decpt << pstr3 << 
//                     tcode_pst[bank][loop][site]:fdlen3 << pstr3;
//
//               trealvalue = ival_pst[bank][loop][site];
//               GetTreal_Unit_Info(trealvalue,realvalue,unitlen,unitstr);
//               cout << realvalue:(fdlen3-unitlen):decpt << unitstr << pstr3;
//               trealvalue = IPMOS_Trim_Target;
//               GetTreal_Unit_Info(trealvalue,realvalue,unitlen,unitstr);
//               cout << realvalue:(fdlen3-unitlen):decpt << unitstr << pstr3;
//
//               if(trim_valid[site])  
//                  cout << "PASS":fdlen3);
//               else
//                  cout << "FAIL**":fdlen3 << endl;
//            } 
//         cout << endl;
//      } 
//   }   /* PrintResultTrimCode */
//       /*++++++++++++++++*/
//{
//   if(v_any_dev_active)  
//   {
//      maxtime = GL_F021_PARAM_MAXTIME;
//      tdelay  = 10ms;
//      tdelay2 = 2ms;
//
//      tcrnum  = 40;
//      tcrmode = ErsMode;  /*actual mode is rd*/
//      testpad = FLTP2;
//      llim    = TCR.TP2_LLim[TCRnum][TCRMode];
//      ulim    = TCR.TP2_ULim[TCRnum][TCRMode];
//      tnum_ipmos[0] = TNUM_BANK_IPMOS_READ_EVEN;
//      tnum_ipmos[1] = TNUM_BANK_IPMOS_READ_ODD;
//
//      Ifactor = IPMOS_Trim_Target-(IPMOS_Trim_Target*IPMOS_Trim_Toler);
//
//      timernstart(ttimer1);
//
//      fl_testname = IrefPMOS_Trim_Test;
//      TestOpen(fl_testname);
//      
//      savesites = V_dev_active;
//      final_results = V_dev_active;
//      trim_valid = V_dev_active;
//      activesites = V_dev_active;
//
//      debugprint = TI_FlashDebug and tiprintpass ; /*false*/
//      iteration  = MAXITER;
//
//      minloop = EVENNUM;
//      maxloop = ODDNUM;
//
//       /*init*/
//      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//      {
//         for (loop = minloop;loop <= maxloop;loop++)
//         {
//            ival_pre[bank][loop] = 0.0uA;
//            ival_pst[bank][loop] = 0.0uA;
//            ratio_pre[bank][loop] = 0.0;
//            ratio_pst[bank][loop] = 0.0;
//            tcode_pre[bank][loop] = 0;
//            tcode_pst[bank][loop] = 0;
//            IPMOS_TRIMCODE_SAVED[bank][loop] = 0;
//            for (j = MINITER;j <= iteration;j++)
//               sftival[bank][loop][j] = 0.0;
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//                  trim_code_str[bank][loop][site] = "00000";
//         }   /*loop*/
//      } 
//
//      if(GL_BANKTYPE==FLESBANK)  
//         maxloop = EVENNUM;
//
//      if(TI_FlashDebug)  
//         PrintHeaderParam(GL_PLELL_FORMAT);
//      
//      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//      {
//          /*enable site with bank to trim*/
//         sitetotrim = BANK_TO_PMOS_TRIM[bank];
//         ArrayAndBoolean(sitetotrim,sitetotrim,activesites,v_sites);
//         devsetholdstates(sitetotrim);
//         logsites = v_dev_active;
//
//          /*+++++*/
//         if(v_any_dev_active)  
//         {
//            writestring(str1,bank:1);
//
//            for (loop = minloop;loop <= maxloop;loop++) /*even than odd*/
//            {
//               testnum = tnum_ipmos[loop]+(bank<<4);
//               if(loop==0)  
//                  str3 = "_EVN";
//               else
//                  str3 = "_ODD";
//
//            str2 = "IPMOS_Pre_B" + str1;
//               str4 = str2 + str3;
//               
//               if(tistdscreenprint and debugprint)  
//                  cout << "Bank" << bank:-5 << "Loop" << loop:-5 << "Pre Trim" << endl;
//               
//                /*-- calculate ratio --*/
//               DoIMeasure;  /*store in meas_val*/
//               if(TI_FlashDebug)  
//                  PrintResultParam(str4,testnum,meas_results,llim,ulim,meas_val,GL_PLELL_FORMAT);
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                     calratio[site] = single(meas_val[site]/Ifactor);
//
//               GetTrimCode_Index_On_Ratio;  /*store code in trimcode, look-up-table index*/
//
//                /*-- store pre info --*/
//               ival_pre[bank][loop] = meas_val;
//               ratio_pre[bank][loop] = calratio;
//               tcode_pre[bank][loop] = trimcode;
//               index_pre[bank][loop] = index;
//
//               logstr = str4;  /*IPMOS_Pre_Bx_EVN*/
//               TWTRealToRealMS(meas_val,realval,unitval);
//               TWPDLDataLogRealVariable(logstr, unitval,realval,TWMinimumData);
//
//               logstr = str4 + "_CRATIO";  /*IPMOS_Pre_Bx_EVN_CRATIO*/
//               unitval = NoUnits;
//               TWPDLDataLogRealVariable(logstr, unitval,calratio,TWMinimumData);
//               
//                /*-- do soft --*/
//               sftindex[MINITER] = index;
//               for (i = MINITER+1;i <= (iteration-1);i++)
//                  ArrayAddIntegerValue(sftindex[i],sftindex[i-1],1,v_sites);
//               ArraySubIntegerValue(sftindex[iteration],sftindex[MINITER],1,v_sites);
//
//               if(loop==0)  
//               {
//                  even_ena = true;
//                  odd_ena  = false;
//               }
//               else
//               {
//                  even_ena = false;
//                  odd_ena  = true;
//               } 
//
//               enasites = v_dev_active;
//               
//               for (j = MINITER;j <= iteration;j++)
//               {
//                  sbool1 = false;
//                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                     if(v_dev_active[site])  
//                        if((sftindex[j][site]<0) or (sftindex[j][site]>31))  
//                        {
//                           sbool1 = true;
//                           devsetholdstate(site,false);  /*skip site w/ out of bound index*/
//                        } 
//
//                  if(v_any_dev_active)  
//                  {
//                     if(tistdscreenprint and debugprint)  
//                        cout << "Soft Trim -- Bank" << bank:-5 << "Loop" << loop:-5 << "Iteration" << j:-5 << endl;
//                     
//                     GetTrimCode_Ratio_On_SftIndex;   /*store code in trimcode, ratio*/
//                     orgtrimcode = trimcode;
//
//                     if(loop==0)  
//                        for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                           if(v_dev_active[site])  
//                              trimcode[site] = trimcode[site]<<8;   /*format even*/
//                     
//                     if((bank mod 2) == 0)  
//                     {
//                        msw_val = trimcode;   /*bank0*/
//                        lsw_val = 0;      /*bank1*/
//                     }
//                     else
//                     {
//                        msw_val = 0;
//                        lsw_val = trimcode;
//                     } 
//
//                     writestring(str5,j:1);
//                     str5 = "_" + str5;
//                     str4 = "IPMOS_SFT_B" + str1;
//                     str4 = str4 + str3;
//                     str4 = str4 + str5;
//                     
//                     RAM_Upload_PMOS_SoftTrim_Bank(bank,even_ena,odd_ena,msw_val,lsw_val);
//                     DoIMeasure;
//                     if(TI_FlashDebug)  
//                        PrintResultParam(str4,testnum,meas_results,llim,ulim,meas_val,GL_PLELL_FORMAT);
//                     sftival[bank][loop][j] = meas_val;
//                     RAM_Clear_PMOS_SoftTrim_Bank(bank);
//                     
//                     logstr = str4;  /*IPMOS_SFT_Bx_EVN_x*/
//                     TWTRealToRealMS(meas_val,realval,unitval);
//                     TWPDLDataLogRealVariable(logstr, unitval,realval,TWMinimumData);
//
//                     logstr = str4 + "_RATIO";  /*IPMOS_SFT_Bx_EVN_x_RATIO*/
//                     unitval = NoUnits;
//                     TWPDLDataLogRealVariable(logstr, unitval,ratio,TWMinimumData);
//
//                     logstr = str4 + "_TC";   /*IPMOS_SFT_Bx_EVN_x_TC*/
//                     TWPDLDataLogVariable(logstr,orgtrimcode,TWMinimumData);
//
//                     for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                        if(v_dev_active[site])  
//                        {
//                           tmpdelta[site] = abs(meas_val[site]-IPMOS_Trim_Target);
//                           if(j==MINITER)  
//                           {
//                              delta[site] = tmpdelta[site];
//                              tmptrimindex[site] = j;
//                              tmptrimcode[site] = trimcode[site];
//                              tmptrimratio[site] = ratio[site];
//                           } 
//                           
//                           if(tmpdelta[site] < delta[site])  
//                           {
//                              delta[site] = tmpdelta[site];
//                              tmptrimindex[site] = j;
//                              tmptrimcode[site] = trimcode[site];
//                              tmptrimratio[site] = ratio[site];
//                           } 
//                        } 
//                  }   /*if v_any_dev_active*/
//                  
//                  if(sbool1)  
//                     Devsetholdstates(enasites);
//               }   /*for j iteration*/
//
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                  {
//                     j = tmptrimindex[site];
//                     ival_pst[bank][loop][site]  = sftival[bank][loop][j][site];
//                     tmpdelta[site] = ival_pst[bank][loop][site];
//                     if((abs(ival_pst[bank][loop][site]) < abs(IPMOS_Trim_ULim)) or
//                        (abs(ival_pst[bank][loop][site]) > abs(IPMOS_Trim_LLim)))  
//                        trim_valid[site] = false;
//
//                     if(loop==0)  
//                        tmptrimcode[site] = tmptrimcode[site] div 256;
//
//                     tcode_pst[bank][loop][site] = tmptrimcode[site];
//                     IPMOS_TRIMCODE_SAVED[bank][loop][site] = tmptrimcode[site];  /*save for later use*/
//                     ratio_pst[bank][loop][site] = tmptrimratio[site];
//                     k = sftindex[j][site];
//                     index_pst[bank][loop][site] = k;  /*sftindex[j,site];*/
//                     trim_code_str[bank][loop][site] = IREF_PMOSCODE_STR[k];
//
//                     if(tistdscreenprint and debugprint)  
//                        cout << "Site" << site:-5 << "Bank" << bank:-5 << "Loop" << loop:-5 << 
//                                " Pre IVal== " << ival_pre[bank][loop][site]:-6:3 << 
//                                " CalcRatio== " << ratio_pre[bank][loop][site]:-6:2 << 
//                                " TrimCode== " << tcode_pre[bank][loop][site]:s_hex:-5 << 
//                                " --  Final Soft IVal== " << ival_pst[bank][loop][site]:-6:3 << 
//                                " Ratio== " << ratio_pst[bank][loop][site]:-6:2 << 
//                                " TrimCode== " << tcode_pst[bank][loop][site]:s_hex:-5 << 
//                                " ** " << trim_valid[site] << " ** " << endl;
//                  } 
//
//               
//               str4 = "IPMOS_TRIM_B" + str1;
//               str4 = str4 + str3;
//
//               logstr = str4;  /*IPMOS_TRIM_Bx_EVN*/
//               TWTRealToRealMS(tmpdelta,realval,unitval);
//               TWPDLDataLogRealVariable(logstr, unitval,realval,TWMinimumData);
//               
//               logstr = str4 + "_RATIO";  /*IPMOS_TRIM_Bx_EVN_RATIO*/
//               unitval = NoUnits;
//               TWPDLDataLogRealVariable(logstr, unitval,tmptrimratio,TWMinimumData);
//
//               logstr = str4 + "_TC";   /*IPMOS_TRIM_Bx_EVN_TC*/
//               TWPDLDataLogVariable(logstr,tmptrimcode,TWMinimumData);
//
//
//               if(tistdscreenprint)  
//               {
//                  str2 = "IPMOS_TRIM_B" + str1;
//                  str2 = str2 + str3;
//                  PrintResultTrimCode;
//               } 
//                               /*-- do soft --*/
//            }   /*for loop*/
//
//            ArrayAndBoolean(final_results,final_results,trim_valid,v_sites);
//            ArrayAndBoolean(logsites,logsites,trim_valid,v_sites);
//
//            if(not ArrayCompareBoolean(logsites,sitetotrim,v_sites))  
//            {
//               logstr = "IPMOS_TRIM_B" + str1;
//               F021_Log_FailPat_To_TW(logstr,tmp_results,fl_testname);
//            } 
//
//            if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//            {
//               ArrayAndBoolean(activesites,activesites,final_results,v_sites);
//               Devsetholdstates(final_results);
//            } 
//
//             /*format & store efuse string per bank bit31:0*/
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  tmpefstr = BANKEF_BIT29_31 + trim_code_str[bank][1][site];  /*odd*/
//                  tmpefstr = tmpefstr + BANKEF_BIT10_23_BANKNUM[bank];
//                  tmpefstr = tmpefstr + trim_code_str[bank][0][site];  /*even*/
//                  tmpefstr = tmpefstr + BANKEF_BIT0_4;
//                  IREF_PMOSTRIMCODE_STR[bank][site] = tmpefstr;
//               } 
//
//         }   /*if v_any_dev_active*/
//          /*+++++*/
//
//      }   /*for bank*/
//
//      Devsetholdstates(savesites);
//      
//      ResultsRecordActive(final_results, S_NULL);
//      TestClose;
//
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site] and trim_valid[site])  
//            SITE_TO_FTRIM[site] = true;
//      
//      ttimer1 = timernread(ttimer1);
//      tt_timer = ttimer1;
//
//      writestring(str1,fl_testname);
//      i = len(str1);
//      writestring(str1,mid(str1,2,i-6));  /*remove _Test*/
//
//      str4 = str1 + "_TTT";
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(str4, unitval,realval,TWMinimumData);
//      
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//         Devsetholdstates(final_results);
//
//      if(tistdscreenprint)  
//      {
//         PrintResultBool(str1,tnum_ipmos[0],final_results,GL_PLELL_FORMAT);
//         cout << "   TT " << ttimer1 << endl;
//         cout << endl;         
//      } 
//      
//   }   /*if v_any_dev_active*/
//
//   F021_IPMOS_SoftTrim_func = v_any_dev_active;
//}   /* F021_IPMOS_SoftTrim_func */
//   
//BoolS F021_IPMOS_NMOS_SoftTrim_func(IntS trimopt)
//{
//   const IntS EVENNUM = 0; 
//   const IntS ODDNUM = 1; 
//   const IntS MINITER = 1; 
//   const IntS MAXITER = 6; 
//   const IntS TRIMOPT_PMOS = 0; 
//   const IntS TRIMOPT_IRD = 1; 
//   const IntS TRIMOPT_IEV = 2; 
//
//   BoolM savesites,activesites,logsites,sitetotrim;
//   BoolM tmp_results,final_results,meas_results;
//   BoolM enasites,trim_valid;
//   IntS1D tnum_ipmos,tnum_irefrd,tnum_irefev; /* :MANUAL FIX REQUIRED: array dimensions are : EVENNUM..ODDNUM */
//   FloatM2D ival_pre,ival_pst; /* :MANUAL FIX REQUIRED: array dimensions are : 0..7,EVENNUM..ODDNUM */
//   FloatM2D ratio_pre,ratio_pst; /* :MANUAL FIX REQUIRED: array dimensions are : 0..7,EVENNUM..ODDNUM */
//   IntM2D tcode_pre,tcode_pst,index_pre,index_pst; /* :MANUAL FIX REQUIRED: array dimensions are : 0..7,EVENNUM..ODDNUM */
//   StringM2D trim_code_str; /* :MANUAL FIX REQUIRED: array dimensions are : 0..7,EVENNUM..ODDNUM */
//   FloatM calratio,tmptrimratio,ratio;
//   IntM trimcode,index,msw_val,lsw_val;
//   IntM tmptrimindex,tmptrimcode,orgtrimcode;
//   IntM1D sftindex; /* :MANUAL FIX REQUIRED: array dimensions are : MINITER..MAXITER */
//   array[0..7,EVENNUM..ODDNUM,MINITER..MAXITER] of FloatM sftival; /* No SV type for > 2 dimensional arrays :MANUAL FIX REQUIRED: */
//   FloatM meas_val,tt_timer,delta,tmpdelta;
//   IntS testnum,tcrnum,bank,site,loop,iteration,i,j,k;
//   TPModeType tcrmode;
//   FloatS maxtime,tdelay,tdelay2,ttimer1;
//   PinM testpad;
//   FloatS llim,ulim,Ifactor; 
//   BoolS even_ena,odd_ena,debugprint,sbool1;
//   StringS str1,str2,str3,str4,str5,logstr;
//   StringS tmpefstr;
//   StringS fl_testname;
//   FloatM FloatSval;
//   TWunit unitval;
//   FloatS ITrim_target,ITrim_llim,ITrim_ulim;
//   IntS minloop,maxloop;
//
//    /*++++++++++++++++*/
//   procedure GetTrimCode_Index_On_Ratio; /* didn"t match any chunk types, FIX */
//   var
//      IntS i;
//   
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            if(calratio[site]>IREF_PMOSRATIO[0])  
//            {
//               trimcode[site] = IREF_PMOSCODE[0];  /*out of range so set to code 0*/
//               index[site] = 0;
//               trim_valid[site] = false;
//               if(tistdscreenprint)  
//                  cout << "Site" << site:-5 << " Calculate Ratio==" << calratio[site] << " Out Of Range ***" << endl;
//            }
//            else
//            {
//               if((calratio[site]<==IREF_PMOSRATIO[0]) and (calratio[site]>IREF_PMOSRATIO[1]))  
//                  i = 0;
//               else if((calratio[site]<==IREF_PMOSRATIO[1]) and (calratio[site]>IREF_PMOSRATIO[2]))  
//                  i = 1            ;
//               else if((calratio[site]<==IREF_PMOSRATIO[2]) and (calratio[site]>IREF_PMOSRATIO[3]))  
//                  i = 2;
//               else if((calratio[site]<==IREF_PMOSRATIO[3]) and (calratio[site]>IREF_PMOSRATIO[4]))  
//                  i = 3;
//               else if((calratio[site]<==IREF_PMOSRATIO[4]) and (calratio[site]>IREF_PMOSRATIO[5]))  
//                  i = 4;
//               else if((calratio[site]<==IREF_PMOSRATIO[5]) and (calratio[site]>IREF_PMOSRATIO[6]))  
//                  i = 5;
//               else if((calratio[site]<==IREF_PMOSRATIO[6]) and (calratio[site]>IREF_PMOSRATIO[7]))  
//                  i = 6;
//               else if((calratio[site]<==IREF_PMOSRATIO[7]) and (calratio[site]>IREF_PMOSRATIO[8]))  
//                  i = 7;
//               else if((calratio[site]<==IREF_PMOSRATIO[8]) and (calratio[site]>IREF_PMOSRATIO[9]))  
//                  i = 8;
//               else if((calratio[site]<==IREF_PMOSRATIO[9]) and (calratio[site]>IREF_PMOSRATIO[10]))  
//                  i = 9;
//               else if((calratio[site]<==IREF_PMOSRATIO[10]) and (calratio[site]>IREF_PMOSRATIO[11]))  
//                  i = 10;
//               else if((calratio[site]<==IREF_PMOSRATIO[11]) and (calratio[site]>IREF_PMOSRATIO[12]))  
//                  i = 11;
//               else if((calratio[site]<==IREF_PMOSRATIO[12]) and (calratio[site]>IREF_PMOSRATIO[13]))  
//                  i = 12;
//               else if((calratio[site]<==IREF_PMOSRATIO[13]) and (calratio[site]>IREF_PMOSRATIO[14]))  
//                  i = 13;
//               else if((calratio[site]<==IREF_PMOSRATIO[14]) and (calratio[site]>IREF_PMOSRATIO[15]))  
//                  i = 14;
//               else if((calratio[site]<==IREF_PMOSRATIO[15]) and (calratio[site]>IREF_PMOSRATIO[16]))  
//                  i = 15;
//               else if((calratio[site]<==IREF_PMOSRATIO[16]) and (calratio[site]>IREF_PMOSRATIO[17]))  
//                  i = 16;
//               else if((calratio[site]<==IREF_PMOSRATIO[17]) and (calratio[site]>IREF_PMOSRATIO[18]))  
//                  i = 17;
//               else if((calratio[site]<==IREF_PMOSRATIO[18]) and (calratio[site]>IREF_PMOSRATIO[19]))  
//                  i = 18;
//               else if((calratio[site]<==IREF_PMOSRATIO[19]) and (calratio[site]>IREF_PMOSRATIO[20]))  
//                  i = 19;
//               else if((calratio[site]<==IREF_PMOSRATIO[20]) and (calratio[site]>IREF_PMOSRATIO[21]))  
//                  i = 20;
//               else if((calratio[site]<==IREF_PMOSRATIO[21]) and (calratio[site]>IREF_PMOSRATIO[22]))  
//                  i = 21;
//               else if((calratio[site]<==IREF_PMOSRATIO[22]) and (calratio[site]>IREF_PMOSRATIO[23]))  
//                  i = 22;
//               else if((calratio[site]<==IREF_PMOSRATIO[23]) and (calratio[site]>IREF_PMOSRATIO[24]))  
//                  i = 23;
//               else if((calratio[site]<==IREF_PMOSRATIO[24]) and (calratio[site]>IREF_PMOSRATIO[25]))  
//                  i = 24;
//               else if((calratio[site]<==IREF_PMOSRATIO[25]) and (calratio[site]>IREF_PMOSRATIO[26]))  
//                  i = 25;
//               else if((calratio[site]<==IREF_PMOSRATIO[26]) and (calratio[site]>IREF_PMOSRATIO[27]))  
//                  i = 26;
//               else if((calratio[site]<==IREF_PMOSRATIO[27]) and (calratio[site]>IREF_PMOSRATIO[28]))  
//                  i = 27;
//               else if((calratio[site]<==IREF_PMOSRATIO[28]) and (calratio[site]>IREF_PMOSRATIO[29]))  
//                  i = 28;
//               else if((calratio[site]<==IREF_PMOSRATIO[29]) and (calratio[site]>IREF_PMOSRATIO[30]))  
//                  i = 29;
//               else if((calratio[site]<==IREF_PMOSRATIO[30]) and (calratio[site]>IREF_PMOSRATIO[31]))  
//                  i = 30;
//               else 
//                  i = 31;
//               
//           trimcode[site] = IREF_PMOSCODE[i];
//           index[site] = i;
//            } 
//            
//            if(tistdscreenprint and debugprint)  
//               cout << "Site:" << site:-5 << " Calc Ratio == " << calratio[site]:-5:3 << 
//                       " Trim Code == " << trimcode[site]:s_hex:-5 << " Index == " << index[site]:-5 << endl;
//         }   /*v_dev_active*/
//   }   /* GetTrimCode_Index_On_Ratio */
//    /*++++++++++++++++*/
//   procedure GetTrimCode_Ratio_On_SftIndex; /* didn"t match any chunk types, FIX */
//   var
//      IntS i;
//   {
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            i = sftindex[j][site];
//            trimcode[site] = IREF_PMOSCODE[i];
//            ratio[site] = IREF_PMOSRATIO[i];
//            if(tistdscreenprint and debugprint)  
//               cout << "Site:" << site:-5 << " Ratio == " << ratio[site]:-5:3 << 
//                       " Trim Code == " << trimcode[site]:s_hex:-5 << " Index == " << i:-5 << endl;
//         } 
//   }   /* GetTrimCode_Ratio_On_SftIndex */
//    /*++++++++++++++++*/
//   procedure DoIMeasure; /* didn"t match any chunk types, FIX */
//   {
//      F021_TurnOff_AllTPADS;
//      F021_Set_TPADS(tcrnum,tcrmode);
//      TIME.Wait(tdelay2);
//      F021_RunTestNumber_PMEX(testnum,maxtime,tmp_results);
//      TIME.Wait(tdelay);
//      F021_Meas_TPAD_PMEX(testpad,tcrnum,tcrmode,llim,ulim,meas_val,meas_results);
//      F021_TurnOff_AllTPADS;
//      Disable(s_pmexit);
//   }       
//    /*++++++++++++++++*/
//   Procedure PrintResultTrimCode; /* didn"t match any chunk types, FIX */
//   var
//      IntS fdlen1,fdlen2,fdlen3,fdlen4,decpt;
//      StringS pstr1,pstr2,pstr3,pstr4,pstr5;
//      StringS unitstr;
//      IntS unitlen;
//      FloatS FloatSvalue;
//      FloatS FloatSvalue;
//   {
//      pstr1 = "------------------------------";  /*30*/
//      pstr2 = "----------";  /*10*/
//      pstr3 = " "; 
//      fdlen1 = 30;
//      fdlen2 = 10;
//      fdlen3 = 10;
//      fdlen4 = 8;
//      decpt  = 2;
//
//      if(GL_PLELL_FORMAT)  
//      {
//         cout << endl;
//         cout << str2:-fdlen1 << pstr3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         {
//            writestring(pstr4,site:1);
//            pstr4 = "Site" + pstr4;
//            cout << pstr4:-fdlen2 << pstr3;
//         } 
//         cout << endl;
//         
//         cout << pstr1 << pstr3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            cout << pstr2 << pstr3;
//         cout << endl;
//
//         pstr5 = "PMOS Iref Pre";
//         cout << pstr5:-fdlen1 << pstr3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               trealvalue = ival_pre[bank][loop][site];
//               GetTreal_Unit_Info(trealvalue,realvalue,unitlen,unitstr);
//               cout << realvalue:(fdlen3-unitlen):decpt << unitstr << pstr3;
//            }
//            else
//               cout << "X":fdlen3 << pstr3;
//         cout << endl;
//
//         pstr5 = "Calculate Ratio";
//         cout << pstr5:-fdlen1 << pstr3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               cout << ratio_pre[bank][loop][site]:fdlen3:decpt << pstr3);
//            else
//               cout << "X":fdlen3 << pstr3;
//         cout << endl;
//
//         pstr5 = "Soft Trim Ratio";
//         cout << pstr5:-fdlen1 << pstr3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               cout << ratio_pst[bank][loop][site]:fdlen3:decpt << pstr3);
//            else
//               cout << "X":fdlen3 << pstr3;
//         cout << endl;
//
//         pstr5 = "Soft Trim Code";
//         cout << pstr5:-fdlen1 << pstr3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               cout << tcode_pst[bank][loop][site]:fdlen3 << pstr3);
//            else
//               cout << "X":fdlen3 << pstr3;
//         cout << endl;
//
//         pstr5 = "Iref Soft";
//         cout << pstr5:-fdlen1 << pstr3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               trealvalue = ival_pst[bank][loop][site];
//               GetTreal_Unit_Info(trealvalue,realvalue,unitlen,unitstr);
//               cout << realvalue:(fdlen3-unitlen):decpt << unitstr << pstr3;
//            }
//            else
//               cout << "X":fdlen3 << pstr3;
//         cout << endl;
//
//         pstr5 = "Target Iref";
//         cout << pstr5:-fdlen1 << pstr3;
//         trealvalue = ITrim_Target;
//         GetTreal_Unit_Info(trealvalue,realvalue,unitlen,unitstr);
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               cout << realvalue:(fdlen3-unitlen):decpt << unitstr << pstr3);
//            else
//               cout << "X":fdlen3 << pstr3;
//         cout << endl;
//
//         pstr5 = "Trim Result";
//         cout << pstr5:-fdlen1 << pstr3;
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               if(trim_valid[site])  
//                  cout << "PASS":fdlen3 << pstr3);
//               else
//                  cout << "FAIL**":fdlen3 << pstr3;
//            }
//            else
//               cout << "X":fdlen3 << pstr3;
//         cout << endl;
//
//         cout << endl;
//      }  /*if paral_format*/
//      else
//      {  /*serial_format*/
//         cout << endl;
//         cout << "TestName ":-fdlen1 << pstr3 << "Iref Pre":-fdlen2 << pstr3 << "Calc Ratio" << pstr3 << 
//                 "Trim Ratio" << pstr3 << "Trim Code" << pstr3 << "Iref Pst" << pstr3 << "TargetIref" << pstr3 << "TrimResult" << endl;
//         cout << pstr1 << pstr3 << pstr2 << pstr3 << pstr2 << pstr3 << pstr2 << pstr3 << pstr2 << pstr3 << pstr2 << pstr3 << pstr2 << pstr3 << pstr2 << endl;
//
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               writestring(pstr4,site:1);
//               pstr4 = "_Site" + pstr4;
//               pstr4 = str2 + pstr4;
//               cout << pstr4:-fdlen1 << pstr3;
//               trealvalue = ival_pre[bank][loop][site];
//               GetTreal_Unit_Info(trealvalue,realvalue,unitlen,unitstr);
//               cout << realvalue:(fdlen3-unitlen):decpt << unitstr << pstr3 << 
//                     ratio_pre[bank][loop][site]:fdlen3:decpt << pstr3 << ratio_pst[bank][loop][site]:fdlen3:decpt << pstr3 << 
//                     tcode_pst[bank][loop][site]:fdlen3 << pstr3;
//
//               trealvalue = ival_pst[bank][loop][site];
//               GetTreal_Unit_Info(trealvalue,realvalue,unitlen,unitstr);
//               cout << realvalue:(fdlen3-unitlen):decpt << unitstr << pstr3;
//               trealvalue = ITrim_Target;
//               GetTreal_Unit_Info(trealvalue,realvalue,unitlen,unitstr);
//               cout << realvalue:(fdlen3-unitlen):decpt << unitstr << pstr3;
//
//               if(trim_valid[site])  
//                  cout << "PASS":fdlen3);
//               else
//                  cout << "FAIL**":fdlen3 << endl;
//            } 
//         cout << endl;
//      } 
//   }   /* PrintResultTrimCode */
//       /*++++++++++++++++*/
//{
//   if(v_any_dev_active)  
//   {
//      maxtime = GL_F021_PARAM_MAXTIME;
//      tdelay  = 10ms;
//      tdelay2 = 2ms;
//
//      testpad = FLTP2;
//      tnum_ipmos[EVENNUM] = TNUM_BANK_IPMOS_READ_EVEN;
//      tnum_ipmos[ODDNUM] = TNUM_BANK_IPMOS_READ_ODD;
//      tnum_irefrd[EVENNUM] = TNUM_BANK_IREF_READ_EVEN;
//      tnum_irefrd[ODDNUM] = TNUM_BANK_IREF_READ_ODD;
//      tnum_irefev[EVENNUM] = TNUM_BANK_IREF_EVFY_EVEN;
//      tnum_irefev[ODDNUM] = TNUM_BANK_IREF_EVFY_ODD;
//
//      Ifactor = IPMOS_Trim_Target-(IPMOS_Trim_Target*IPMOS_Trim_Toler);
//
//      timernstart(ttimer1);
//
//      fl_testname = IrefPMOS_Trim_Test;
//      TestOpen(fl_testname);
//      
//      savesites = V_dev_active;
//      final_results = V_dev_active;
//      trim_valid = V_dev_active;
//      activesites = V_dev_active;
//
//      debugprint = TI_FlashDebug;
//      iteration  = MAXITER;
//
//      minloop = EVENNUM;
//      maxloop = ODDNUM;
//
//       /*init*/
//      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//      {
//         for (loop = minloop;loop <= maxloop;loop++)
//         {
//            ival_pre[bank][loop] = 0.0uA;
//            ival_pst[bank][loop] = 0.0uA;
//            ratio_pre[bank][loop] = 0.0;
//            ratio_pst[bank][loop] = 0.0;
//            tcode_pre[bank][loop] = 0;
//            tcode_pst[bank][loop] = 0;
//            IPMOS_TRIMCODE_SAVED[bank][loop] = 0;
//            for (j = MINITER;j <= iteration;j++)
//               sftival[bank][loop][j] = 0.0;
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//                  trim_code_str[bank][loop][site] = "00000";
//         }   /*loop*/
//      } 
//
//      if(GL_BANKTYPE==FLESBANK)  
//         maxloop = EVENNUM;
//
//      if(TI_FlashDebug)  
//         PrintHeaderParam(GL_PLELL_FORMAT);
//      
//      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//      {
//          /*enable site with bank to trim*/
//         sitetotrim = BANK_TO_PMOS_TRIM[bank];
//         ArrayAndBoolean(sitetotrim,sitetotrim,activesites,v_sites);
//         devsetholdstates(sitetotrim);
//         logsites = v_dev_active;
//
//          /*+++++*/
//         if(v_any_dev_active)  
//         {
//            writestring(str1,bank:1);
//
//            for (loop = minloop;loop <= maxloop;loop++) /*even than odd*/
//            {
//               testnum = tnum_ipmos[loop]+(bank<<4);
//               if(loop==0)  
//                  str3 = "_EVN";
//               else
//                  str3 = "_ODD";
//
//               str2 = "IPMOS_Pre_B" + str1;
//               str4 = str2 + str3;
//               
//               if(tistdscreenprint and debugprint)  
//                  cout << "Bank" << bank:-5 << "Loop" << loop:-5 << "Pre Trim" << endl;
//               
//                /*-- calculate ratio --*/
//               tcrnum  = 40;
//               tcrmode = ErsMode;  /*actual mode is rd*/
//               testpad = FLTP2;
//               llim    = TCR.TP2_LLim[TCRnum][TCRMode];
//               ulim    = TCR.TP2_ULim[TCRnum][TCRMode];
//               DoIMeasure;  /*store in meas_val*/
//               if(TI_FlashDebug)  
//                  PrintResultParam(str4,testnum,meas_results,llim,ulim,meas_val,GL_PLELL_FORMAT);
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                     calratio[site] = single(meas_val[site]/Ifactor);
//
//               GetTrimCode_Index_On_Ratio;  /*store code in trimcode, look-up-table index*/
//
//                /*-- store pre info --*/
//               ival_pre[bank][loop] = meas_val;
//               ratio_pre[bank][loop] = calratio;
//               tcode_pre[bank][loop] = trimcode;
//               index_pre[bank][loop] = index;
//
//               logstr = str4;  /*IPMOS_Pre_Bx_EVN*/
//               TWTRealToRealMS(meas_val,realval,unitval);
//               TWPDLDataLogRealVariable(logstr, unitval,realval,TWMinimumData);
//
//               logstr = str4 + "_CRATIO";  /*IPMOS_Pre_Bx_EVN_CRATIO*/
//               unitval = NoUnits;
//               TWPDLDataLogRealVariable(logstr, unitval,calratio,TWMinimumData);
//               
//                /*-- do soft --*/
//               sftindex[MINITER] = index;
//               for (i = MINITER+1;i <= (iteration-1);i++)
//                  ArrayAddIntegerValue(sftindex[i],sftindex[i-1],1,v_sites);
//               ArraySubIntegerValue(sftindex[iteration],sftindex[MINITER],1,v_sites);
//
//               if(loop==0)  
//               {
//                  even_ena = true;
//                  odd_ena  = false;
//               }
//               else
//               {
//                  even_ena = false;
//                  odd_ena  = true;
//               } 
//
//               enasites = v_dev_active;
//               
//               for (j = MINITER;j <= iteration;j++)
//               {
//                  sbool1 = false;
//                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                     if(v_dev_active[site])  
//                        if((sftindex[j][site]<0) or (sftindex[j][site]>31))  
//                        {
//                           sbool1 = true;
//                           devsetholdstate(site,false);  /*skip site w/ out of bound index*/
//                        } 
//
//                  if(v_any_dev_active)  
//                  {
//                     if(tistdscreenprint and debugprint)  
//                        cout << "Soft Trim -- Bank" << bank:-5 << "Loop" << loop:-5 << "Iteration" << j:-5 << endl;
//                     
//                     GetTrimCode_Ratio_On_SftIndex;   /*store code in trimcode, ratio*/
//                     orgtrimcode = trimcode;
//
//                     if(loop==0)  
//                        for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                           if(v_dev_active[site])  
//                              trimcode[site] = trimcode[site]<<8;   /*format even*/
//                     
//                     if((bank mod 2) == 0)  
//                     {
//                        msw_val = trimcode;   /*bank0*/
//                        lsw_val = 0;      /*bank1*/
//                     }
//                     else
//                     {
//                        msw_val = 0;
//                        lsw_val = trimcode;
//                     } 
//
//                     RAM_Upload_PMOS_SoftTrim_Bank(bank,even_ena,odd_ena,msw_val,lsw_val);
//                     
//                     writestring(str5,j:1);
//                     str5 = "_" + str5;
//                     
//                     switch(trimopt) {
//                       case TRIMOPT_PMOS :  
//                          str4 = "IPMOS_SFT_B" + str1;
//                          tcrnum  = 40;
//                          tcrmode = ErsMode;  /*actual mode is rd*/
//                          testnum = tnum_ipmos[loop]+(bank<<4);
//                          ITrim_Target = IPMOS_Trim_Target;
//                          ITrim_LLim   = IPMOS_Trim_LLim;
//                          ITrim_ULim   = IPMOS_Trim_ULim;
//                        break; 
//                       case TRIMOPT_IRD  :  
//                          str4 = "IREFRD_SFT_B" + str1;
//                          tcrnum  = 25;
//                          tcrmode = ReadMode;
//                          testnum = tnum_irefrd[loop]+(bank<<4);
//                          ITrim_Target = IrefRd_Trim_Target;
//                          ITrim_LLim   = IrefRd_Trim_LLim;
//                          ITrim_ULim   = IrefRd_Trim_ULim;
//                        break; 
//                       case TRIMOPT_IEV  :  
//                          str4 = "IREFEV_SFT_B" + str1;
//                          tcrnum  = 25;
//                          tcrmode = EvfyMode;
//                          testnum = tnum_irefev[loop]+(bank<<4);
//                          ITrim_Target = IrefEv_Trim_Target;
//                          ITrim_LLim   = IrefEv_Trim_LLim;
//                          ITrim_ULim   = IrefEv_Trim_ULim;
//                        break; 
//                       default:  
//                          str4 = "IPMOS_SFT_B" + str1;
//                          tcrnum  = 40;
//                          tcrmode = ErsMode;  /*actual mode is rd*/
//                          testnum = tnum_ipmos[loop]+(bank<<4);
//                          ITrim_Target = IPMOS_Trim_Target;
//                          ITrim_LLim   = IPMOS_Trim_LLim;
//                          ITrim_ULim   = IPMOS_Trim_ULim;
//                        break; 
//                     }   /* case */
//
//                     llim    = TCR.TP2_LLim[TCRnum][TCRMode];
//                     ulim    = TCR.TP2_ULim[TCRnum][TCRMode];
//                          
//                     str4 = str4 + str3;
//                     str4 = str4 + str5;
//                     
//                     DoIMeasure;
//                     if(TI_FlashDebug)  
//                        PrintResultParam(str4,testnum,meas_results,llim,ulim,meas_val,GL_PLELL_FORMAT);
//                     sftival[bank][loop][j] = meas_val;
//                     
//                     logstr = str4;  /*IPMOS_SFT_Bx_EVN_x*/
//                     TWTRealToRealMS(meas_val,realval,unitval);
//                     TWPDLDataLogRealVariable(logstr, unitval,realval,TWMinimumData);
//
//                     logstr = str4 + "_RATIO";  /*IPMOS_SFT_Bx_EVN_x_RATIO*/
//                     unitval = NoUnits;
//                     TWPDLDataLogRealVariable(logstr, unitval,ratio,TWMinimumData);
//
//                     logstr = str4 + "_TC";   /*IPMOS_SFT_Bx_EVN_x_TC*/
//                     TWPDLDataLogVariable(logstr,orgtrimcode,TWMinimumData);
//
//                     for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                        if(v_dev_active[site])  
//                        {
//                           tmpdelta[site] = abs(meas_val[site]-ITrim_Target);
//                           if(j==MINITER)  
//                           {
//                              delta[site] = tmpdelta[site];
//                              tmptrimindex[site] = j;
//                              tmptrimcode[site] = trimcode[site];
//                              tmptrimratio[site] = ratio[site];
//                           } 
//                           
//                           if(tmpdelta[site] < delta[site])  
//                           {
//                              delta[site] = tmpdelta[site];
//                              tmptrimindex[site] = j;
//                              tmptrimcode[site] = trimcode[site];
//                              tmptrimratio[site] = ratio[site];
//                           } 
//                        } 
//
//                      /*collect data*/
//                      /*KChau 03/10/11 -- uncomment these out if want to collect data*/
//                      /* ...
//                      case trimopt of
//                        TRIMOPT_PMOS : begin
//                           {irefRd}
//                           logstr := concat("IREFRD_SFT_B",str1);
//                           logstr := concat(logstr,str3); {even/odd}
//                           logstr := concat(logstr,str5); {iteration}
//                           tcrnum  := 25;
//                           tcrmode := ReadMode;
//                           testnum := tnum_irefrd[loop]+(bank<<4);
//                           llim    := TCR.TP2_LLim[TCRnum,TCRMode];
//                           ulim    := TCR.TP2_ULim[TCRnum,TCRMode];
//                           DoIMeasure;
//                           if(TI_FlashDebug) then
//                              PrintResultParam(logstr,testnum,meas_results,llim,ulim,meas_val,GL_PLELL_FORMAT);
//                           TWTRealToRealMS(meas_val,realval,unitval);
//                           TWPDLDatalogRealVariableMS(logstr, unitval,realval,TWMinimumData);
//                           {irefEv}
//                           logstr := concat("IREFEV_SFT_B",str1);
//                           logstr := concat(logstr,str3); {even/odd}
//                           logstr := concat(logstr,str5); {iteration}
//                           tcrnum  := 25;
//                           tcrmode := EvfyMode;
//                           testnum := tnum_irefev[loop]+(bank<<4);
//                           llim    := TCR.TP2_LLim[TCRnum,TCRMode];
//                           ulim    := TCR.TP2_ULim[TCRnum,TCRMode];
//                           DoIMeasure;
//                           if(TI_FlashDebug) then
//                              PrintResultParam(logstr,testnum,meas_results,llim,ulim,meas_val,GL_PLELL_FORMAT);
//                           TWTRealToRealMS(meas_val,realval,unitval);
//                           TWPDLDatalogRealVariableMS(logstr, unitval,realval,TWMinimumData);
//                        end;
//                        TRIMOPT_IRD  : begin
//                           {ipmos}
//                           logstr := concat("IPMOS_SFT_B",str1);
//                           logstr := concat(logstr,str3); {even/odd}
//                           logstr := concat(logstr,str5); {iteration}
//                           tcrnum  := 40;
//                           tcrmode := ErsMode; {actual mode is rd}
//                           testnum := tnum_ipmos[loop]+(bank<<4);
//                           llim    := TCR.TP2_LLim[TCRnum,TCRMode];
//                           ulim    := TCR.TP2_ULim[TCRnum,TCRMode];
//                           DoIMeasure;
//                           if(TI_FlashDebug) then
//                              PrintResultParam(logstr,testnum,meas_results,llim,ulim,meas_val,GL_PLELL_FORMAT);
//                           TWTRealToRealMS(meas_val,realval,unitval);
//                           TWPDLDatalogRealVariableMS(logstr, unitval,realval,TWMinimumData);
//                           {irefEv}
//                           logstr := concat("IREFEV_SFT_B",str1);
//                           logstr := concat(logstr,str3); {even/odd}
//                           logstr := concat(logstr,str5); {iteration}
//                           tcrnum  := 25;
//                           tcrmode := EvfyMode;
//                           testnum := tnum_irefev[loop]+(bank<<4);
//                           llim    := TCR.TP2_LLim[TCRnum,TCRMode];
//                           ulim    := TCR.TP2_ULim[TCRnum,TCRMode];
//                           DoIMeasure;
//                           if(TI_FlashDebug) then
//                              PrintResultParam(logstr,testnum,meas_results,llim,ulim,meas_val,GL_PLELL_FORMAT);
//                           TWTRealToRealMS(meas_val,realval,unitval);
//                           TWPDLDatalogRealVariableMS(logstr, unitval,realval,TWMinimumData);
//                        end;
//                        TRIMOPT_IEV  : begin
//                           {ipmos}
//                           logstr := concat("IPMOS_SFT_B",str1);
//                           logstr := concat(logstr,str3); {even/odd}
//                           logstr := concat(logstr,str5); {iteration}
//                           tcrnum  := 40;
//                           tcrmode := ErsMode; {actual mode is rd}
//                           testnum := tnum_ipmos[loop]+(bank<<4);
//                           llim    := TCR.TP2_LLim[TCRnum,TCRMode];
//                           ulim    := TCR.TP2_ULim[TCRnum,TCRMode];
//                           DoIMeasure;
//                           if(TI_FlashDebug) then
//                              PrintResultParam(logstr,testnum,meas_results,llim,ulim,meas_val,GL_PLELL_FORMAT);
//                           TWTRealToRealMS(meas_val,realval,unitval);
//                           TWPDLDatalogRealVariableMS(logstr, unitval,realval,TWMinimumData);
//                           {irefRd}
//                           logstr := concat("IREFRD_SFT_B",str1);
//                           logstr := concat(logstr,str3); {even/odd}
//                           logstr := concat(logstr,str5); {iteration}
//                           tcrnum  := 25;
//                           tcrmode := ReadMode;
//                           testnum := tnum_irefrd[loop]+(bank<<4);
//                           llim    := TCR.TP2_LLim[TCRnum,TCRMode];
//                           ulim    := TCR.TP2_ULim[TCRnum,TCRMode];
//                           DoIMeasure;
//                           if(TI_FlashDebug) then
//                              PrintResultParam(logstr,testnum,meas_results,llim,ulim,meas_val,GL_PLELL_FORMAT);
//                           TWTRealToRealMS(meas_val,realval,unitval);
//                           TWPDLDatalogRealVariableMS(logstr, unitval,realval,TWMinimumData);
//                        end;
//                      end; { case } {collect data}
// 
//                      ... */
//               
//                     RAM_Clear_PMOS_SoftTrim_Bank(bank);
//                  }   /*if v_any_dev_active*/
//                  
//                  if(sbool1)  
//                     Devsetholdstates(enasites);
//               }   /*for j iteration*/
//
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                  {
//                     j = tmptrimindex[site];
//                     ival_pst[bank][loop][site]  = sftival[bank][loop][j][site];
//                     tmpdelta[site] = ival_pst[bank][loop][site];
//                     if(trimopt==TRIMOPT_PMOS)  
//                     {
//                        if(abs(ival_pst[bank][loop][site]) < abs(ITrim_ULim))  
//                           trim_valid[site] = false;
//                     }
//                     else
//                     {
//                        if(abs(ival_pst[bank][loop][site]) < abs(ITrim_LLim))  
//                           trim_valid[site] = false;
//                     } 
//
//                     if(loop==0)  
//                        tmptrimcode[site] = tmptrimcode[site] div 256;
//
//                     tcode_pst[bank][loop][site] = tmptrimcode[site];
//                     IPMOS_TRIMCODE_SAVED[bank][loop][site] = tmptrimcode[site];  /*save for later use*/
//                     ratio_pst[bank][loop][site] = tmptrimratio[site];
//                     k = sftindex[j][site];
//                     index_pst[bank][loop][site] = k;  /*sftindex[j,site];*/
//                     trim_code_str[bank][loop][site] = IREF_PMOSCODE_STR[k];
//
//                     if(tistdscreenprint and debugprint)  
//                        cout << "Site" << site:-5 << "Bank" << bank:-5 << "Loop" << loop:-5 << 
//                                " Pre IVal== " << ival_pre[bank][loop][site]:-6:3 << 
//                                " CalcRatio== " << ratio_pre[bank][loop][site]:-6:2 << 
//                                " TrimCode== " << tcode_pre[bank][loop][site]:s_hex:-5 << 
//                                " --  Final Soft IVal== " << ival_pst[bank][loop][site]:-6:3 << 
//                                " Ratio== " << ratio_pst[bank][loop][site]:-6:2 << 
//                                " TrimCode== " << tcode_pst[bank][loop][site]:s_hex:-5 << 
//                                " ** " << trim_valid[site] << " ** " << endl;
//                  } 
//
//               switch(trimopt) {
//                 case TRIMOPT_PMOS : str4 = "IPMOS_TRIM_B" + str1;
//                 case TRIMOPT_IRD  : str4 = "IrefRd_TRIM_B" + str1;
//                 case TRIMOPT_IEV  : str4 = "IrefEv_TRIM_B" + str1;
//                 default: str4 = "IPMOS_TRIM_B" + str1;
//               }   /* case */
//               
//               str4 = str4 + str3;
//
//               logstr = str4;  /*IPMOS_TRIM_Bx_EVN*/
//               TWTRealToRealMS(tmpdelta,realval,unitval);
//               TWPDLDataLogRealVariable(logstr, unitval,realval,TWMinimumData);
//               
//               logstr = str4 + "_RATIO";  /*IPMOS_TRIM_Bx_EVN_RATIO*/
//               unitval = NoUnits;
//               TWPDLDataLogRealVariable(logstr, unitval,tmptrimratio,TWMinimumData);
//
//               logstr = str4 + "_TC";   /*IPMOS_TRIM_Bx_EVN_TC*/
//               TWPDLDataLogVariable(logstr,tmptrimcode,TWMinimumData);
//
//
//               if(tistdscreenprint)  
//               {
//                  str2 = "IPMOS_TRIM_B" + str1;
//                  str2 = str2 + str3;
//                  PrintResultTrimCode;
//               } 
//                               /*-- do soft --*/
//            }   /*for loop*/
//
//            ArrayAndBoolean(final_results,final_results,trim_valid,v_sites);
//            ArrayAndBoolean(logsites,logsites,trim_valid,v_sites);
//
//            if(not ArrayCompareBoolean(logsites,sitetotrim,v_sites))  
//            {
//               logstr = "IPMOS_TRIM_B" + str1;
//               F021_Log_FailPat_To_TW(logstr,tmp_results,fl_testname);
//            } 
//
//            if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//            {
//               ArrayAndBoolean(activesites,activesites,final_results,v_sites);
//               Devsetholdstates(final_results);
//            } 
//
//             /*format & store efuse string per bank bit31:0*/
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  tmpefstr = BANKEF_BIT29_31 + trim_code_str[bank][1][site];  /*odd*/
//                  tmpefstr = tmpefstr + BANKEF_BIT10_23_BANKNUM[bank];
//                  tmpefstr = tmpefstr + trim_code_str[bank][0][site];  /*even*/
//                  tmpefstr = tmpefstr + BANKEF_BIT0_4;
//                  IREF_PMOSTRIMCODE_STR[bank][site] = tmpefstr;
//               } 
//
//         }   /*if v_any_dev_active*/
//          /*+++++*/
//
//      }   /*for bank*/
//
//      Devsetholdstates(savesites);
//      
//      ResultsRecordActive(final_results, S_NULL);
//      TestClose;
//
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site] and trim_valid[site])  
//            SITE_TO_FTRIM[site] = true;
//      
//      ttimer1 = timernread(ttimer1);
//      tt_timer = ttimer1;
//
//      writestring(str1,fl_testname);
//      i = len(str1);
//      writestring(str1,mid(str1,2,i-6));  /*remove _Test*/
//
//      str4 = str1 + "_TTT";
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(str4, unitval,realval,TWMinimumData);
//      
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//         Devsetholdstates(final_results);
//
//      if(tistdscreenprint)  
//      {
//         PrintResultBool(str1,tnum_ipmos[0],final_results,GL_PLELL_FORMAT);
//         cout << "   TT " << ttimer1 << endl;
//         cout << endl;         
//      } 
//      
//   }   /*if v_any_dev_active*/
//
//   F021_IPMOS_NMOS_SoftTrim_func = v_any_dev_active;
//} 
//      
//   
//void TL_Mod_OTP_PMOS_SoftTrim()
//{
//   const  DATA_TARG_ARB = 0x0000AA00;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS IND_W8 = 64; 
//   const IntS IND_W9 = 72; 
//
//   IntS site,tnum,bank,count,loop,index;
//   IntS numword,numword_max,row,wdnum;
//   IntS addr_msw,addr_lsw,addr_loc;
//   BoolS debugprint;
//   BoolM savesites,tmp_results;
//   IntM1D log1val(128),idval(128),vtval(128),log3val(128);
//   FloatS maxtime;
//   IntM tdata,tdata2,lsw_data,msw_data;
//   StringS str1,str2,str3;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint)  
//         cout << "+++++ TL_Mod_OTP_PMOS_SoftTrim +++++" << endl;
//
//       /*read all OTP data contents*/
//      numword = 0;
//      numword_max = 127;
//      maxtime = GL_F021_MAXTIME;
//      debugprint = false;
//
//       /*do pmos soft trim. value store in IPMOS_TRIMCODE_SAVED[bank,loop,site], here loop0=even,loop1=odd*/
//      F021_IPMOS_SoftTrim_func;
//
//      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//      {
//          /*read log1 otp*/
//         tnum = TNUM_OTP_RD_LOG1_MBOX + (bank<<4);
//         F021_RunTestNumber(tnum,maxtime,spare_mstreal1,tmp_results);
//         
//         if(GL_DO_ESDA_WITH_SCRAM)  
//            Get_Flash_MBoxSpace_OTP_SCRAM;
//
//         if(tistdscreenprint and debugprint)  
//            PrintHeaderBool(GL_PLELL_FORMAT);            
//
//         wdnum = 0;
//         row   = 0;
//         for (count = numword;count <= numword_max;count++)
//         {
//            Get_MBoxSpace_RowX_WdX(row,wdnum,tdata);   /*wdnum of 0=msw, wdnum of 1=lsw*/
//            log1val[count] = tdata;
//            if(tistdscreenprint and debugprint)  
//            {
//               writestring(str2,row:1);
//               str2 = "Row" + str2;
//               writestring(str3,wdnum:1);
//               str3 = "Wd" + str3;
//               str1 = str2 + "_";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,tdata,0,0,GL_PLELL_FORMAT);
//            } 
//            wdnum = wdnum+1;
//            if((wdnum mod 8)==0)  
//            {
//               wdnum = 0;
//               row   = row+1;
//            } 
//         }   /*for count*/
//
//          /*update w8/w9 w/ pmos trim val*/
//         index = IND_W8;
//         for (loop = 0;loop <= 1;loop++)
//         {
//            arrayandintegervalue(log1val[index],log1val[index],0xFF07,v_sites);  /*bit31:16*/
//            arraymultintegervalue(tdata,IPMOS_TRIMCODE_SAVED[bank][loop],8,v_sites);  /*<<3*/
//            arrayaddinteger(log1val[index],log1val[index],tdata,v_sites);
//            
//            index = index+1;
//            arrayandintegervalue(log1val[index],log1val[index],0xFC1F,v_sites);  /*bit15:0*/
//            arraymultintegervalue(tdata,IPMOS_TRIMCODE_SAVED[bank][loop],32,v_sites);  /*<<5*/
//            arrayaddinteger(log1val[index],log1val[index],tdata,v_sites);
//            
//            index = index+1;
//            arrayandintegervalue(log1val[index],log1val[index],0xFFF0,v_sites);  /*bit63:48*/
//            arraydivintegervalue(tdata,IPMOS_TRIMCODE_SAVED[bank][loop],2,v_sites);  /*>>1 to replace bit51:48*/
//            arrayaddinteger(log1val[index],log1val[index],tdata,v_sites);
//            
//            
//            index = index+1;
//            arrayandintegervalue(log1val[index],log1val[index],0x7FFF,v_sites);  /*bit47:32*/
//            tdata = IPMOS_TRIMCODE_SAVED[bank][loop];
//            arrayandintegervalue(tdata,tdata,0x01,v_sites);   /*extract 1 lsb*/
//            arraymultintegervalue(tdata,tdata,32768,v_sites);  /*<<15 to replace bit47*/
//            arrayaddinteger(log1val[index],log1val[index],tdata,v_sites);
//            
//            index = index+1;
//             /*unused so no modify*/
//             /*
//              arrayandintegervalue(log1val[index],log1val[index],0x07FC,v_sites); {bit95:80*/
//            arraymultintegervalue(tdata,IPMOS_TRIMCODE_SAVED[bank][loop],2048,v_sites);  /*<<11 to replace bit95:91*/
//            arraydivintegervalue(tdata2,IPMOS_TRIMCODE_SAVED[bank][loop],8,v_sites);  /*>>3 to replace bit81:80*/
//            arrayaddinteger(log1val[index],log1val[index],tdata,v_sites);
//            arrayaddinteger(log1val[index],log1val[index],tdata2,v_sites);
//            }
//            
//            index = index+1;
//            arrayandintegervalue(log1val[index],log1val[index],0x1FFF,v_sites);  /*bit79:64*/
//            tdata = IPMOS_TRIMCODE_SAVED[bank][loop];
//            arrayandintegervalue(tdata,tdata,0x07,v_sites);   /*extract 3 lsb*/
//            arraymultintegervalue(tdata,tdata,8192,v_sites);  /*<<13 to replace bit79:77*/
//            arrayaddinteger(log1val[index],log1val[index],tdata,v_sites);
//            
//            index = index+1;
//            arrayandintegervalue(log1val[index],log1val[index],0xF07F,v_sites);  /*bit127:112*/
//            arraymultintegervalue(tdata,IPMOS_TRIMCODE_SAVED[bank][loop],128,v_sites);  /*<<7 to replace bit123:119*/
//            arrayaddinteger(log1val[index],log1val[index],tdata,v_sites);
//            
//            index = index+1;
//             /*unused so no modify*/
//             /*
//              arrayandintegervalue(log1val[index],log1val[index],0xF07F,v_sites); {bit111:96*/
//            arraymultintegervalue(tdata,IPMOS_TRIMCODE_SAVED[bank][loop],512,v_sites);  /*<<9 to replace bit109:105*/
//            arrayaddinteger(log1val[index],log1val[index],tdata,v_sites);
//            }
//
//            index = index+1;
//         } 
//         
//            
//          /*read id otp*/
//         tnum = TNUM_OTP_RD_ID_MBOX + (bank<<4);
//         F021_RunTestNumber(tnum,maxtime,spare_mstreal1,tmp_results);
//
//         if(GL_DO_ESDA_WITH_SCRAM)  
//            Get_Flash_MBoxSpace_OTP_SCRAM;
//
//         wdnum = 0;
//         row   = 0;
//         for (count = numword;count <= numword_max;count++)
//         {
//            Get_MBoxSpace_RowX_WdX(row,wdnum,tdata);
//            idval[count] = tdata;
//            wdnum = wdnum+1;
//            if((wdnum mod 8)==0)  
//            {
//               wdnum = 0;
//               row   = row+1;
//            } 
//         }   /*for count*/
//            
//          /*read vt/bcc otp*/
//         tnum = TNUM_OTP_RD_VT_MBOX + (bank<<4);
//         F021_RunTestNumber(tnum,maxtime,spare_mstreal1,tmp_results);
//
//         if(GL_DO_ESDA_WITH_SCRAM)  
//            Get_Flash_MBoxSpace_OTP_SCRAM;
//
//         wdnum = 0;
//         row   = 0;
//         for (count = numword;count <= numword_max;count++)
//         {
//            Get_MBoxSpace_RowX_WdX(row,wdnum,tdata);
//            vtval[count] = tdata;
//            wdnum = wdnum+1;
//            if((wdnum mod 8)==0)  
//            {
//               wdnum = 0;
//               row   = row+1;
//            } 
//         }   /*for count*/
//            
//          /*read log3 otp*/
//         tnum = TNUM_OTP_RD_LOG3_MBOX + (bank<<4);
//         F021_RunTestNumber(tnum,maxtime,spare_mstreal1,tmp_results);
//
//         if(GL_DO_ESDA_WITH_SCRAM)  
//            Get_Flash_MBoxSpace_OTP_SCRAM;
//
//         wdnum = 0;
//         row   = 0;
//         for (count = numword;count <= numword_max;count++)
//         {
//            Get_MBoxSpace_RowX_WdX(row,wdnum,tdata);
//            log3val[count] = tdata;
//            wdnum = wdnum+1;
//            if((wdnum mod 8)==0)  
//            {
//               wdnum = 0;
//               row   = row+1;
//            } 
//         }   /*for count*/
//
//
//          /*erase otp*/
//         tnum = TNUM_OTP_ERS_PRECON_SW+(bank<<4);
//         F021_RunTestNumber(tnum,maxtime,spare_mstreal1,tmp_results);
//         
//          /*refresh otp*/
//         for (loop = 0;loop <= 3;loop++)
//         {
//            addr_msw = ADDR_TIOTP_HI[bank];
//            addr_lsw = ADDR_TIOTP_LO[bank]+(loop*0x100);
//            TL_SetARBADDR(addr_msw,addr_lsw);
//            addr_msw = 0;
//            addr_lsw = (numword_max+1)*2;
//            TL_SetARBLENGTH(addr_msw,addr_lsw);
//            
//            tnum = TNUM_BANK_PROG_SM+DATA_TARG_ARB+(bank<<4);
//            addr_loc = ADDR_RAM_MAILBOX;
//            msw_data = 0x1234;  /*msword*/
//            lsw_data = numword_max+1;  /*lsword*/
//            WriteRamContentDec_32Bit(addr_loc,lsw_data,true,msw_data,true,true);
//            addr_loc = addr_loc+ADDR_RAM_INC;
//            
//            for count = numword to numword_max by 2 do
//            {
//               switch(loop) {
//                 case 0 :  
//                        msw_data = log1val[count];
//                        lsw_data = log1val[count+1];
//                      break; 
//                 case 1 :  
//                        msw_data = idval[count];
//                        lsw_data = idval[count+1];
//                      break; 
//                 case 2 :  
//                        msw_data = vtval[count];
//                        lsw_data = vtval[count+1];
//                      break; 
//                 case 3 :  
//                        msw_data = log3val[count];
//                        lsw_data = log3val[count+1];
//                      break; 
//               }   /* case */
//                 
//               WriteRamContentDec_32Bit(addr_loc,lsw_data,true,msw_data,true,true);
//               addr_loc = addr_loc+ADDR_RAM_INC;
//            }   /*for count*/
//
//            F021_RunTestNumber(tnum,maxtime,spare_mstreal1,tmp_results);
//            TL_SetARBADDR(0,0);
//            TL_SetARBLENGTH(0,0);
//         }   /*for loop*/
//      }   /*for bank*/
//
//
//   } 
//}   /* TL_Mod_OTP_PMOS_SoftTrim */
//   
//      
// /*added for fake repair*/
//void RAM_Upload_FakeRepair(IntS bankcount)
//{
//   IntS site,bank,count,sblk,eblk,i,j;
//   IntS index,sindex,eindex,addr,saddr;
//   IntM msw_data,lsw_data;
//   BoolS bcd_format,hexvalue;
//   BoolS debugprint,logena;
//   StringM logstr;
//   StringS str1,str2,str3,str4,str5,str6;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ RAM_Upload_FakeRepair +++++" << endl;
//
//      debugprint  = TIStdscreenprint and TI_FlashDebug and TIPrintPass;
//      bcd_format  = true;
//      hexvalue    = true;
//      saddr       = ADDR_RAM_REPAIR_SOL;
//      sblk        = 0;  /*repair by block so start @0*/
//      sindex      = 0;  /*doing 4 repair per block*/
//      eindex      = 3;
//      j = 0;
//      msw_data = 0;
//
//       /*clear 16 rows of ram esda log space*/
//      addr = saddr;
//      for (i = 0;i <= 63;i++)
//      {
//         WriteRamContentDec_32Bit(addr,msw_data,hexvalue,msw_data,hexvalue,bcd_format);
//         addr = addr+ADDR_RAM_INC;
//      } 
//
//      logena = true;
//      if(logena)  
//         str1 = "REPSOL_";
//
//      for (bank = bankcount;bank <= bankcount;bank++) /*0 to F021_Flash.MAXBANK do*/
//      {
//         addr = saddr;
//         eblk = F021_Flash.MAXBLOCK[bank];
//         if(logena)  
//         {
//            writestring(str2,bank:1);
//            str2 = "B" + str2;
//         } 
//
//         for (count = sblk;count <= eblk;count++)
//         {
//            if(logena)  
//            {
//               writestring(str3,count:1);
//               str3 = "BLK" + str3;
//            } 
//            
//            for (index = sindex;index <= eindex;index++)
//            {
//               i = FAKEREP_SOL[bank][count][index];
//               lsw_data = i;
//               WriteRamContentDec_32Bit(addr,lsw_data,hexvalue,msw_data,hexvalue,bcd_format);
//               addr = addr+ADDR_RAM_INC;
//
//               if(logena)  
//               {
//                  writestring(str4,index:1);
//                  str4 = "_" + str4;
//                  str5 = str1 + str2;
//                  str5 = str5 + str3;
//                  str5 = str5 + str4;
//                  writestring(str6,i:s_hex:1);
//                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                     if(v_dev_active[site])  
//                        logstr[site] = str6;
//                  TWPDLDataLogText(str5,logstr,TWMinimumData);
//               } 
//
//               if(debugprint)  
//                  j = j+1;
//            }   /*index*/
//         }   /*count*/
//
//         if(debugprint)  
//         {
//            cout << "Fake Repair Solution Uploaded Bank" << bank:-5 << endl;
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//                  readramaddress(site,saddr,(saddr+j+(4*ADDR_RAM_INC)));
//            cout << endl;
//         } 
//
//      }   /*bank*/
//
//   }   /*any_dev_active*/
//   
//}   /* RAM_Upload_FakeRepair */
//
//
// /*prerequisite : must execute RAM_Upload_FakeRepair before run this test*/
//BoolS Run_Update_FakeRepair(    StringS tname,
//                                   BoolM test_results,
//                                  BoolS dlogonly)
//{
//   IntS site,bank,count,sblk,eblk,i,j;
//   IntS testnum,length;
//   IntS1D start_tnum(4);
//   FloatS maxtime,ttimer1;
//   FloatM tt_timer;
//   BoolM tmp_results,final_results;
//   BoolM logsites,savesites;
//   BoolS debugprint;
//   StringS fl_testname;
//   FloatM FloatSval;
//   TWunit unitval;
//   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
//   IntM rti_timer;
//   StringM site_cof_inst_str;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ Run_Update_FakeRepair +++++" << endl;
//
//      writestring(tmpstr1,tname);
//      length = len(tmpstr1);
//      writestring(tmpstr1,mid(tmpstr1,2,length-6));
//      tmpstr1 = tmpstr1 + "_REP";
//      fl_testname = tname;
//
//      timernstart(ttimer1);
//
//      PrintHeaderBool(GL_PLELL_FORMAT);
//
//      TestOpen(fl_testname);
//
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//
//      savesites = V_dev_active;
//      final_results = V_dev_active;
//      tmp_results = V_dev_active;
//
//      maxtime = GL_F021_MAXTIME;
//       /*start_tnum[1] := TNUM_BANK_REPAIR_UPDATE_SOLUTION;*/
//      start_tnum[2] = TNUM_OTP_PROG_TEMPLATE;
//      start_tnum[3] = 0x70000100;  /*TNUM_OTP_PROG_TEMPLATE_ENGOVRD;} {will define tnum var later*/
//
//      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//      {
//         logsites = V_dev_active;
//
//          /*KChau - need this??
//          testnum := 0x82400000+(bank<<4);
//          discard(F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results));
//          */
//
//          /*RAM_Upload_FakeRepair(bank);
//          
//          testnum  := start_tnum[1]+(bank<<4);
//          discard(F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results));
//          ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);*/
//         
//         RAM_Upload_VHV_PMOS_EngOvride(bank);
//         testnum  = start_tnum[2]+(bank<<4);
//         F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results);
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//         
//         RAM_Upload_FakeRepair(bank);
//         testnum  = start_tnum[3]+(bank<<4);
//         F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results);
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//         
//         writestring(tmpstr2,bank:1);
//         tmpstr2 = "_B" + tmpstr2;  /*_B#*/
//         tmpstr3 = tmpstr1 + tmpstr2;  /*now has xx_B#*/
//         tmpstr4 = tmpstr3 + "_TT";
//         TWTRealToRealMS(tt_timer,realval,unitval);
//         TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//         
//          /*log RTI timer (internal vclock cycle value) to tw*/
//         rti_timer = 0;
//         GetRTIValue(rti_timer);
//         tmpstr4 = tmpstr3 + "_RTI_TT";
//         TWPDLDataLogVariable(tmpstr4,rti_timer, TWMinimumData);
//         
//         if(tistdscreenprint)  
//            PrintResultBool(tmpstr3,testnum,tmp_results,GL_PLELL_FORMAT);
//               
//         if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//            if(not dlogonly)  
//            {
//               F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
//                     
//               if(TI_FlashCOFEna)  
//                  F021_Update_COF_Inst_Str(tmpstr2,site_cof_inst_str,tmp_results);
//                     
//            } 
//         
//         if(not dlogonly)  
//            if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//               Devsetholdstates(final_results);
//         
//         if(not v_any_dev_active)  
//            break;
//      }   /*bank*/
//      
//      Devsetholdstates(savesites);
//
//      if(not dlogonly)  
//         ResultsRecordActive(final_results, S_NULL);
//      else
//         ResultsRecordActive(savesites, S_NULL);
//      TestClose;
//
//      test_results = final_results;
//
//      if(TI_FlashCOFEna)  
//         F021_Save_COF_Info(tmpstr1,site_cof_inst_str,final_results);
//      
//      ttimer1 = timernread(ttimer1);
//      tt_timer = ttimer1;
//
//      tmpstr4 = tmpstr1 + "_TTT";
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//
//      if(tistdscreenprint)  
//      {
//         PrintResultBool(tmpstr1,start_tnum[2],final_results,GL_PLELL_FORMAT);
//         cout << "   TT " << ttimer1 << endl;
//         cout << endl;
//      }   /*if tistdscreenprint*/
//
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna) and (not dlogonly))  
//         DevSetHoldStates(final_results);
//
//   }   /*any_dev_act*/
//
//   Run_Update_FakeRepair = v_any_dev_active;
//}   /* Run_Update_FakeRepair */
//
// /*in production test screen: tname must not be NULL_TestName and ovrideRPC_EFIndex/twlogstr will be ignored*/
// /*usage for charz: tname=NULL_TestName, ovrideRPC_EFIndex=select predefined read PC/efuse mbox (calling TL_EngOvride_RPC_EF())*/
// /*                 twlogstr=log string w/o bank info, ie no _B0/B0Q0. Also log bit histogram to tw iff charena*/
//BoolS SAMP_Noise_Screen_func(StringS tname,
//                                IntS tcrnum,
//                                IntS tdata,
//                                IntS ttarget,
//                                FloatS force_vcg,
//                                BoolS redundena,
//                                    BoolM test_results,
//                                BoolS dopgmbkgrnd,
//                                IntS ovrideRPC_Val,
//                                IntS ovrideEF_Index,
//                                IntS ovrideEF_Val,
//                                StringS twlogstr)
//{
//   IntS site,bank,count,addr,tnum,length;
//   IntS stnum_prog,stnum_bcc;
//   FloatS cg_vprog,cg_iprog,maxtime,ttimer1,tdelay;
//   FloatS iref_vprog,iref_iprog;
//   FloatS iref_start,iref_stop,iref_inc;
//   IntM FAddr,FData;
//   IntM faddr_msw,faddr_lsw,fdata_msw,fdata_lsw;
//   IntM sum_msw,sum_lsw,Sumbit;
//   StringM FAddrStr_msw,FAddrStr_lsw;
//   StringM FDataStr_msw,FDataStr_lsw,tmpbinstr;
//   StringM FAddrStr,FDataStr;
//   BoolM FoundBit;
//   BoolM final_results,tmp_results;
//   BoolM logsites,savesites,activesites;
//   StringS str1,str2,str3,str4,str5,str6,istr,str7;
//   StringS fl_testname;
//   BoolS tp_iref_ena,tp_cg_ena,done,logena;
//   PinM tp_iref,tp_cg;
//   FloatM tt_timer,FBCC;
//   FloatM FloatSval;
//   TWunit unitval;
//   FloatS ULimit,LLimit;
//   BoolS charena,dlogonly;
//
//   if(v_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ SAMP_Noise_Screen_func +++++" << endl;
//
//      writestring(str1,tname);
//      length = len(str1);
//      writestring(str1,mid(str1,2,length-6));
//      fl_testname = tname;
//      logena = true;
//      tdelay = 2ms;
//      maxtime = GL_F021_BANK_VT_MAXTIME;
//
//      if(tname==NULL_TestName)  
//      {
//         dlogonly = true;
//         charena  = true;
//         str7 = "";
//         if(twlogstr!="")  
//         {
//            if((instr(twlogstr,"Z_SAN_VMX")==1) or (instr(twlogstr,"Z_SAN_VMN")==1) or (instr(twlogstr,"Z_SAN_VNM")==1))  
//            {
//               length = len(twlogstr);
//               if(length>9)  
//               {
//                  str1 = mid(twlogstr,1,9);
//                  str7 = mid(twlogstr,10,length-9);
//               }
//               else
//                  str1 = twlogstr;
//            }
//            else
//            {
//               str1 = twlogstr;
//            } 
//         }
//         else
//            str1 = "Z_SAMP_NOISE";
//      }
//      else
//      {
//         dlogonly = false;
//         charena  = false;
//      } 
//      
//      timernstart(ttimer1);      
//
//      savesites = v_dev_active;
//      final_results = v_dev_active;
//      tmp_results = v_dev_active;
//
//       /*programming*/
//      if(dopgmbkgrnd)  
//      {
//         stnum_prog = TNUM_BANK_PROG_SM + tdata;
//         if(redundena)  
//            stnum_prog = stnum_prog + TNUM_REDUNDENA;
//         tnum = stnum_prog;
//         discard(F021_Program_func(tnum,PgmChk_Test  /*fl_testname},tmp_results)); {KChau 07/25/11 - will need to add to Jazz later*/
//         ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//      } 
//      
//       /*get sense amp noise*/
//      if(v_any_dev_active)  
//      {
//         TestOpen(fl_testname);
//
//         switch(tcrnum) {
//           case 6  :  
//                   stnum_bcc   = TNUM_TCR6 + MainBCC.IRATIO[CHKVT0][pre];
//                   tp_cg_ena   = true;
//                   tp_iref_ena = true;
//                   tp_cg       = FLTP1;
//                   tp_iref     = FLTP2;
//                 break; 
//           case 38 :  
//                   stnum_bcc   = TNUM_TCR38;
//                   tp_cg_ena   = false;
//                   tp_iref_ena = true;
//                   tp_iref     = FLTP1;
//                 break; 
//           default:  
//              stnum_bcc   = TNUM_TCR6 + MainBCC.IRATIO[CHKVT0][pre];
//              tp_cg_ena   = true;
//              tp_iref_ena = true;
//              tp_cg       = FLTP1;
//              tp_iref     = FLTP2;
//            break; 
//         }   /* case */
//
//         cg_vprog   = force_vcg;
//         cg_iprog   = 100mA;
//         iref_start = 20uA;
//         iref_stop  = 1uA;
//         iref_inc   = 1uA;
//         iref_vprog = 2.5V;
//         
//         if(tp_cg_ena)  
//            STDSetVRange(tp_cg,iref_vprog);
//         
//         if(tp_iref_ena)  
//            STDSetVRange(tp_iref,iref_vprog);
//
//         LLimit = 0uA;
//         
//         stnum_bcc = stnum_bcc + ttarget + tdata;
//
//         if((tdata==TNUM_DATA_LOGIC_ECHK) or (tdata==TNUM_DATA_ECHK) or (tdata==TNUM_DATA_OCHK))  
//            stnum_bcc = stnum_bcc + TNUM_PBIST_MASK1s;
//         
//         if(redundena)  
//         {
//            if(tdata==TNUM_DATA_0S)  
//               stnum_bcc = stnum_bcc + TNUM_REDUNDENA;
//         } 
//
//         PrintHeaderParam(GL_PLELL_FORMAT);
//
//         for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//         {
//            logsites = v_dev_active;
//            activesites = v_dev_active;
//
//            Foundbit = false;
//            FAddr = 0;
//            FData = 0;
//            FBCC = 0uA;
//
//            ULimit = SAMP_NOISE_ULIM[bank];
//            
//            tnum = stnum_bcc + (bank<<4);
//            F021_TurnOff_AllTpads;
//            if(tp_cg_ena)  
//               STDSetVI(tp_cg,cg_vprog,cg_iprog);
//
//            writestring(str3,bank:1);
//            str3 = "_B" + str3;
//            if(ttarget == TNUM_TARGET_QUAD)  
//               str3 = str3 + "Q0";
//            str4 = str1 + str3;
//            if(charena)  
//               str4 = str4 + str7;
//
//            done = false;
//            iref_iprog = iref_start;
//
//            REPEAT
//               if(tp_iref_ena)  
//                  STDSetVI(tp_iref,iref_vprog,iref_iprog);
//               TIME.Wait(tdelay);
//               if(tistdscreenprint and TI_FlashDebug)  
//                  cout << "IREF @ " << iref_iprog << endl;
//
//               if(charena)  
//               {
//                  TL_EngOvride_RPC_EF(ovrideRPC_Val,ovrideEF_Index,ovrideEF_Val);
//               } 
//               
//               F021_RunTestNumber(tnum,maxtime,tt_timer,tmp_results);
//               Get_TLogSpace_TotPPulse(sum_msw,sum_lsw);
//               Get_TLogSpace_FAILADDR(faddr_msw,faddr_lsw);
//               IntToBCD_BinStr(faddr_msw,FAddrStr_msw,tmpbinstr,true);
//               IntToBCD_BinStr(faddr_lsw,FAddrStr_lsw,tmpbinstr,true);
//               Get_TLogSpace_FAILDATA(fdata_msw,fdata_lsw);
//               IntToBCD_BinStr(fdata_msw,FDataStr_msw,tmpbinstr,true);
//               IntToBCD_BinStr(fdata_lsw,FDataStr_lsw,tmpbinstr,true);
//               
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                  {
//                     Sumbit[site] = (sum_msw[site]<<16) + sum_lsw[site];
//                     if((Sumbit[site]>0) and (not Foundbit[site]))  
//                     {
//                        Foundbit[site] = true;
//                        FAddrStr[site] = "0x" + FAddrStr_msw[site];
//                        FAddrStr[site] = FAddrStr[site] + FAddrStr_lsw[site];
//                        FDataStr[site] = "0x" + FDataStr_msw[site];
//                        FDataStr[site] = FDataStr[site] + FDataStr_lsw[site];
//                        FBCC[site] = iref_iprog;
//                        FAddr[site] = (faddr_msw[site]<<16) + faddr_lsw[site];
//                        FData[site] = (fdata_msw[site]<<16) + fdata_lsw[site];
//                        if(not charena)  
//                           devsetholdstate(site,false);
//                        if(tistdscreenprint and TI_FlashDebug)  
//                           cout << "Site" << site:-5 << " FAddr==" << FAddr[site]:s_hex:-12 << " FData==" << FData[site]:s_hex:-12 << " FBCC==" << FBCC[site] << endl;
//                     } 
//                  }   /*v_dev_active*/
//
//                /*log bit histo*/
//               if(charena)  
//               {
//                  str5 = str4;
//                  if(tp_iref_ena)  
//                  {
//                     TrealToStr(iref_iprog,istr);
//                     if((istr=="1000NA") or (istr=="1000na"))  
//                        istr = "01UA";
//                     if(len(istr)<4)  
//                        istr = "0" + istr;
//                     str5 = str5 + "_";
//                     str5 = str5 + istr;
//                  } 
//                  str5 = str5 + "_FBIT";
//                  TWPDLDataLogVariable(str5,Sumbit,TWMinimumData);
//                  PrintResultInt(str5,tnum,Sumbit,0,0,GL_PLELL_FORMAT);
//               } 
//
//               if(iref_start>iref_stop)  
//               {
//                  if(iref_iprog<iref_stop)  
//                     done = true;
//                  else
//                  {
//                     if((iref_iprog>==8ua) and (iref_iprog<==9ua) and (not charena))  
//                        iref_iprog = iref_iprog-0.5uA;
//                     else
//                        iref_iprog = iref_iprog-iref_inc;
//                  } 
//               }
//               else
//               {
//                  if(iref_iprog>iref_stop)  
//                     done = true;
//                  else
//                  {
//                     if((iref_iprog>==8ua) and (iref_iprog<==9ua) and (not charena))  
//                        iref_iprog = iref_iprog+0.5uA;
//                     else
//                        iref_iprog = iref_iprog+iref_inc;
//                  } 
//               } 
//
//               if(not v_any_dev_active)  
//                  done = true;
//               
//            UNTIL (done);  /*iref_iprog*/
//
//            devsetholdstates(activesites);
//            tmp_results = v_dev_active;
//
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  if(FBCC[site] > ULimit)  
//                     tmp_results[site] = false;
//               } 
//
//            ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//            
//            if(charena and tistdscreenprint)  
//               cout << endl;
//            str5 = str4 + "_BCC";
//            PrintResultParam(str5,tnum,tmp_results,LLimit,ULimit,FBCC,GL_PLELL_FORMAT);
//                  
//            if(logena)  
//            {
//               TWTRealToRealMS(FBCC,realval,unitval);
//               TWPDLDataLogRealVariable(str5, unitval,realval,TWMinimumData);
//               str5 = str4 + "_FADDR";
//                /*TWPDLDatalogVariableMS(str5,FAddr, TWMinimumData);*/
//               TWPDLDataLogText(str5,FAddrStr,TWMinimumData);
//               PrintResultIntHex(str5,0,FAddr,0,0,GL_PLELL_FORMAT);
//               str5 = str4 + "_FDATA";
//                /*TWPDLDatalogVariableMS(str5,FData, TWMinimumData);*/
//               TWPDLDataLogText(str5,FDataStr,TWMinimumData);
//               PrintResultIntHex(str5,0,FData,0,0,GL_PLELL_FORMAT);
//               if(charena and tistdscreenprint and (bank<F021_Flash.MAXBANK))  
//                  cout << endl;
//            } 
//                  
//            if((not ArrayCompareBoolean(logsites,tmp_results,v_sites)) and (not dlogonly))  
//            {
//               F021_Log_FailPat_To_TW(str4,tmp_results,fl_testname);
//            } 
//
//            if((not TIIgnoreFail) and (not TI_FlashCOFEna) and (not dlogonly))  
//               DevSetHoldStates(final_results);
//
//            if(not v_any_dev_active)  
//               break;
//
//         }   /*for bank*/
//
//         Devsetholdstates(savesites);
//         F021_TurnOff_AllTpads;
//
//         ResultsRecordActive(final_results, S_NULL);
//         TestClose;
//         
//         ttimer1 = timernread(ttimer1);
//         tt_timer = ttimer1;
//         
//         str5 = str1 + "_TTT";
//         TWTRealToRealMS(tt_timer,realval,unitval);
//         TWPDLDataLogRealVariable(str5, unitval,realval,TWMinimumData);
//
//         if(tistdscreenprint)  
//         {
//            PrintResultBool(str1,tnum,final_results,GL_PLELL_FORMAT);
//            cout << "   TT " << ttimer1 << endl;
//            cout << endl;
//         }         /*if tistdscreenprint*/
//
//         if((not TIIgnoreFail) and (not TI_FlashCOFEna) and (not dlogonly))  
//            DevSetHoldStates(final_results);
//
//      }   /*v_any_dev_active senamp noise*/
//
//      test_results = final_results;
//         
//   }   /*v_any_dev_active*/
//
//   SAMP_Noise_Screen_func = v_any_dev_active;
//
//}   /* SAMP_Noise_Screen_func */
//   
//BoolS F021_LPO_Trim_func(    StringS fl_tname,
//                                BoolS dlogonly,
//                                BoolM test_results)
//{
//   BoolM final_results,tmp_results;
//   BoolM savesites,logsites;
//   IntS testnum,site;
//   FloatM tt_timer;
//   StringS tname;
//   StringS str1,str2,str3,str4,str5;
//   FloatS tdelay,maxtime,ttimer1;
//   IntM trimsol,fvalhi,fvallo,rti_timer;
//   FloatM FloatSval;
//   TWunit unitval;
//   BoolS datalogonly;
//   StringM site_cof_inst_str;
//
//   if(v_any_dev_active)  
//   {
//      testnum = TNUM_LPO_AUTOTRIM;
//      maxtime = GL_F021_BANK_MAXTIME;
//      datalogonly = dlogonly;
//      
//      tname = fl_tname;
//      writestring(str1,tname);
//      writestring(str1,mid(str1,2,(len(str1)-6)));
//      str2 = str1 + "_HF";
//      str3 = str1 + "_LF";
//      str4 = str1 + "_SOL";
//      str5 = str1 + "_RTI_TT";
//
//      final_results = v_dev_active;
//      savesites = v_dev_active;
//      logsites = v_dev_active;
//
//      PrintHeaderBool(GL_PLELL_FORMAT);
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//
//      timernstart(ttimer1);
//      TestOpen(tname);
//
//      f021_runtestnumber(testnum,maxtime,tt_timer,tmp_results);
//      ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//      
//      Get_TLogSpace_MeasFreq(fvalhi,fvallo);
//      Get_TLogSpace_TRIMSOL(trimsol);
//      Get_TLogSpace_RTIValue(rti_timer);
//      PrintResultInt(str2,testnum,fvalhi,0,0,GL_PLELL_FORMAT);
//      PrintResultInt(str3,testnum,fvallo,0,0,GL_PLELL_FORMAT);
//      PrintResultInt(str4,testnum,trimsol,0,0,GL_PLELL_FORMAT);
//
//      TWPDLDataLogVariable(str2,fvalhi, TWMinimumData);
//      TWPDLDataLogVariable(str3,fvallo, TWMinimumData);
//      TWPDLDataLogVariable(str4,trimsol, TWMinimumData);
//      TWPDLDataLogVariable(str5,rti_timer, TWMinimumData);
//
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//            LPO_TRIMSAVED[site] = trimsol[site];
//         
//      if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//      {
//         if(not datalogonly)  
//            F021_Log_FailPat_To_TW(str1,final_results,tname);
//         if(TI_FlashCOFEna)  
//            F021_Save_COF_Info("",site_cof_inst_str,final_results);
//      } 
//
//      if(not datalogonly)  
//         ResultsRecordActive(final_results, S_NULL);
//      else
//         ResultsRecordActive(savesites, S_NULL);
//      TestClose;
//
//      test_results = final_results;
//
//      if(TI_FlashCOFEna)  
//         F021_Save_COF_Info(str1,site_cof_inst_str,final_results);
//      
//      ttimer1 = timernread(ttimer1);
//      tt_timer = ttimer1;
//
//      str5 = str1 + "_TTT";
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(str5, unitval,realval,TWMinimumData);
//
//      if(tistdscreenprint)  
//      {
//         PrintResultBool(str1,testnum,final_results,GL_PLELL_FORMAT);
//         cout << "   TT " << ttimer1 << endl;
//         cout << endl;
//      }   /*if tistdscreenprint*/
//
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna) and (not datalogonly))  
//         DevSetHoldStates(final_results);
//   }   /*v_any_dev_active*/
//
//   F021_LPO_Trim_func = v_any_dev_active;
//} 
//
//
// /*++++++++++++++++++++++++++++++++++++++*/
//
//
//
//
//void MyPATTEST_COF(StringS logstr,
//                        StringS firstPatt,
//                        StringS lastPatt,
//                        FloatS tfreq,
//                        VCornerType vcorner)
//{
//   IntS site,i,j;
//   StringS str1,str2,str3,vstr;
//   StringM PatRes;
//   BoolM tmp_results,final_results;
//   BoolS debugprint;
//   StringS pattind;
//   FloatS tdelay;
//
//   if(v_any_dev_active)  
//   {
//      debugprint = true;
//      tdelay = 2ms;
//      
//      if(ord(lastPatt) > ord(firstPatt))  
//      {
//         i = ord(lastPatt)-ord(firstPatt)+1;
//         if(tistdscreenprint and debugprint)  
//            cout << "Total patterns : " << i << endl;
//
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//               PatRes[site] = "";
//
//         switch(vcorner) {
//           case  VMN: case VMNO: case VMNE :   
//              PowerUpAtVmin(dcsetup_loosevmin,norm_fmsu);
//              ClockSet(S_CLOCK1A,false,tfreq,
//                    v[vih_loose_osc_vmin],v[vil_loose]);
//              vstr = "_VMN";
//            break; 
//           case  VNM: case VNMO: case VNME :   
//              PowerUpAtVnom(dcsetup_loosevnom,norm_fmsu);
//              ClockSet(S_CLOCK1A,false,tfreq,
//                    v[vih_loose_osc_vnom],v[vil_loose]);
//              vstr = "_VNM";
//            break; 
//           case  VMX: case VMXO: case VMXE :   
//              PowerUpAtVmax(dcsetup_loosevmax,norm_fmsu);
//              ClockSet(S_CLOCK1A,false,tfreq,
//                    v[vih_loose_osc_vmax],v[vil_loose]);
//              vstr = "_VMX";
//            break; 
//           default:  
//              PowerUpAtVnom(dcsetup_loosevnom,norm_fmsu);
//              ClockSet(S_CLOCK1A,false,tfreq,
//                    v[vih_loose_osc_vnom],v[vil_loose]);
//              vstr = "_VNM";
//            break;            
//         }   /* case */
//
//         TIME.Wait(tdelay);
//
//         PrintHeaderBool(GL_PLELL_FORMAT);
//         final_results = v_dev_active;
//         
//         for (pattind = firstpatt;pattind <= lastpatt;pattind++)
//         {
//            patternexecute(j,pattind);
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  if(not v_pf_status[site])  
//                     PatRes[site] = PatRes[site] + "0";
//                  else
//                     PatRes[site] = PatRes[site] + "1";
//               } 
//
//            if(tistdscreenprint)  
//            {
//               writestring(str1,pattind);
//               tmp_results = v_pf_status;
//               arrayandboolean(final_results,final_results,tmp_results,v_sites);
//               PrintResultBool(str1,0,tmp_results,GL_PLELL_FORMAT);
//            } 
//         } 
//
//         str2 = logstr + vstr;
//         TWPDLDataLogText(str2,PatRes,TWMinimumData);
//
//         if(tistdscreenprint)  
//         {
//            PrintResultBool(str2,0,final_results,GL_PLELL_FORMAT);
//            if(debugprint)  
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                     cout << "Site" << site:-5 << PatRes[site] << endl;
//         } 
//      }
//      else
//      {
//         if(tistdscreenprint)  
//            cout << "*** WARNING: FirstPatt is after LastPatt !!! ***" << endl;
//      } 
//   }   /*if v_any_dev_active*/
//} 
//
//
//void TL_Display_BCC_INFO()
//{
//   IntS site,bank,count,loop,row;
//   IntS numword,numword_max;
//   BoolM final_results;
//   FloatS maxtime;
//   FloatM ttimer1;
//
//   if(tistdscreenprint)  
//   {
//      numword = 0;
//      numword_max = 127;
//      
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            cout << endl;
//            cout << "Site " << site:-5 << " OTP BCC INFO" << endl;
//            for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//            {
//               cout << "BANK " << bank:-4 << endl;
//               loop = 0;
//               row  = 0;
//               for (count = numword;count <= numword_max;count++)
//               {
//                  if((loop mod 8)==0)  
//                     cout << "Row " << row:-6;
//                  cout << OTP_BCC_INFO_INTVAL[bank][count][site]:s_hex:-6 << " ":4;
//                  loop = loop+1;
//                  if((loop mod 8)==0)  
//                  {
//                     cout << endl;
//                     loop = 0;
//                     row  = row+1;
//                  } 
//               }   /*for count*/
//               cout << endl;
//            }   /*for bank*/
//         }   /*v_dev_active*/
//   } 
//}   /* TL_Display_BCC_INFO */
//
//void TL_DEBUG_FUNC()
//{
//   IntS site,bank,tnum;
//   BoolM final_results;
//   FloatS maxtime;
//   FloatM ttimer1;
//
//    /*Place holder for debug*/
//}   /* TL_DEBUG_FUNC */
//
// /*debug routine for programming fail*/
// /*input param: vcorner is either VMN,VNM,VMX.  pattype is either BANKTYPE,SECTTYPE,...*/
// /*This routine perform following steps --  */
// /*--deep program w/ COF & override pulse width of 80us & 1 pulse only*/
// /*--do pvfy esda*/
// /*--do bcc0 histogram @ vcg=0v, iref=15ua to 2ua. and record worst bit info*/
// /*--do iv curve w/ TCR1 @ vcg=1v to 7v on 1st worst bit*/
// /*--do iv curve w/ TCR6 on 1st worst bit*/
//void TL_DEBUG_PGM_FAIL(VCornerType vcorner,
//                            IntS pattype)
//{
//   const IntS TNUM_COF = 0x00020000; 
//   const IntS TNUM_PVFY_ESDA = 0x41020000; 
//   const  TNUM_TARGET_ARB = 0x00000A00;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS IND_FCOUNT_MSW = 9; 
//   const IntS IND_FCOUNT_LSW = 10; 
//   const IntS IND_STARTADDR = 11; 
//   const  STARTFLAG = 0xFEDE;  /* :MANUAL FIX REQUIRED: Unknown const type */
//
//   IntS site,bank,count,tnum,pulse_ulim,testnum;
//   IntS stnum_pgm,stnum_pv,stnum_tcr1,stnum_tcr6;
//   BoolM final_results,tmp_results;
//   BoolM savesites,logsites,SiteToEsda,disallsites;
//   FloatS maxtime,tdelay1,tdelay2,tdelay3;
//   FloatM ttimer1,ttimer2,tt_timer;
//   IntS blkstart,blkstop,imgesda,i,j,k,dbit;
//   IntM pgmpulse,expfailcnt;
//   StringS str1,str2,str3,str4,str5,current_shell,s;
//   FloatS vcg_start,vcg_stop,vcg_inc;
//   FloatS iref_start,iref_stop,iref_inc;
//   FloatS start_v,stop_v,inc_v,loop_v,loop_i;
//   BoolS found_bit;
//   IntM1D fdata(11);
//   IntM fdata_index,fdata_bitindex;
//   IntM faddr,msw_data,lsw_data,senampnum;
//   IntS senamp,addr_loc,address,addr_lo,addr_hi;
//   FloatM istartarr,istoparr,vforcearr;
//   FloatM bccval;
//
//   if(v_any_dev_active)  
//   {
//      savesites = v_dev_active;
//      final_results = v_dev_active;
//      disallsites = false;
//
//      tdelay1 = 10ms;
//      tdelay2 = 2ms;
//      tdelay3 = 100ms;
//      maxtime = GL_F021_BANK_MAXTIME;
//      pulse_ulim = BANK_PROG_ULimit;
//      imgesda = 500;
//      
//      switch(vcorner) {
//        case  VMN: case VMNO: case VMNE :   
//           PowerUpAtVmin(dcsetup_loosevmin,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vmin],v[vil_loose]);
//         break; 
//        case  VNM: case VNMO: case VNME :   
//           PowerUpAtVnom(dcsetup_loosevnom,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vnom],v[vil_loose]);
//         break; 
//        case  VMX: case VMXO: case VMXE :   
//           PowerUpAtVmax(dcsetup_loosevmax,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vmax],v[vil_loose]);
//         break; 
//        default:  
//           PowerUpAtVnom(dcsetup_loosevnom,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vnom],v[vil_loose]);
//         break;            
//      }   /* case */
//
//      TIME.Wait(tdelay2);
//      
//      current_shell = "FlashShell";
//      if(GL_PREVIOUS_SHELL != current_shell)        
//         patternexecute(spareint1,f021_shell_loadpat);
//
//      PrintHeaderErsProg(0,pulse_ulim,0,0,0,0,(not GL_PLELL_FORMAT));
//
//      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//      {
//         if((pattype==BANKTYPE) or (pattype==OTPTYPE))  
//         {
//            blkstart = bank;
//            blkstop  = bank;
//            stnum_pgm = TNUM_BANK_PROG_SM;
//            stnum_pv  = TNUM_PVFY_ESDA;
//            stnum_tcr6 = TNUM_TCR6+TNUM_MULT1;
//            if(pattype==OTPTYPE)  
//            {
//               stnum_pgm = stnum_pgm+TNUM_TARGET_OTP;
//               stnum_pv  = stnum_pv+TNUM_TARGET_OTP;
//               stnum_tcr6  = stnum_tcr6+TNUM_TARGET_OTP;
//            } 
//         }
//         else if(pattype==BLOCKTYPE)  
//         {
//            blkstart = 0;
//            blkstop  = F021_Flash.MAXBLOCK[bank];
//            stnum_pgm = TNUM_BANK_PROG_SM+TNUM_TARGET_BLOCK;
//            stnum_pv  = TNUM_PVFY_ESDA+TNUM_TARGET_BLOCK;
//            stnum_tcr6  = TNUM_TCR6+TNUM_MULT1+TNUM_TARGET_BLOCK;
//         }
//         else
//         {
//            blkstart = 0;
//            blkstop  = F021_Flash.MAXSECT[bank];
//            stnum_pgm = TNUM_BANK_PROG_SM+TNUM_TARGET_SECT;
//            stnum_pv  = TNUM_PVFY_ESDA+TNUM_TARGET_SECT;
//            stnum_tcr6  = TNUM_TCR6+TNUM_MULT1+TNUM_TARGET_SECT;
//         } 
//
//         tnum = stnum_pgm+TNUM_COF+(bank<<4);
//
//         for (count = blkstart;count <= blkstop;count++)
//         {
//            SiteToEsda = false;
//            logsites = v_dev_active;
//            if((pattype==BLOCKTYPE) or (pattype==SECTTYPE))  
//               tnum = tnum+count;
//            tiprintpass= true;
//            TL_EngOvride_PPW_MAXPP(0xA0,1);
//            f021_runtestnumber(tnum,maxtime*2,tt_timer,tmp_results);
//            arrayandboolean(final_results,final_results,tmp_results,v_sites);
//            tiprintpass= false;
//            
//            pgmpulse = 0;
//            Get_TLogSpace_MaxPPulse(pgmpulse);
//
//            writestring(str2,bank:1);
//            str2 = "_B" + str2;
//            if((pattype==BLOCKTYPE) or (pattype==SECTTYPE))  
//            {
//               writestring(str3,count:1);
//               if(pattype==BLOCKTYPE)  
//                  str3 = "BLK" + str3;
//               else
//                  str3 = "S" + str3;
//               str2 = str2 + str3;
//            } 
//            str1 = "PGM" + str2;
//            str1 = str1 + "_PLS";
//
//            PrintResultErsProg(str1,testnum,pgmpulse,pgmpulse,pgmpulse,0,pulse_ulim,0,0,0,0,(not GL_PLELL_FORMAT));
//
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site] and (not tmp_results[site]))  
//                  SiteToEsda[site] = true;
//
//             /*+++ pvfy esda +++*/
//            if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//            {
//               devsetholdstates(SiteToEsda);
//               tnum = stnum_pv+(bank<<4);
//               if((pattype==BLOCKTYPE) or (pattype==SECTTYPE))  
//                  tnum = tnum+count;
//               f021_runtestnumber(tnum,maxtime,tt_timer,tmp_results);
//               
//               if(not GL_DO_ESDA_WITH_SCRAM)  
//                  F021_GetESDA_NonSCRAM(imgesda,bank);
//               else
//                  Get_Flash_ESDASpace_SCRAM;
//               TL_SaveESDAImage(imgesda,bank);
//
//                /*get fail count*/
//               expfailcnt = FL_SCRAM_CAPT_ARR[IND_FCOUNT_MSW];
//               arraymultintegervalue(expfailcnt,expfailcnt,0x10000,v_sites);
//               arrayaddinteger(expfailcnt,expfailcnt,FL_SCRAM_CAPT_ARR[IND_FCOUNT_LSW],v_sites);
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                     if((expfailcnt[site]<==0) or (FL_SCRAM_CAPT_ARR[2][site]!= STARTFLAG))  
//                     {
//                        SiteToEsda[site] = false;
//                        devsetholdstate(site,false);
//                     } 
//
//                /*+++ bcc0 histogram & record worst bit info +++*/
//               if(v_any_dev_active)  
//               {
//                   /*do bcc0 histogram & record worst bit info*/
//                  tnum = stnum_tcr6+(bank<<4);
//                  if((pattype==BLOCKTYPE) or (pattype==SECTTYPE))  
//                     tnum = tnum+count;
//                  vcg_start = 0V;
//                  vcg_stop  = 0V;
//                  vcg_inc   = 1V;
//                  iref_start = 15ua ; /*40uA*/
//                  iref_stop  = 2uA;
//                  iref_inc   = 1uA;
//                  GL_DO_GET_WORSTBIT = true;
//                  TL_BitHistogram(pattype,tnum,vcg_start,vcg_stop,vcg_inc,iref_start,iref_stop,iref_inc,false,"");
//                  GL_DO_GET_WORSTBIT = false;
//
//                   /*parse to enable one worst bit*/
//                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                     if(v_dev_active[site])  
//                     {
//                        found_bit = false;
//                        faddr[site] = 0x08000000 + (FL_WORSTBIT_FADDR[site]<<4);
//                        if(tistdscreenprint and TI_FlashDebug)  
//                        {
//                           cout << "Site" << site:-5 << " BitHistogram FADDR == " << faddr[site]:s_hex << endl;
//                           cout << "FDATA == ";
//                           for (i = 1;i <= 10;i++)
//                              cout << FL_WORSTBIT_FDATA[i][site]:s_hex:-7 << "  ";
//                           cout << endl;
//                        } 
//                        for (i = 1;i <= 9;i++)
//                        {
//                            /*ignore ECC word*/
//                           if(FL_WORSTBIT_FDATA[i+1][site] != 0)  
//                           {
//                              if(found_bit)  
//                                 fdata[i][site] = 0xFFFF;
//                              else
//                              {
//                                 dbit= FL_WORSTBIT_FDATA[i+1][site];
//                                  /*writeln(tiwindow,"i=",i:-5,"dbit=",dbit:s_hex);*/
//                                 for (j = 15;j >= 0;--j)
//                                 {
//                                    k = (dbit & (1<<j)) >>j;
//                                     /*writeln(tiwindow,"j=",j:-5," k=",k:-5);*/
//                                    if(k==1)  
//                                    {
//                                       dbit = 0xFFFF ^ (1<<j);
//                                       fdata[i][site] = dbit;
//                                       found_bit = true;
//                                       senampnum[site] = ((i-1)*16) + (16-j-1);
//                                       fdata_index[site] = i;
//                                       fdata_bitindex[site] = j;
//                                       break;
//                                    } 
//                                 }   /*for j*/
//                              }   /*if found_bit*/
//                           }
//                           else
//                           {
//                              fdata[i][site] = 0xFFFF;
//                           } 
//                        }   /*for i*/
//                        fdata[10][site] = 0xffff;
//                        if(tistdscreenprint and TI_FlashDebug)  
//                        {
//                           cout << "Site" << site:-5 << " First Worst Bit Info: " << endl;
//                           cout << "FADDR == " << faddr[site]:s_hex:-12 << " SA == " << senampnum[site]:-5;
//                           cout << "FDATA == ";
//                           for (i = 1;i <= 10;i++)
//                              cout << fdata[i][site]:s_hex:-7 << " ";
//                           cout << endl;
//                        } 
//                     }   /*v_dev_active*/
//
//
//                   /*+++ iv curve tcr1 +++*/
//                  addr_loc = ADDR_RAM_MAILBOX;
//                  msw_data = 0x1234;
//                  lsw_data = 9;
//                  WriteRamContentDec_32Bit(addr_loc,lsw_data,true,msw_data,true,true);
//                  addr_loc = addr_loc+ADDR_RAM_INC;
//                  for i = 1 to 10 by 2 do
//                  {
//                     msw_data = fdata[i];
//                     lsw_data = fdata[i+1];
//                     WriteRamContentDec_32Bit(addr_loc,lsw_data,true,msw_data,true,true);
//                     addr_loc = addr_loc+ADDR_RAM_INC;
//                  } 
//                  if(tistdscreenprint and TI_FlashDebug)  
//                  {
//                     i = ADDR_RAM_MAILBOX;
//                     for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                        if(v_dev_active[site])  
//                           readramaddress(site,i,i+(8*ADDR_RAM_INC));
//                  } 
//
//                   /*taking iv serially*/
//                  start_v = 1V;
//                  stop_v  = 7V;
//                  inc_v   = 1v ; /*0.5v*/
//                  devsetholdstates(disallsites);
//                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                     if(SiteToEsda[site])  
//                     {
//                        devsetholdstate(site,true);
//                        address = faddr[site];
//                        senamp  = senampnum[site];
//                        TL_IV_Curve(address,senamp,start_v,stop_v,inc_v,false,1v,false);
//                        devsetholdstate(site,false);
//                     } 
//                  devsetholdstates(SiteToEsda);
//                   /*+++ end iv curve tcr1 +++*/
//
//
//                   /*+++ iv curve tcr6 +++*/
//                  devsetholdstates(disallsites);
//                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                     if(SiteToEsda[site])  
//                     {
//                        devsetholdstate(site,true);
//                        addr_hi = (faddr[site]&0xFFFF0000)>>16;
//                        addr_lo = faddr[site]&0x0000FFFF;
//                        TL_SetArbAddr(addr_hi,addr_lo);
//                        TL_SetArbLength(0x0,0x12);  /*18bytes*/
//                        devsetholdstate(site,false);
//                     } 
//                  devsetholdstates(SiteToEsda);
//                  istartarr = 0uA ; /*iref_stop*/
//                  istoparr = 40uA ; /*iref_start*/
//
//                  tnum = stnum_tcr6+(bank<<4)+TNUM_TARGET_ARB+TNUM_TOPTION_ESDARD;
//                  if((pattype==BLOCKTYPE) or (pattype==SECTTYPE))  
//                     tnum = tnum+count;
//
//                  PrintHeaderBool(GL_PLELL_FORMAT);
//
//                  for loop_v = start_v to stop_v by inc_v do
//                  {
//                     if(TI_FlashDebug)  
//                        if(Inkey(s))   break;
//                     bccval = 0uA;
//                     for loop_i = 40ua downto 2ua by 2ua do
//                     {
//                        if(TI_FlashDebug)  
//                           if(Inkey(s))   break;
//                        TRealToStr(loop_v,str4);
//                        str5 = "TCR6" + str2;
//                        str5 = str5 + "_";
//                        str5 = str5 + str4;
//                        str5 = str5 + "_";
//                        TRealToStr(loop_i,str4);
//                        str5 = str5 + str4;
//
//                        STDSetVRange(FLTP2,2.5v);
//                        STDSetVI(FLTP2,2.5v,loop_i);
//                        STDSetVRange(FLTP1,loop_v);
//                        STDSetVI(FLTP1,loop_v,100ma);
//                        TIME.Wait(tdelay2);
//                        f021_runtestnumber(tnum,maxtime,tt_timer,tmp_results);
//                        F021_TurnOff_AllTpads;
//                        
//                         /*check if bit fail*/
//                        if(not GL_DO_ESDA_WITH_SCRAM)  
//                           F021_GetESDA_NonSCRAM(500,bank);
//                        else
//                           Get_Flash_ESDASpace_SCRAM;
//
//                         /*get fail count*/
//                        expfailcnt = FL_SCRAM_CAPT_ARR[IND_FCOUNT_MSW];
//                        arraymultintegervalue(expfailcnt,expfailcnt,0x10000,v_sites);
//                        arrayaddinteger(expfailcnt,expfailcnt,FL_SCRAM_CAPT_ARR[IND_FCOUNT_LSW],v_sites);
//                        
//                        for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                           if(v_dev_active[site])  
//                           {
//                              if(expfailcnt[site]>0)  
//                              {
//                                 i = fdata_index[site] ; /*(senampnum[site] div 16)+1*/
//                                  /*senamp := senampnum[site] mod 16;*/
//                                 j = fdata_bitindex[site];
//                                 k = ((FL_SCRAM_CAPT_ARR[IND_STARTADDR+i+2][site]) >> j) &0x01;
//                                 if(tistdscreenprint and TI_FlashDebug)  
//                                 {
//                                     /*writeln(tiwindow,"i=",i:-5," senamp=",senamp:-5," j=",j:s_hex:-7," k=",k:s_hex:-7);*/
//                                    cout << "FL_SCRAM_CAPT_ARR["][IND_STARTADDR+i+2]["] " << FL_SCRAM_CAPT_ARR[IND_STARTADDR+i+2][site]:s_hex << endl;
//                                 } 
//                                 if(k==1)  
//                                 {
//                                    bccval[site] = loop_i;
//                                    if(tistdscreenprint)  
//                                    {
//                                       cout << "Site" << site:-5 << str5 << " " << bccval[site] << endl;
//                                       if(TI_FlashDebug)  
//                                          readramaddress(site,0x500,0x52c);
//                                    } 
//                                    devsetholdstate(site,false);
//                                 }   /*if k*/
//                                 if(v_dev_active[site] and tistdscreenprint and TI_FlashDebug)  
//                                 {
//                                    cout << str5 << endl;
//                                    readramaddress(site,0x500,0x52c);
//                                 } 
//                              } 
//                           }   /*if v_dev_active*/
//
//                        if(not v_any_dev_active)  
//                           break;
//                     }   /*for loop_i*/
//                     devsetholdstates(SiteToEsda);
//                     PrintResultParam(str5,tnum,tmp_results,0ua,40ua,bccval,GL_PLELL_FORMAT);
//                  }   /*for loop_v*/
//
//                  
//
//               }   /*if v_any_dev_active*/
//                /*+++ end bcc0 histogram & record worst bit info +++*/
//
//               devsetholdstates(savesites);
//            }   /*if not arraycomparebool*/
//             /*+++ end pvfy esda +++*/
//
//            TL_SetArbAddr(0x0,0x0);
//            
//         }   /*count*/
//      }   /*bank*/
//
//   }   /*if v_any_dev_active*/
//}  
//
//void TL_SENSEAMP_CHARZ(VCornerType vcorner,
//                            IntS banknum,
//                            IntS bkgrnd_data)
//{
//   const IntS TNUM_COF = 0x00020000; 
//   const IntS TNUM_PVFY_ESDA = 0x41020000; 
//   const  TNUM_TARGET_ARB = 0x00000A00;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS IND_FCOUNT_MSW = 9; 
//   const IntS IND_FCOUNT_LSW = 10; 
//   const IntS IND_STARTADDR = 11; 
//   const  STARTFLAG = 0xFEDE;  /* :MANUAL FIX REQUIRED: Unknown const type */
//
//   IntS site,bank,count,tnum,pulse_ulim,testnum;
//   IntS stnum_pgm,stnum_pv,stnum_tcr1,stnum_tcr6;
//   BoolM final_results,tmp_results;
//   BoolM savesites,logsites,SiteToEsda,disallsites;
//   FloatS maxtime,tdelay1,tdelay2,tdelay3;
//   FloatM ttimer1,ttimer2,tt_timer;
//   IntS blkstart,blkstop,imgesda,i,j,k,dbit;
//   IntM pgmpulse,expfailcnt;
//   StringS str1,str2,str3,str4,str5,current_shell,s;
//   FloatS vcg_start,vcg_stop,vcg_inc;
//   FloatS iref_start,iref_stop,iref_inc;
//   FloatS start_v,stop_v,inc_v,loop_v,loop_i;
//   BoolS found_bit;
//   IntM1D fdata(11);
//   IntM fdata_index,fdata_bitindex;
//   IntM faddr,faddr_save,msw_data,lsw_data,senampnum;
//   IntS senamp,addr_loc,address,addr_lo,addr_hi;
//   FloatM istartarr,istoparr,vforcearr;
//   FloatM bccval;
//   IntS addr_offset,counter,tdata,pattype;
//   IntS fdlen1,fdlen2,decpt;
//   FloatS tmpFloatS;
//   FloatM1D tcr1_val(513),tcr6_val(513);
//   BoolS savescreenprint;
//
//   if(v_any_dev_active)  
//   {
//      savesites = v_dev_active;
//      final_results = v_dev_active;
//      SiteToEsda = v_dev_active;
//      disallsites = false;
//
//      tdelay1 = 10ms;
//      tdelay2 = 2ms;
//      tdelay3 = 100ms;
//      maxtime = GL_F021_BANK_MAXTIME;
//      imgesda = 500;
//      
//      switch(vcorner) {
//        case  VMN: case VMNO: case VMNE :   
//           PowerUpAtVmin(dcsetup_loosevmin,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vmin],v[vil_loose]);
//         break; 
//        case  VNM: case VNMO: case VNME :   
//           PowerUpAtVnom(dcsetup_loosevnom,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vnom],v[vil_loose]);
//         break; 
//        case  VMX: case VMXO: case VMXE :   
//           PowerUpAtVmax(dcsetup_loosevmax,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vmax],v[vil_loose]);
//         break; 
//        default:  
//           PowerUpAtVnom(dcsetup_loosevnom,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vnom],v[vil_loose]);
//         break;            
//      }   /* case */
//
//      TIME.Wait(tdelay2);
//      
//      current_shell = "FlashShell";
//      if(GL_PREVIOUS_SHELL != current_shell)        
//         patternexecute(spareint1,f021_shell_loadpat);
//
//      pattype = BANKTYPE;
//      
//      switch(bkgrnd_data) {
//        case 0 : tdata = TNUM_DATA_0s;
//        case 1 : tdata = TNUM_DATA_1s;
//        case 2 : tdata = TNUM_DATA_ECHK;
//        case 3 : tdata = TNUM_DATA_OCHK;
//        case 10 : tdata = TNUM_DATA_ARBITRARY;
//        default: tdata = TNUM_DATA_0s;
//      }   /* case */
//      
//      stnum_tcr6 = TNUM_TCR6+TNUM_MULT1+tdata+(banknum<<4);
//
//      vcg_start = 1.825V;
//      vcg_stop  = 1.825V;
//      vcg_inc   = 1V;
//      iref_start = 20uA;
//      iref_stop  = 0.25uA;
//      iref_inc   = 0.25uA;
//
//       /*+++ bcc0 histogram & record worst bit info +++*/
//      if(v_any_dev_active)  
//      {
//          /*do bcc0 histogram & record worst bit info*/
//         tnum = stnum_tcr6;
//         GL_DO_GET_WORSTBIT = true;
//         TL_BitHistogram(pattype,tnum,vcg_start,vcg_stop,vcg_inc,iref_start,iref_stop,iref_inc,false,"");
//         GL_DO_GET_WORSTBIT = false;
//
//         switch(banknum) {
//             switch(switch(0 : addr_offset = 0x08000000;
//               switch(switch(switch(1 : addr_offset = 0x08080000;
//                 switch(switch(switch(switch(2 : addr_offset = 0xF0200000;   /*emu bank*/
//         }   /* case */
//         
//          /*parse to enable one worst bit*/
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               found_bit = false;
//               faddr[site] = addr_offset + (FL_WORSTBIT_FADDR[site]<<4);
//               faddr_save[site] = FL_WORSTBIT_FADDR[site];
//               TL_Get_PhysSenAmp_From_ESDA_WorstBit(site,senamp,i,j);
//               senampnum[site] = senamp;
//               fdata_index[site] = i;
//               fdata_bitindex[site] = j;
//               if(tistdscreenprint)  
//               {
//                  cout << "Site" << site:-5 << " BitHistogram FADDR == " << faddr[site]:s_hex:-12 << " SA == " << senampnum[site]:-5 << endl;
//                  cout << "FDATA == ";
//                  for (i = 1;i <= 10;i++)
//                     cout << FL_WORSTBIT_FDATA[i][site]:s_hex:-7 << "  ";
//                  cout << endl;
//               } 
//            }   /*v_dev_active*/
//
//
//          /*+++ iv curve tcr1 +++*/
//          /*
//          addr_loc := ADDR_RAM_MAILBOX;
//          arraysetinteger(msw_data,0x1234);
//          arraysetinteger(lsw_data,9);
//          WriteRamContentDec_32Bit(addr_loc,lsw_data,true,msw_data,true,true);
//          addr_loc := addr_loc+ADDR_RAM_INC;
//          for i := 1 to 10 by 2 do
//          begin
//             arraycopyinteger(msw_data,fdata[i],v_sites);
//             arraycopyinteger(lsw_data,fdata[i+1],v_sites);
//             WriteRamContentDec_32Bit(addr_loc,lsw_data,true,msw_data,true,true);
//             addr_loc := addr_loc+ADDR_RAM_INC;
//          end;
//                   if(tistdscreenprint and TI_FlashDebug) then
//                   begin
//                      i := ADDR_RAM_MAILBOX;
//                      for site := 1 to v_sites do
//                         if(v_dev_active[site]) then
//                            readramaddress(site,i,i+(8*ADDR_RAM_INC));
//                   end;
//          */
//          /*savescreenprint := TIStdScreenPrint;
//          if(not TI_FlashDebug) then
//             TIStdScreenPrint := false;*/
//         
//          /*taking iv serially*/
//         start_v = 1V;
//         stop_v  = 6.5V;
//         inc_v   = 0.25V;
//         devsetholdstates(disallsites);
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(SiteToEsda[site])  
//            {
//               devsetholdstate(site,true);
//               address = faddr[site];
//               senamp  = senampnum[site];
//               GL_DO_SAVE_IV_DATA = true;
//               TL_IV_Curve(address,senamp,start_v,stop_v,inc_v,false,1v,false);
//               GL_DO_SAVE_IV_DATA = false;
//               for (i = 1;i <= FL_IV_DATA_COUNT;i++)
//                  tcr1_val[i][site] = FL_IV_DATA[i][site];
//               devsetholdstate(site,false);
//            } 
//          /*devsetholdstates(SiteToEsda);*/
//          /*+++ end iv curve tcr1 +++*/
//
//
//          /*+++ iv curve tcr6 +++*/
//         devsetholdstates(disallsites);
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(SiteToEsda[site])  
//            {
//               devsetholdstate(site,true);
//               addr_hi = (faddr[site]&0xFFFF0000)>>16;
//               addr_lo = faddr[site]&0x0000FFFF;
//               TL_SetArbAddr(addr_hi,addr_lo);
//               TL_SetArbLength(0x0,0x12);  /*18bytes*/
//               devsetholdstate(site,false);
//            } 
//         devsetholdstates(SiteToEsda);
//         istartarr = iref_stop;
//         istoparr = 15uA;
//         
//         tnum = stnum_tcr6+TNUM_TARGET_ARB+TNUM_TOPTION_ESDARD;
//
//         savescreenprint = TIStdScreenPrint;
//         if(not TI_FlashDebug)  
//            TIStdScreenPrint = false;
//         
//         PrintHeaderBool(GL_PLELL_FORMAT);
//
//         counter = 0;
//         
//         for loop_v = start_v to stop_v by inc_v do
//         {
//            counter = counter+1;
//            if(TI_FlashDebug)  
//               if(Inkey(s))   break;
//            bccval = 0uA;
//
//             /*sweep from pass-to-fail*/
//            for loop_i = iref_start downto iref_stop by iref_inc do
//            {
//               if(TI_FlashDebug)  
//                  if(Inkey(s))   break;
//               TRealToStr(loop_v,str4);
//               str5 = "TCR6" + str2;
//               str5 = str5 + "_";
//               str5 = str5 + str4;
//               str5 = str5 + "_";
//               TRealToStr(loop_i,str4);
//               str5 = str5 + str4;
//               
//               STDSetVRange(FLTP2,2.5v);
//               STDSetVI(FLTP2,2.5v,loop_i);
//               STDSetVRange(FLTP1,loop_v);
//               STDSetVI(FLTP1,loop_v,100ma);
//               TIME.Wait(tdelay2);
//               f021_runtestnumber(tnum,maxtime,tt_timer,tmp_results);
//               F021_TurnOff_AllTpads;
//               
//                /*check if bit fail*/
//               if(not GL_DO_ESDA_WITH_SCRAM)  
//                  F021_GetESDA_NonSCRAM(500,bank);
//               else
//                  Get_Flash_ESDASpace_SCRAM;
//               
//                /*get fail count*/
//               expfailcnt = FL_SCRAM_CAPT_ARR[IND_FCOUNT_MSW];
//               arraymultintegervalue(expfailcnt,expfailcnt,0x10000,v_sites);
//               arrayaddinteger(expfailcnt,expfailcnt,FL_SCRAM_CAPT_ARR[IND_FCOUNT_LSW],v_sites);
//
//               if(tistdscreenprint and TI_FlashDebug)  
//               {
//                  cout << "Vcg == " << loop_v << " Iref == " << loop_i << endl;
//                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                     if(v_dev_active[site])  
//                     {
//                        cout << "Site" << site:-5 << " Failcount == " << expfailcnt[site] << endl;
//                        readramaddress(site,ADDR_RAM_REPAIR_SOL,ADDR_RAM_REPAIR_SOL+(16*ADDR_RAM_INC));
//                     } 
//               } 
//               
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                  {
//                     if(expfailcnt[site]>0)  
//                     {
//                        i = fdata_index[site];
//                        j = fdata_bitindex[site];
//                        k = ((FL_SCRAM_CAPT_ARR[IND_STARTADDR+i+3][site]) >> j) &0x01;
//                        if(tistdscreenprint and TI_FlashDebug)  
//                        {
//                            /*writeln(tiwindow,"i=",i:-5," senamp=",senamp:-5," j=",j:s_hex:-7," k=",k:s_hex:-7);*/
//                           cout << "FL_SCRAM_CAPT_ARR["][IND_STARTADDR+i+3]["] " << FL_SCRAM_CAPT_ARR[IND_STARTADDR+i+3][site]:s_hex << endl;
//                        } 
//                        
//                        if(k==1)  
//                        {
//                           bccval[site] = loop_i;
//                           tcr6_val[counter][site] = loop_i;
//                           if(tistdscreenprint)  
//                           {
//                              cout << "Site" << site:-5 << str5 << " " << bccval[site] << endl;
//                               /*if(TI_FlashDebug) then
//                                  readramaddress(site,0x500,0x500+(11*ADDR_RAM_INC));*/
//                           } 
//                           devsetholdstate(site,false);
//                        }
//                        else if(loop_i >== iref_stop)  
//                        {
//                           tcr6_val[counter][site] = 0uA;
//                        } 
//                        
//                         /*if(v_dev_active[site] and tistdscreenprint and TI_FlashDebug) then
//                         begin
//                            writeln(tiwindow,str5);
//                            readramaddress(site,0x500,0x500+(11*ADDR_RAM_INC));
//                         end;*/
//                     } 
//                  }   /*if v_dev_active*/
//               
//               if(not v_any_dev_active)  
//                  break;
//            }   /*for loop_i*/
//            devsetholdstates(SiteToEsda);
//            PrintResultParam(str5,tnum,tmp_results,0ua,40ua,bccval,GL_PLELL_FORMAT);
//         }   /*for loop_v*/
//         
//      }   /*if v_any_dev_active*/
//       /*+++ end bcc0 histogram & record worst bit info +++*/
//      
//      devsetholdstates(savesites);
//      
//      TL_SetArbAddr(0x0,0x0);
//
//      TIStdScreenPrint = savescreenprint;
//      
//      if(tistdscreenprint)  
//      {
//         fdlen1  = 30;
//         fdlen2  = 12;
//         decpt   = 3;
//
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               cout << endl;
//               cout << TIWindow << "Site" << site:-5 << "IV Curve results:  Address == " << faddr[site]:s_hex:-12 << " SenAmp == " << senampnum[site]:-5 << endl;
//               cout << endl;
//
//               cout << "VCG":-fdlen1 << "TCR1 (ua)":fdlen2 << " " << "TCR6 (ua)":fdlen2 << endl;
//
//               counter = 1;
//               
//               for loop_v = start_v to stop_v by inc_v do
//               {
//                  tmpreal = single(loop_v/1v);
//                  cout << tmpreal:-fdlen1:decpt;
//                  tmpreal = single(tcr1_val[counter][site]/1uA);
//                  cout << tmpreal:fdlen2:decpt << " ";
//                  tmpreal = single(tcr6_val[counter][site]/1uA);
//                  cout << tmpreal:fdlen2:decpt << endl;
//                  counter = counter+1;
//                  if(counter>FL_IV_DATA_COUNT)  
//                     break;
//               }   /*loop_v*/
//               cout << endl;
//               cout << endl;
//            }   /*if v_dev_active*/
//      } 
//                  
//            
//            
//   }   /*if v_any_dev_active*/
//} 
//
//
// /*take bitmap, iv curve using tcr1 & tcr6*/
// /*parameters: vcorner = VMN/VNM/VMX,  banknum = 0/1/2...,  bkgrnd_data = (0=zeros, 1=ones, 2=evenchk, 3=oddchk, 10=arbitrary)*/
// /*            start_senamp/stop_senamp = logical sense amp number, i.e. 0=most left, 143=most right*/
//void TL_PER_SENSEAMP_CHARZ(VCornerType vcorner,
//                                IntS banknum,
//                                IntS bkgrnd_data,
//                                  IntS start_senamp, IntS stop_senamp)
//{
//   const IntS TNUM_COF = 0x00020000; 
//   const IntS TNUM_PVFY_ESDA = 0x41020000; 
//   const  TNUM_TARGET_ARB = 0x00000A00;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS IND_FCOUNT_MSW = 9; 
//   const IntS IND_FCOUNT_LSW = 10; 
//   const IntS IND_STARTADDR = 11; 
//   const  STARTFLAG = 0xFEDE;  /* :MANUAL FIX REQUIRED: Unknown const type */
//
//   IntS site,bank,count,tnum,pulse_ulim,testnum;
//   IntS stnum_pgm,stnum_pv,stnum_tcr1,stnum_tcr6;
//   BoolM final_results,tmp_results;
//   BoolM savesites,logsites,SiteToEsda,disallsites;
//   FloatS maxtime,tdelay1,tdelay2,tdelay3,ttimer1;
//   FloatM ttimer2,tt_timer;
//   IntS blkstart,blkstop,imgesda,i,j,k,dbit;
//   IntM pgmpulse,expfailcnt;
//   StringS str1,str2,str3,str4,str5,current_shell,s;
//   FloatS vcg_start,vcg_stop,vcg_inc;
//   FloatS iref_start,iref_stop,iref_inc;
//   FloatS start_v,stop_v,inc_v,loop_v,loop_i;
//   BoolS found_bit;
//   IntM1D fdata(11);
//   IntM fdata_index,fdata_bitindex;
//   IntM faddr,faddr_save,msw_data,lsw_data,senampnum;
//   IntS senamp,addr_loc,address,addr_lo,addr_hi;
//   FloatM istartarr,istoparr,vforcearr;
//   FloatM bccval;
//   IntS addr_offset,counter,tdata,pattype;
//   IntS fdlen1,fdlen2,decpt;
//   FloatS tmpFloatS;
//   FloatM1D tcr1_val(513),tcr6_val(513);
//   BoolS savescreenprint;
//   IntS iomin,iomax,iter;
//
//   if(v_any_dev_active)  
//   {
//      timernstart(ttimer1);
//      savesites = v_dev_active;
//      final_results = v_dev_active;
//      SiteToEsda = v_dev_active;
//      disallsites = false;
//
//      tdelay1 = 10ms;
//      tdelay2 = 2ms;
//      tdelay3 = 100ms;
//      maxtime = GL_F021_BANK_MAXTIME;
//      imgesda = 500;
//      
//      switch(vcorner) {
//        case  VMN: case VMNO: case VMNE :   
//           PowerUpAtVmin(dcsetup_loosevmin,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vmin],v[vil_loose]);
//         break; 
//        case  VNM: case VNMO: case VNME :   
//           PowerUpAtVnom(dcsetup_loosevnom,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vnom],v[vil_loose]);
//         break; 
//        case  VMX: case VMXO: case VMXE :   
//           PowerUpAtVmax(dcsetup_loosevmax,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vmax],v[vil_loose]);
//         break; 
//        default:  
//           PowerUpAtVnom(dcsetup_loosevnom,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vnom],v[vil_loose]);
//         break;            
//      }   /* case */
//
//      TIME.Wait(tdelay2);
//      
//      current_shell = "FlashShell";
//      if(GL_PREVIOUS_SHELL != current_shell)        
//         patternexecute(spareint1,f021_shell_loadpat);
//
//      pattype = BANKTYPE;
//      
//      switch(bkgrnd_data) {
//        case 0 : tdata = TNUM_DATA_0s;
//        case 1 : tdata = TNUM_DATA_1s;
//        case 2 : tdata = TNUM_DATA_ECHK;
//        case 3 : tdata = TNUM_DATA_OCHK;
//        case 10 : tdata = TNUM_DATA_ARBITRARY;
//        default: tdata = TNUM_DATA_0s;
//      }   /* case */
//      
//      stnum_tcr6 = TNUM_TCR6+TNUM_MULT1+tdata+(banknum<<4);
//
//      vcg_start = 1.825V;
//      vcg_stop  = 1.825V;
//      vcg_inc   = 1V;
//      iref_start = 20uA;
//      iref_stop  = 0.25uA;
//      iref_inc   = 0.25uA;
//
//       /*+++ bcc0 histogram & record worst bit info +++*/
//      if(v_any_dev_active)  
//      {
//          /*do bcc0 histogram & record worst bit info*/
//         tnum = stnum_tcr6;
//         GL_DO_GET_WORSTBIT = true;
//         TL_BitHistogram(pattype,tnum,vcg_start,vcg_stop,vcg_inc,iref_start,iref_stop,iref_inc,false,"");
//         GL_DO_GET_WORSTBIT = false;
//
//         switch(banknum) {
//             switch(switch(0 : addr_offset = 0x08000000;
//               switch(switch(switch(1 : addr_offset = 0x08080000;
//                 switch(switch(switch(switch(2 : addr_offset = 0xF0200000;   /*emu bank*/
//         }   /* case */
//         
//          /*parse to enable one worst bit*/
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               found_bit = false;
//               faddr[site] = addr_offset + (FL_WORSTBIT_FADDR[site]<<4);
//               faddr_save[site] = FL_WORSTBIT_FADDR[site];
//               TL_Get_PhysSenAmp_From_ESDA_WorstBit(site,senamp,i,j);
//               senampnum[site] = senamp;
//               fdata_index[site] = i;
//               fdata_bitindex[site] = j;
//               if(tistdscreenprint)  
//               {
//                  cout << "Site" << site:-5 << " BitHistogram FADDR == " << faddr[site]:s_hex:-12 << " SA == " << senampnum[site]:-5 << endl;
//                  cout << "FDATA == ";
//                  for (i = 1;i <= 10;i++)
//                     cout << FL_WORSTBIT_FDATA[i][site]:s_hex:-7 << "  ";
//                  cout << endl;
//               } 
//            }   /*v_dev_active*/
//
//         savescreenprint = TIStdScreenPrint;
//         if(not TI_FlashDebug)  
//            TIStdScreenPrint = false;
//            
//         iomin = start_senamp;  /*0;*/
//         iomax = stop_senamp;  /*F021_Flash.DATAWIDTH-1;*/
//         
//         for (senamp = iomin;senamp <= iomax;senamp++)
//         {
//            if(TI_FlashDebug)  
//               if(Inkey(s))   break;
//
//             /*+++ iv curve tcr1 +++*/
//             /*taking iv serially*/
//            start_v = 1V;
//            stop_v  = 6.5V;
//            inc_v   = 0.25V;
//            devsetholdstates(disallsites);
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(SiteToEsda[site])  
//               {
//                  devsetholdstate(site,true);
//                  address = faddr[site];
//                  GL_DO_SAVE_IV_DATA = true;
//                  TL_IV_Curve(address,senamp,start_v,stop_v,inc_v,false,1v,false);
//                  GL_DO_SAVE_IV_DATA = false;
//                  for (i = 1;i <= FL_IV_DATA_COUNT;i++)
//                     tcr1_val[i][site] = FL_IV_DATA[i][site];
//                  devsetholdstate(site,false);
//               } 
//             /*devsetholdstates(SiteToEsda);*/
//             /*+++ end iv curve tcr1 +++*/
//
//
//             /*+++ iv curve tcr6 +++*/
//            devsetholdstates(disallsites);
//             /*discard(patternexecute(spareint1,f021_shell_loadpat));*/
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(SiteToEsda[site])  
//               {
//                  devsetholdstate(site,true);
//                  addr_hi = (faddr[site]&0xFFFF0000)>>16;
//                  addr_lo = faddr[site]&0x0000FFFF;
//                  TL_SetArbAddr(addr_hi,addr_lo);
//                  TL_SetArbLength(0x0,0x12);  /*18bytes*/
//                  devsetholdstate(site,false);
//               } 
//            devsetholdstates(SiteToEsda);
//            
//            tnum = stnum_tcr6+TNUM_TARGET_ARB+TNUM_TOPTION_ESDARD;
//            
//            PrintHeaderBool(GL_PLELL_FORMAT);
//            
//            counter = 0;
//            
//            for loop_v = start_v to stop_v by inc_v do
//            {
//               counter = counter+1;
//               if(TI_FlashDebug)  
//                  if(Inkey(s))   break;
//               bccval = 0uA;
//               
//                /*sweep from pass-to-fail*/
//               for loop_i = iref_start downto iref_stop by iref_inc do
//               {
//                  if(TI_FlashDebug)  
//                     if(Inkey(s))   break;
//                  TRealToStr(loop_v,str4);
//                  str5 = "TCR6" + str2;
//                  str5 = str5 + "_";
//                  str5 = str5 + str4;
//                  str5 = str5 + "_";
//                  TRealToStr(loop_i,str4);
//                  str5 = str5 + str4;
//                  
//                  STDSetVRange(FLTP2,2.5v);
//                  STDSetVI(FLTP2,2.5v,loop_i);
//                  STDSetVRange(FLTP1,loop_v);
//                  STDSetVI(FLTP1,loop_v,100ma);
//                  TIME.Wait(tdelay2);
//                  f021_runtestnumber(tnum,maxtime,tt_timer,tmp_results);
//                  F021_TurnOff_AllTpads;
//               
//                   /*check if bit fail*/
//                  if(not GL_DO_ESDA_WITH_SCRAM)  
//                     F021_GetESDA_NonSCRAM(500,bank);
//                  else
//                     Get_Flash_ESDASpace_SCRAM;
//                  
//                   /*get fail count*/
//                  expfailcnt = FL_SCRAM_CAPT_ARR[IND_FCOUNT_MSW];
//                  arraymultintegervalue(expfailcnt,expfailcnt,0x10000,v_sites);
//                  arrayaddinteger(expfailcnt,expfailcnt,FL_SCRAM_CAPT_ARR[IND_FCOUNT_LSW],v_sites);
//                  
//                  if(tistdscreenprint and TI_FlashDebug)  
//                  {
//                     cout << "Vcg == " << loop_v << " Iref == " << loop_i << endl;
//                     for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                        if(v_dev_active[site])  
//                        {
//                           cout << "Site" << site:-5 << " Failcount == " << expfailcnt[site] << endl;
//                           readramaddress(site,ADDR_RAM_REPAIR_SOL,ADDR_RAM_REPAIR_SOL+(16*ADDR_RAM_INC));
//                        } 
//                  } 
//                  
//                  for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                     if(v_dev_active[site])  
//                     {
//                        if(expfailcnt[site]>0)  
//                        {
//                           i = senamp div 16;
//                           j = senamp mod 16;  /*fdata_bitindex[site];*/
//                           k = ((FL_SCRAM_CAPT_ARR[IND_STARTADDR+i+3][site]) >> j) &0x01;
//                           if(tistdscreenprint and TI_FlashDebug)  
//                           {
//                               /*writeln(tiwindow,"i=",i:-5," senamp=",senamp:-5," j=",j:s_hex:-7," k=",k:s_hex:-7);*/
//                              cout << "FL_SCRAM_CAPT_ARR["][IND_STARTADDR+i+3]["] " << FL_SCRAM_CAPT_ARR[IND_STARTADDR+i+3][site]:s_hex << endl;
//                           } 
//                        
//                           if(k==1)  
//                           {
//                              bccval[site] = loop_i;
//                              tcr6_val[counter][site] = loop_i;
//                              if(tistdscreenprint)  
//                              {
//                                 cout << "Site" << site:-5 << str5 << " " << bccval[site] << endl;
//                                  /*if(TI_FlashDebug) then
//                                     readramaddress(site,0x500,0x52c);*/
//                              } 
//                              devsetholdstate(site,false);
//                           }
//                           else if(loop_i <== iref_stop)  
//                           {
//                              tcr6_val[counter][site] = 0uA;
//                           } 
//                           
//                            /*if(v_dev_active[site] and tistdscreenprint and TI_FlashDebug) then
//                            begin
//                               writeln(tiwindow,str5);
//                               readramaddress(site,0x500,0x52c);
//                            end;*/
//                        } 
//                     }   /*if v_dev_active*/
//                  
//                  if(not v_any_dev_active)  
//                     break;
//               }   /*for loop_i*/
//               devsetholdstates(SiteToEsda);
//               PrintResultParam(str5,tnum,tmp_results,0ua,40ua,bccval,GL_PLELL_FORMAT);
//            }   /*for loop_v*/
//
//            tistdscreenprint = true;
//
//            if(tistdscreenprint)  
//            {
//               fdlen1  = 30;
//               fdlen2  = 12;
//               decpt   = 3;
//               
//               devsetholdstates(SiteToEsda);
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                  {
//                     cout << endl;
//                     cout << TIWindow << "Site" << site:-5 << "IV Curve results:  Address == " << faddr[site]:s_hex:-12 << " SenAmp == " << senamp:-5 << endl;
//                     cout << endl;
//                     cout << "VCG":-fdlen1 << "TCR1 (ua)":fdlen2 << " " << "TCR6 (ua)":fdlen2 << endl;
//                     
//                     counter = 1;
//                     
//                     for loop_v = start_v to stop_v by inc_v do
//                     {
//                        tmpreal = single(loop_v/1v);
//                        cout << tmpreal:-fdlen1:decpt;
//                        tmpreal = single(tcr1_val[counter][site]/1uA);
//                        cout << tmpreal:fdlen2:decpt << " ";
//                        tmpreal = single(tcr6_val[counter][site]/1uA);
//                        cout << tmpreal:fdlen2:decpt << endl;
//                        counter = counter+1;
//                        if(counter>FL_IV_DATA_COUNT)  
//                           break;
//                     }   /*loop_v*/
//                     cout << endl;
//                     cout << endl;
//                  }   /*if v_dev_active*/
//               if(not TI_FlashDebug)  
//                  tistdscreenprint = false;
//            }   /*screenprint*/
//                  
//         }   /*for senamp*/
//         
//      }   /*if v_any_dev_active*/
//       /*+++ end bcc0 histogram & record worst bit info +++*/
//      
//      devsetholdstates(savesites);
//      
//      TL_SetArbAddr(0x0,0x0);
//
//      TIStdScreenprint = true;
//      if(tistdscreenprint)  
//      {
//         cout << "TL_Per_SenseAmp_Charz TT == " << timernread(ttimer1) << endl;
//         cout << endl;
//      } 
//
//      TIStdScreenPrint = savescreenprint;
//      
//            
//   }   /*if v_any_dev_active*/
//} 
//   
//BoolS FlashCode_WR_EXE_func(StringS tname,
//                               FlashCodeType code_type,
//                               BoolM test_results)
//{
//   const IntS NONE_OPT = 0; 
//   const IntS SCPL_OPT = 1; 
//
//   BoolM savesites,logsites;
//   BoolM tmp_results,final_results;
//   FloatS ttimer1,ttimer2,tfreq;
//   FloatM tt_timer;
//   StringS str1,str2,str3,str4;
//   IntS testnum,length,special_opt;
//   FloatM FloatSval;
//   TWunit unitval;
//   StringS fl_testname;
//   FloatS maxtime,tdelay;
//   StringS tpatt;
//   vcornertype vcorner;
//
//   if(V_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ FlashCode_WR_EXE_func +++++" << endl;
//
//      writestring(str1,tname);
//      length = len(str1);
//      writestring(str1,mid(str1,2,length-6));
//      fl_testname = tname;
//      
//      timernstart(ttimer1);      
//
//      savesites = V_dev_active;
//      final_results = V_dev_active;
//
//      testnum = TNUM_PROG_RANDCODE;
//
//      maxtime = GL_F021_BANK_PGM_MAXTIME;
//      tdelay  = 2ms;
//
//      if(F021_RunCode.DO_RUNCODE_ENA[code_type])  
//      {
//         if(code_type==OtpSCPL)  
//            special_opt = SCPL_OPT;
//         else
//            special_opt = NONE_OPT;
//
//         TestOpen(fl_testname);
//
//         vcorner = F021_RunCode.PROG_VDDCORNER[code_type];
//         tfreq   = F021_RunCode.PROG_FREQ[code_type];
//         switch(vcorner) {
//           case  VMN: case VMNO: case VMNE :   
//              PowerUpAtVmin(dcsetup_loosevmin,norm_fmsu);
//              ClockSet(S_CLOCK1A,false,tfreq,
//                    v[vih_loose_osc_vmin],v[vil_loose]);
//            break; 
//           case  VNM: case VNMO: case VNME :   
//              PowerUpAtVnom(dcsetup_loosevnom,norm_fmsu);
//              ClockSet(S_CLOCK1A,false,tfreq,
//                    v[vih_loose_osc_vnom],v[vil_loose]);
//            break; 
//           case  VMX: case VMXO: case VMXE :   
//              PowerUpAtVmax(dcsetup_loosevmax,norm_fmsu);
//              ClockSet(S_CLOCK1A,false,tfreq,
//                    v[vih_loose_osc_vmax],v[vil_loose]);
//            break; 
//           default:  
//              PowerUpAtVnom(dcsetup_loosevnom,norm_fmsu);
//              ClockSet(S_CLOCK1A,false,tfreq,
//                    v[vih_loose_osc_vnom],v[vil_loose]);
//            break;            
//         }   /* case */
//
//         TIME.Wait(tdelay);
//
//         PrintHeaderBool(GL_PLELL_FORMAT);
//
//         for (tpatt = F021_RunCode.FIRST_PROGPAT[code_type];tpatt <= F021_RunCode.LAST_PROGPAT[code_type];tpatt++)
//         {
//            logsites = v_dev_active;
//
//            if(special_opt==NONE_OPT)  
//            {
//               patternexecute(spareint1,tpatt);
//               tmp_results = v_pf_status;
//               ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//               writestring(str2,tpatt);
//               PrintResultBool(str2,0,tmp_results,GL_PLELL_FORMAT);
//               
//               F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results);
//               ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//               PrintResultBool(str1,testnum,tmp_results,GL_PLELL_FORMAT);
//            }
//            else
//            {
//                /*SCPL_OPTion*/
//               discard(f021_matchloopbypmu_ms(tpatt,F021_PASSPIN,F021_DONEPIN,F021_NDONEPIN,
//                       maxtime,1,tt_timer,tmp_results));
//               ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//               PrintResultBool(str1,testnum,tmp_results,GL_PLELL_FORMAT);
//            } 
//               
//            if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//            {
//               writestring(str3,str1,tpatt);
//               F021_Log_FailPat_To_TW(str3,tmp_results,fl_testname);
//            } 
//            
//            if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//               Devsetholdstates(final_results);
//            
//            if(not v_any_dev_active)  
//               break;
//         }   /*for tpatt*/
//
//         Devsetholdstates(savesites);
//
//         ResultsRecordActive(final_results, S_NULL);
//         TestClose;
//
//         test_results = final_results;
//      
//         ttimer1 = timernread(ttimer1);
//         tt_timer = ttimer1;
//         
//         str4 = str1 + "_TTT";
//         TWTRealToRealMS(tt_timer,realval,unitval);
//         TWPDLDataLogRealVariable(str4, unitval,realval,TWMinimumData);
//         
//         if(tistdscreenprint)  
//         {
//             /*PrintResultBool(str1,testnum,final_results,GL_PLELL_FORMAT);*/
//            cout << "   TT " << ttimer1 << endl;
//            cout << endl;
//         }         /*if tistdscreenprint*/
//      
//         if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//            DevSetHoldStates(final_results);
//      }   /*if do_runcode_ena*/
//
//      ClockStopFreeRun(s_clock1a);
//      powerdownall;
//      GL_PREVIOUS_SHELL = "";
//   }   /*if v_any_dev_active*/
//
//   FlashCode_WR_EXE_func = V_any_dev_active;
//}   /*FlashCode_WR_EXE_func*/
//   
//BoolS FlashCode_RdPsa_func(StringS tname,
//                              FlashCodeType code_type,
//                              BoolM test_results)
//{
//   BoolM savesites,logsites;
//   BoolM tmp_results,final_results;
//   FloatS ttimer1,ttimer2,tfreq;
//   FloatM tt_timer;
//   StringS str1,str2,str3,str4;
//   IntS testnum,length,special_opt;
//   FloatM FloatSval;
//   TWunit unitval;
//   StringS fl_testname;
//   FloatS maxtime,tdelay;
//   vcornertype vcorner;
//   IntS bank,stnum;
//
//   if(V_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ FlashCode_RdPsa_func +++++" << endl;
//
//      writestring(str1,tname);
//      length = len(str1);
//      writestring(str1,mid(str1,2,length-6));
//      fl_testname = tname;
//      
//      timernstart(ttimer1);      
//
//      if(F021_RunCode.DO_RDPSA_ENA[code_type])  
//      {
//         stnum = TNUM_BANK_RD0S+TNUM_TOPTION_PSARD;
//         maxtime = GL_F021_BANK_PGM_MAXTIME;
//         tdelay  = 2ms;
//         vcorner = F021_RunCode.PROG_VDDCORNER[code_type];
//         tfreq   = F021_RunCode.PROG_FREQ[code_type];
//         switch(vcorner) {
//           case  VMN: case VMNO: case VMNE :   
//              PowerUpAtVmin(dcsetup_loosevmin,norm_fmsu);
//              ClockSet(S_CLOCK1A,false,tfreq,
//                    v[vih_loose_osc_vmin],v[vil_loose]);
//            break; 
//           case  VNM: case VNMO: case VNME :   
//              PowerUpAtVnom(dcsetup_loosevnom,norm_fmsu);
//              ClockSet(S_CLOCK1A,false,tfreq,
//                    v[vih_loose_osc_vnom],v[vil_loose]);
//            break; 
//           case  VMX: case VMXO: case VMXE :   
//              PowerUpAtVmax(dcsetup_loosevmax,norm_fmsu);
//              ClockSet(S_CLOCK1A,false,tfreq,
//                    v[vih_loose_osc_vmax],v[vil_loose]);
//            break; 
//           default:  
//              PowerUpAtVnom(dcsetup_loosevnom,norm_fmsu);
//              ClockSet(S_CLOCK1A,false,tfreq,
//                    v[vih_loose_osc_vnom],v[vil_loose]);
//            break;            
//         }   /* case */
//
//         TIME.Wait(tdelay);
//         F021_LoadFlashShell_func;
//
//         savesites = V_dev_active;
//         final_results = V_dev_active;
//         tmp_results = V_dev_active;
//
//         TestOpen(fl_testname);
//
//         PrintHeaderBool(GL_PLELL_FORMAT);
//
//         for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//         {
//            if(F021_RunCode.MEMCFG[code_type][bank]>==0)  
//            {
//               logsites = v_dev_active;
//               testnum = stnum + (F021_RunCode.TDATA[code_type][bank]<<12) + (F021_RunCode.MEMCFG[code_type][bank]<<8) + (bank<<4);
//               MBox_Upload_RCODE_PSA(bank,code_type);
//               F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results);
//               ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//
//               writestring(str2,bank:1);
//               str2 = "_B" + str2;
//               str3 = str1 + str2;
//               PrintResultBool(str3,testnum,tmp_results,GL_PLELL_FORMAT);
//
//               if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//                  F021_Log_FailPat_To_TW(str3,tmp_results,fl_testname);
//               
//               if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//                  Devsetholdstates(final_results);
//               
//               if(not v_any_dev_active)  
//                  break;
//            }   /*if memcfg*/
//
//            if(not v_any_dev_active)  
//               break;
//         }   /*bank*/
//
//         Devsetholdstates(savesites);
//
//         ResultsRecordActive(final_results, S_NULL);
//         TestClose;
//
//         test_results = final_results;
//      
//         ttimer1 = timernread(ttimer1);
//         tt_timer = ttimer1;
//         
//         str4 = str1 + "_TTT";
//         TWTRealToRealMS(tt_timer,realval,unitval);
//         TWPDLDataLogRealVariable(str4, unitval,realval,TWMinimumData);
//         
//         if(tistdscreenprint)  
//         {
//             /*PrintResultBool(str1,testnum,final_results,GL_PLELL_FORMAT);*/
//            cout << "   TT " << ttimer1 << endl;
//            cout << endl;
//         }         /*if tistdscreenprint*/
//      
//         if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//            DevSetHoldStates(final_results);
//      }  /*if do_rdpsa_ena*/
//      else
//      {
//         if(tistdscreenprint)  
//            cout << str1 << " not enabled" << endl;
//      } 
//   }   /*if v_any_dev_active*/
//
//   FlashCode_RdPsa_func = V_any_dev_active;
//} 
//   
//   
TMResultM  F021_Special_Program_func(IntS start_testnum,
                                   StringS tname,
                                   IntS PPULimit,
                                   BoolM test_results,
                                   BoolM soft_results)
{
//   const IntS none_ena = 0; 
//   const IntS cmpress_ena = 1; 
//   const IntS avnv_ena = 2; 
//   const IntS pmos_ena = 3; 
//   const IntS efchksum_ena = 4; 
//   const IntS TARGET_BANK = 0; 
//   const IntS TARGET_SECT = 1; 
//   const IntS TARGET_OTP = 4; 
//   const IntS TARGET_SEMIOTP = 5; 
//   const IntS TARGET_DATAOTP = 6; 
//   const IntS TOPT_SW_COMPRESS = 0x31; 
//
//   BoolM savesites,logsites,good_results;
//   IntM pgmpulse;
     TMResultM  tmp_results,final_results;
//   IntS bankcount,count;
//   IntS site,opertype,pattype;
//   FloatS ttimer1,ttimer2;
//   FloatM tt_timer;
//   StringS tmpstr1,tmpstr2,tmpstr3,tmpstr4;
//   IntS testnum,start_tnum;
//   FloatM FloatSval;
//   TWunit unitval;
//   StringS fl_testname;
//   FloatS maxtime;
//   IntS1D addr_loc(4);
//   IntS length;
//   FloatM vhvprog_val,vhvpvfy_val;
//   IntM cmpr_factor1,cmpr_factor2;
//   IntS addr_loc_mbox;
//   IntS wr_flag_num;
//   IntM src_data1,src_data2;
//   BoolS hexvalue,nothexvalue;
//   BoolS bcd_format,notbcd;
//   BoolS firsttime;
//   IntM rti_timer;
//   StringM site_cof_inst_str;
//   IntS target_bits;
//   IntS pulse_ulim,screen_ulim;
//   IntS blkstart,blkstop;
//   BoolS dlogonly,faildetect;
//
//   if(V_any_dev_active)  
//   {
//      if(tistdscreenprint and TI_FlashDebug)  
//         cout << "+++++ F021_Special_Program_func +++++" << endl;
//
//      opertype = none_ena;   /*set to default normal operation*/
//      dlogonly = false;
//
//      writestring(tmpstr1,tname);
//      length = len(tmpstr1);
//      writestring(tmpstr1,mid(tmpstr1,2,length-6));
//      fl_testname = tname;
//      
//      timernstart(ttimer1);      
//
//      TestOpen(fl_testname);
//
//      if(TI_FlashCOFEna)  
//         F021_Init_COF_Inst_Str(site_cof_inst_str);
//
//      savesites = V_dev_active;
//      final_results = V_dev_active;
//      good_results = V_dev_active;
//
//      testnum = start_testnum;
//
//       /*otp template pgm w/ eng override*/
//      if(testnum == TNUM_OTP_PROG_TEMPLATE)  
//      {
//         opertype = pmos_ena;
//         pattype = OTPTYPE;
//      }
//      else
//      {
//         target_bits = (testnum & 0x00000f00) >>8;
//         switch(target_bits) {
//           case TARGET_BANK    : pattype = BANKTYPE;
//           case TARGET_SECT    : pattype = SECTTYPE;
//           TARGET_OTP,
//           TARGET_SEMIOTP,
//           case TARGET_DATAOTP : pattype = OTPTYPE;
//           default:     pattype = MODTYPE;
//         }   /*case*/
//         
//          /*check override pulse limits bit22*/
//         if((testnum&0x00400000)>0)  
//         {
//            if(tistdscreenprint)  
//            {
//               cout << endl;
//               cout << "*** WARNING: OVERRIDE PULSE LIMITS is Enable." << 
//                    "  MAKE SURE THIS IS INTENTIONALLY DONE SO <<  i.e. Engineering Debug Only ***" << endl;
//               cout << endl;
//            } 
//             /*make sure not use in production unless*/
//            if(not ti_flashcofena)  
//            {
//               pattype = MODTYPE;
//               if(tistdscreenprint)  
//                  cout << "*** PLS SET TI_FlashCOFEna true" << 
//                       " IF INTENTION OVERRIDE PULSE LIMITS. ***" << endl;
//            } 
//         } 
//      } 
//      
//       /*check bank/sector bits*/
//      if((((testnum&0x00000070)>>4)!=0) or ((testnum&0x0000000f)!=0))  
//      {
//         if(tistdscreenprint)  
//            cout << "*** ERROR: Bank/Sector bits are not start @0." << 
//                    "  Please double check!!! ***" << endl;
//         if(not tistdscreenprint)  
//            cout << "*** ERROR: Bank/Sector bits are not start @0." << 
//                    "  Please double check!!! ***" << endl;
//         pattype = MODTYPE;
//      } 
//
//            
//      if(TI_FlashESDAEna)  
//         FLEsda.Pattype  = pattype;
//
//      if(pattype == MODTYPE)  
//      {
//          /*+++ Module operation +++*/
//         final_results = false;
//         if(tistdscreenprint)  
//            cout << "+++ WARNING : Invalid Test Number Entered +++" << endl;
//      }
//      else 
//      {
//          /*++++++++ Bank operation ++++++++*/
//     if((testnum&0x0f000000)==0x03000000)  
//            maxtime = GL_F021_BANK_SWPGM_MAXTIME;
//     else
//            maxtime = GL_F021_BANK_PGM_MAXTIME;
//
//         pulse_ulim = BANK_PROG_ULimit;
//         screen_ulim = PPULimit;
//
//         if(tistdscreenprint)  
//            PrintHeaderErsProg(0,screen_ulim,0,0,0,0,(not GL_PLELL_FORMAT));
//
//         for (bankcount = 0;bankcount <= F021_Flash.MAXBANK;bankcount++)
//         {
//            if((pattype==BANKTYPE) or (pattype==OTPTYPE))  
//            {
//               blkstart = bankcount;
//               blkstop  = bankcount;
//            }
//            else if(pattype==BLOCKTYPE)  
//            {
//               blkstart = 0;
//               blkstop  = F021_Flash.MAXBLOCK[bankcount];
//            }
//            else
//            {
//               blkstart = 0;
//               blkstop  = F021_Flash.MAXSECT[bankcount];
//            } 
//
//            testnum  = start_testnum+(bankcount<<4);
//
//            for (count = blkstart;count <= blkstop;count++)
//            {
//               logsites = v_dev_active;
//               tmp_results = v_dev_active;
//               F021_RunTestNumber(testnum,maxtime,tt_timer,tmp_results);
//               ArrayAndBoolean(final_results,final_results,tmp_results,v_sites);
//               
//               pgmpulse = 0;
//               Get_TLogSpace_MaxPPulse(pgmpulse);
//
//                /*pass/fail per limit*/
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site])  
//                  {
//                      /*check gross limit*/
//                     if(pgmpulse[site] > pulse_ulim)  
//                     {
//                        tmp_results[site] = false;
//                        final_results[site] = false;
//                     }
//                     else if(pgmpulse[site] > screen_ulim)  
//                     {
//                        good_results[site] = false;
//                     } 
//                  } 
//               
//                /*log to TW*/
//                /*tw string: PGMx_B#_TT and PGMx_B#_PGM_PLS*/
//               writestring(tmpstr2,bankcount:1);
//               tmpstr2 = "_B" + tmpstr2;  /*_B#*/
//
//               if((pattype==BLOCKTYPE) or (pattype==SECTTYPE))  
//               {
//                  writestring(tmpstr3,count:1);
//                  if(pattype==BLOCKTYPE)  
//                     tmpstr3 = "BLK" + tmpstr3;
//                  else
//                     tmpstr3 = "S" + tmpstr3;
//                  tmpstr2 = tmpstr2 + tmpstr3;
//               } 
//
//               tmpstr3 = tmpstr1 + tmpstr2;  /*now has PGMx_B#*/
//               tmpstr4 = tmpstr3 + "_TT";
//               TWTRealToRealMS(tt_timer,realval,unitval);
//               TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//            
//               tmpstr4 = tmpstr3 + "_PGM_PLS";
//               TWPDLDataLogVariable(tmpstr4,pgmpulse, TWMinimumData);
//               
//                /*log RTI timer (internal vclock cycle value) to tw*/
//               rti_timer = 0;
//               GetRTIValue(rti_timer);
//               tmpstr4 = tmpstr3 + "_RTI_TT";
//               TWPDLDataLogVariable(tmpstr4,rti_timer, TWMinimumData);
//               
//               if(tistdscreenprint)  
//                  PrintResultErsProg(tmpstr3,testnum,pgmpulse,pgmpulse,pgmpulse,
//                                     0,screen_ulim,0,0,0,0,(not GL_PLELL_FORMAT));
//
//                /*log failed test to tw*/
//                /*KChau 12/21/07 - determine if any site is failing to log to TW.*/
//               if(not ArrayCompareBoolean(logsites,tmp_results,v_sites))  
//               {
//                  F021_Log_FailPat_To_TW(tmpstr3,tmp_results,fl_testname);
//                  
//                  if(TI_FlashCOFEna)  
//                     F021_Update_COF_Inst_Str(tmpstr2,site_cof_inst_str,tmp_results);
//
//                  if(TI_FlashESDAEna)  
//                     if((pattype==BANKTYPE) or (pattype==OTPTYPE))  
//                        SetFlashESDAVars(tmp_results,bankcount,bankcount);
//                     else
//                        SetFlashESDAVars(tmp_results,bankcount,count);
//               } 
//               
//               testnum = testnum+1; 
//
//               if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//                  Devsetholdstates(final_results);
//               
//               if(not v_any_dev_active)  
//                  break;
//            }   /*for count*/
//            if(not v_any_dev_active)  
//               break;
//         }   /*for bankcount*/
//      }    /*+++ End of Bank operation +++*/
//
//       /*restore all active sites*/
//      Devsetholdstates(savesites);
//
//      ResultsRecordActive(final_results, S_NULL);
//      TestClose;
//
//      test_results = final_results;
//      soft_results = good_results;
//      
//      if(TI_FlashCOFEna)  
//         F021_Save_COF_Info(tmpstr1,site_cof_inst_str,final_results);
//      
//      ttimer1 = timernread(ttimer1);
//      tt_timer = ttimer1;
//
//      tmpstr4 = tmpstr1 + "_TTT";
//      TWTRealToRealMS(tt_timer,realval,unitval);
//      TWPDLDataLogRealVariable(tmpstr4, unitval,realval,TWMinimumData);
//
//      if(tistdscreenprint)  
//      {
//          /*PrintHeaderBool(GL_PLELL_FORMAT);*/
//         PrintResultBool(tmpstr1,start_testnum,final_results,GL_PLELL_FORMAT);
//         tmpstr4 = tmpstr1 + "_SFTBIN";
//         PrintResultBool(tmpstr4,start_testnum,soft_results,GL_PLELL_FORMAT);
//         cout << "   TT " << ttimer1 << endl;
//         cout << endl;
//      }         /*if tistdscreenprint*/
//      
//      if((not TIIgnoreFail) and (not TI_FlashCOFEna))  
//         DevSetHoldStates(final_results);
//            
//   }   /*if v_any_dev_active*/
//
//   F021_Special_Program_func = V_any_dev_active;
     return(final_results);
}   /* F021_Special_Program_func */
//
// /*display OTP decoded ratio word8/9 for 144bit bank*/
//void TL_Display_W89()
//{
//   const IntS IND_W8_0 = 64; 
//   const IntS IND_W8_7 = 71; 
//   const IntS IND_W9_0 = 72; 
//   const IntS IND_W9_7 = 79; 
//
//   IntS site,bank,count,loop;
//   IntS int1,int2,int3,int4;
//   BoolM tmp_results,final_results;
//   IntM cv_nmos,cv_pmos,cv_pc,cv_ena;
//   IntM ev_nmos,ev_pmos,ev_pc,ev_ena;
//   IntM pv_nmos,pv_pmos,pv_pc,pv_ena;
//   IntM rm0_nmos,rm0_pmos,rm0_pc,rm0_ena;
//   IntM rm1_nmos,rm1_pmos,rm1_pc,rm1_ena;
//   IntM rd_nmos,rd_pmos,rd_pc,rd_ena;
//   StringS str1,str2,str3;
//
//   if(v_any_dev_active)  
//   {
//      F021_ReadLog1OTP_func(tmp_results,1);
//
//      PrintHeaderBool(GL_PLELL_FORMAT);            
//
//      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//      {
//         writestring(str3,bank:1);
//         str3 = "_B" + str3;
//         
//         for (loop = 0;loop <= 1;loop++)
//         {
//            if(loop==0)  
//            {
//               count = IND_W8_0;
//               str2 = "W8_";
//            }
//            else
//            {
//               count = IND_W9_0;
//               str2 = "W9_";
//            } 
//
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                   /*cv*/
//                  int1 = OTP_LOG1_INFO_VAL[bank][count][site];
//                  int2 = OTP_LOG1_INFO_VAL[bank][count+3][site];
//                  cv_nmos[site] = ((int2&0x1) <<4) + ((int1&0xf000) >>12);
//                  cv_pmos[site] = (int2&0x3e) >>1;
//                  cv_pc[site]   = (int2&0x1c0) >>6;
//                  cv_ena[site]  = (int2&0x0200) >>9;
//                  
//                   /*ev*/
//                  int1 = OTP_LOG1_INFO_VAL[bank][count][site];
//                  int2 = OTP_LOG1_INFO_VAL[bank][count+1][site];
//                  ev_nmos[site] = ((int2&0xc000) >>14) + ((int1&0x7) <<2);
//                  ev_pmos[site] = (int1&0x00f8) >>3;
//                  ev_pc[site]   = (int1&0x0700) >>8;
//                  ev_ena[site]  = (int1&0x0800) >>11;
//                  
//                   /*pv*/
//                  int1 = OTP_LOG1_INFO_VAL[bank][count+1][site];
//                  pv_nmos[site] = int1&0x1f;
//                  pv_pmos[site] = (int1&0x03e0) >>5;
//                  pv_pc[site]   = (int1&0x1c00) >>10;
//                  pv_ena[site]  = (int1&0x2000) >>13;
//                  
//                   /*rm0*/
//                  int1 = OTP_LOG1_INFO_VAL[bank][count+2][site];
//                  int2 = OTP_LOG1_INFO_VAL[bank][count+3][site];
//                  rm0_nmos[site] = (int2&0x7c00) >>10;
//                  rm0_pmos[site] = ((int1&0xf) <<1) +((int2&0x8000) >>15);
//                  rm0_pc[site]   = (int1&0x0070) >>4;
//                  rm0_ena[site]  = (int1&0x0080) >>8;
//                  
//                   /*rm1*/
//                  int1 = OTP_LOG1_INFO_VAL[bank][count+4][site];
//                  int2 = OTP_LOG1_INFO_VAL[bank][count+5][site];
//                  rm1_nmos[site] = (int2&0x1f00) >>8;
//                  rm1_pmos[site] = ((int1&0x3) <<3) +((int2&0xe000) >>13);
//                  rm1_pc[site]   = (int1&0x001c) >>2;
//                  rm1_ena[site]  = (int1&0x0020) >>5;
//                  
//                   /*rm1*/
//                  int1 = OTP_LOG1_INFO_VAL[bank][count+6][site];
//                  rd_nmos[site] = (int1&0x007c) >>6;
//                  rd_pmos[site] = (int1&0x0f80) >>7;
//                  rd_pc[site]   = (int1&0x7000) >>12;
//                  rd_ena[site]  = (int1&0x8000) >>15;
//               }   /*v_dev_active*/
//
//            str1 = str2 + "CV_NMOS";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,cv_nmos,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "CV_PMOS";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,cv_pmos,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "CV_PC";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,cv_pc,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "CV_ENA";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,cv_ena,0,0,GL_PLELL_FORMAT);
//            if(tistdscreenprint)  
//               cout << endl;
//            
//            str1 = str2 + "EV_NMOS";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,ev_nmos,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "EV_PMOS";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,ev_pmos,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "EV_PC";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,ev_pc,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "EV_ENA";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,ev_ena,0,0,GL_PLELL_FORMAT);
//            if(tistdscreenprint)  
//               cout << endl;
//
//            str1 = str2 + "PV_NMOS";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,pv_nmos,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "PV_PMOS";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,pv_pmos,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "PV_PC";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,pv_pc,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "PV_ENA";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,pv_ena,0,0,GL_PLELL_FORMAT);
//            if(tistdscreenprint)  
//               cout << endl;
//
//            str1 = str2 + "RM0_NMOS";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,rm0_nmos,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "RM0_PMOS";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,rm0_pmos,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "RM0_PC";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,rm0_pc,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "RM0_ENA";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,rm0_ena,0,0,GL_PLELL_FORMAT);
//            if(tistdscreenprint)  
//               cout << endl;
//
//            str1 = str2 + "RM1_NMOS";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,rm1_nmos,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "RM1_PMOS";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,rm1_pmos,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "RM1_PC";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,rm1_pc,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "RM1_ENA";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,rm1_ena,0,0,GL_PLELL_FORMAT);
//            if(tistdscreenprint)  
//               cout << endl;
//
//            str1 = str2 + "RD_NMOS";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,rd_nmos,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "RD_PMOS";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,rd_pmos,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "RD_PC";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,rd_pc,0,0,GL_PLELL_FORMAT);
//            str1 = str2 + "RD_ENA";
//            str1 = str1 + str3;
//            PrintResultIntHex(str1,0,rd_ena,0,0,GL_PLELL_FORMAT);
//            if(tistdscreenprint)  
//               cout << endl;
//            
//         }   /*loop*/
//      }   /*bank*/
//
//   }   /*if v_any_dev_active*/
//      
//}   /* TL_Display_W89 */
//   
// /*display OTP decoded ratio word3/4 for 64bit bank*/
//void TL_Display_W34()
//{
//   const IntS IND_W3_0 = 27; 
//   const IntS IND_W3_7 = 34; 
//   const IntS IND_W4_0 = 35; 
//   const IntS IND_W4_7 = 42; 
//
//   IntS site,bank,count,loop;
//   IntS int1,int2,int3,int4;
//   BoolM tmp_results,final_results;
//   IntM cv_nmos,cv_pmos,cv_pc,cv_ena;
//   IntM ev_nmos,ev_pmos,ev_pc,ev_ena;
//   IntM pv_nmos,pv_pmos,pv_pc,pv_ena;
//   IntM rm0_nmos,rm0_pmos,rm0_pc,rm0_ena;
//   IntM rm1_nmos,rm1_pmos,rm1_pc,rm1_ena;
//   IntM rd_nmos,rd_pmos,rd_pc,rd_ena;
//   StringS str1,str2,str3;
//
//   if(v_any_dev_active)  
//   {
//      F021_ReadLog1OTP_func(tmp_results,1);
//
//      PrintHeaderBool(GL_PLELL_FORMAT);            
//
//      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//      {
//         writestring(str3,bank:1);
//         str3 = "_B" + str3;
//         
//         for (loop = 0;loop <= 1;loop++)
//         {
//            if(loop==0)  
//            {
//               count = IND_W3_0;
//               str2 = "W3_";
//            }
//            else
//            {
//               count = IND_W4_0;
//               str2 = "W4_";
//            } 
//
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  if(loop==0)  
//                  {
//                      /*pv*/
//                     int1 = OTP_LOG1_INFO_VAL[bank][count+1][site];
//                     pv_nmos[site] = int1&0x1f;
//                     pv_pmos[site] = (int1&0x03e0) >>5;
//                     pv_pc[site]   = (int1&0x1c00) >>10;
//                     pv_ena[site]  = (int1&0x2000) >>13;
//                  
//                      /*cv*/
//                     int1 = OTP_LOG1_INFO_VAL[bank][count][site];
//                     int2 = OTP_LOG1_INFO_VAL[bank][count+1][site];
//                     cv_nmos[site] = ((int2&0xC000) >>14) + ((int1&0x0007) <<2);
//                     cv_pmos[site] = (int1&0x00F8) >>3;
//                     cv_pc[site]   = (int1&0x0700) >>8;
//                     cv_ena[site]  = (int1&0x0800) >>11;
//                     
//                      /*rm1*/
//                     int1 = OTP_LOG1_INFO_VAL[bank][count+2][site];
//                     int2 = OTP_LOG1_INFO_VAL[bank][count+3][site];
//                     rm1_nmos[site] = (int2&0x1f00) >>8;
//                     rm1_pmos[site] = ((int1&0x7) <<3) +((int2&0xc000) >>14);
//                     rm1_pc[site]   = (int1&0x0038) >>3;
//                     rm1_ena[site]  = (int1&0x0040) >>6;
//                  }
//                  else
//                  {
//                      /*ev*/
//                     int1 = OTP_LOG1_INFO_VAL[bank][count+1][site];
//                     ev_nmos[site] = int1&0x1f;
//                     ev_pmos[site] = (int1&0x03e0) >>5;
//                     ev_pc[site]   = (int1&0x1c00) >>10;
//                     ev_ena[site]  = (int1&0x2000) >>13;
//                     
//                      /*rm0*/
//                     int1 = OTP_LOG1_INFO_VAL[bank][count][site];
//                     int2 = OTP_LOG1_INFO_VAL[bank][count+1][site];
//                     rm0_nmos[site] = ((int2&0xC000) >>14) + ((int1&0x0007) <<2);
//                     rm0_pmos[site] = (int1&0x00F8) >>3;
//                     rm0_pc[site]   = (int1&0x0700) >>8;
//                     rm0_ena[site]  = (int1&0x0800) >>11;
//                     
//                      /*rd1*/
//                     int1 = OTP_LOG1_INFO_VAL[bank][count+3][site];
//                     rd_nmos[site] = (int1&0x007c) >>2;
//                     rd_pmos[site] = (int1&0x0f80) >>7;
//                     rd_pc[site]   = (int1&0x7000) >>12;
//                     rd_ena[site]  = (int1&0x8000) >>15;
//                  } 
//               }   /*v_dev_active*/
//
//            if(loop==0)  
//            {
//               str1 = str2 + "PV_NMOS";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,pv_nmos,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "PV_PMOS";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,pv_pmos,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "PV_PC";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,pv_pc,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "PV_ENA";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,pv_ena,0,0,GL_PLELL_FORMAT);
//               if(tistdscreenprint)  
//                  cout << endl;
//               
//               str1 = str2 + "CV_NMOS";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,cv_nmos,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "CV_PMOS";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,cv_pmos,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "CV_PC";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,cv_pc,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "CV_ENA";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,cv_ena,0,0,GL_PLELL_FORMAT);
//               if(tistdscreenprint)  
//                  cout << endl;
//               
//               str1 = str2 + "RM1_NMOS";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,rm1_nmos,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "RM1_PMOS";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,rm1_pmos,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "RM1_PC";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,rm1_pc,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "RM1_ENA";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,rm1_ena,0,0,GL_PLELL_FORMAT);
//               if(tistdscreenprint)  
//                  cout << endl;
//            }
//            else
//            {
//               str1 = str2 + "EV_NMOS";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,ev_nmos,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "EV_PMOS";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,ev_pmos,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "EV_PC";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,ev_pc,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "EV_ENA";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,ev_ena,0,0,GL_PLELL_FORMAT);
//               if(tistdscreenprint)  
//                  cout << endl;
//               
//               str1 = str2 + "RM0_NMOS";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,rm0_nmos,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "RM0_PMOS";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,rm0_pmos,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "RM0_PC";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,rm0_pc,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "RM0_ENA";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,rm0_ena,0,0,GL_PLELL_FORMAT);
//               if(tistdscreenprint)  
//                  cout << endl;
//               
//               str1 = str2 + "RD_NMOS";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,rd_nmos,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "RD_PMOS";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,rd_pmos,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "RD_PC";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,rd_pc,0,0,GL_PLELL_FORMAT);
//               str1 = str2 + "RD_ENA";
//               str1 = str1 + str3;
//               PrintResultIntHex(str1,0,rd_ena,0,0,GL_PLELL_FORMAT);
//               if(tistdscreenprint)  
//                  cout << endl;
//            }             
//         }   /*loop*/
//      }   /*bank*/
//
//   }   /*if v_any_dev_active*/
//      
//}   /* TL_Display_W34 */
//
//void TL_Display_Word8_9()
//{
//   if(F021_Flash.DATAWIDTH==144)  
//      TL_Display_W89;
//   else if(F021_Flash.DATAWIDTH==64)  
//      TL_Display_W34;
//   else
//      TL_Display_W89;
//}   /* TL_Display_Word8_9 */
//      
//void TL_Meas_VHV_ER_OvrCT(IntM ovr_ersct,
//                               BoolS logena,
//                               StringS logstr,
//                                   FloatM ret_val)
//{
//   BoolM tmp_results;
//   IntS site,testnum,tcrnum;
//   TPModeType tcrmode;
//   FloatM meas_val;
//   FloatS llim,ulim,maxtime,tdelay;
//   PinM testpad;
//   FloatM FloatSval;
//   twunit unitval;
//   StringS str1,str2;
//
//   if(v_any_dev_active)  
//   {
//      maxtime = GL_F021_PARAM_MAXTIME;
//      tdelay = 10ms;
//      
//      tcrnum  = 115;
//      tcrmode = ErsMode;
//      testpad = FLTP1;
//      testnum = TNUM_PUMP_VHVERS;
//      llim    = TCR.TP1_LLim[tcrnum][tcrmode];
//      ulim    = TCR.TP1_ULim[tcrnum][tcrmode];
//
//      TL_EngOvride_VHV_ER_CT_MS(ovr_ersct);
//
//      F021_Set_TPADS(tcrnum,tcrmode);
//#if $TP3_TO_TP5_PRESENT  
//   STDDisconnect(FLTP3);
//#endif
//      F021_RunTestNumber_PMEX(testnum,maxtime,tmp_results);
//      TIME.Wait(tdelay);
//      F021_Meas_TPAD_PMEX(testpad,tcrnum,tcrmode,llim,ulim,meas_val,tmp_results);
//      Disable(s_pmexit);
//      F021_TurnOff_AllTPADS;
//
//      if(logstr=="")  
//         str1 = "VHV_ER_OVR_CT";
//      else
//         str1 = logstr;
//      
//      PrintHeaderParam(GL_PLELL_FORMAT);
//      PrintResultParam(str1,testnum,tmp_results,llim,ulim,meas_val,GL_PLELL_FORMAT);
//
//      if(logena)  
//      {
//         TWTRealToRealMS(meas_val,realval,unitval);
//         TWPDLDataLogRealVariable(str1, unitval,realval,TWMinimumData);
//      } 
//
//      ret_val = meas_val;
//   } 
//}   /* TL_Meas_VHV_ER_OvrCT */
//   
// /*estart=trim start ct value, ersct=ers ct (stop) value, ctoffset=subtraction from estart, maxep=max # of ers pulse*/
//void TL_StairStep_Erase(  IntS banknum, IntS sectnum,
//                               IntM estart, IntM ersct,
//                               IntS ctoffset, IntS maxep,
//                             BoolS logena,
//                             StringS logstr)
//{
//   const IntS ONESTEPCT = 32; 
//
//   IntS site,bank,etnum,btnum,evtnum,tnum,loop;
//   IntM msw_data,lsw_data;
//   IntM erspulse,preconpulse,cmptpulse;   
//   IntM ct_start,ct_stop,ovr_maxep;
//   BoolM final_results,tmp_results,savesites;
//   BoolM logsites,activesites;
//   BoolS done,savebool;
//   StringS str1,str2,str3,str4,str5,s;
//   FloatS maxtime,ttimer1;
//   FloatM tt_timer,meas_val;
//   FloatS vcg_start,vcg_stop,vcg_inc;
//   FloatS iref_start,iref_stop,iref_inc;
//   IntM final_ct;
//
//   if(v_any_dev_active)  
//   {
//      timernstart(ttimer1);
//      savebool = TI_FlashEsdaEna;
//      TI_FlashEsdaEna = false;
//      
//      savesites = v_dev_active;
//
//      ArraySubIntegerValue(ct_start,estart,ctoffset,v_sites);
//      ct_stop = ersct;
//      ovr_maxep = maxep;
//
//      vcg_start = 1.8V;
//      vcg_stop  = 1.8V;
//      vcg_inc   = 1V;
//      iref_start = 10uA;
//      iref_stop  = 40uA;
//      iref_inc   = 1uA;
//      
//      if(logstr=="")  
//         str1 = "Z_ESS";
//      else
//         str1 = logstr;
//
//      maxtime = GL_F021_BANK_ERS_MAXTIME;
//      done = false;
//      loop = 1;
//
//      if((banknum>==0) and (banknum<==7))  
//      {
//         etnum  = TNUM_BANK_ERS_NOPRECON + (banknum<<4);
//         btnum  = TNUM_TCR38 + TNUM_MULT1 + TNUM_DATA_1S + (banknum<<4);
//      }
//      else
//      {
//         etnum  = TNUM_BANK_ERS_NOPRECON;
//         btnum  = TNUM_TCR38 +TNUM_MULT1 + TNUM_DATA_1s;
//      } 
//
//      if((sectnum>==0) and (sectnum<==15))  
//      {
//         etnum  = etnum + TNUM_TARGET_SECT + sectnum;
//         btnum  = btnum + TNUM_TARGET_SECT + sectnum;
//      } 
//
//      final_ct = 0;
//      
//      PrintHeaderParam(GL_PLELL_FORMAT);
//      str2 = str1 + "_STARTCT";
//      PrintResultInt(str2,0,ct_start,0,511,GL_PLELL_FORMAT);
//      str2 = str1 + "_STOPCT";
//      PrintResultInt(str2,0,ct_stop,0,511,GL_PLELL_FORMAT);
//
//      while(not done) do
//      {
//         if(TI_FlashDebug)  
//        if(Inkey(s))   break;
//            
//         logsites = v_dev_active;
//         activesites = v_dev_active;
//         tmp_results = v_dev_active;
//
//         writestring(str2,loop:1);
//         str2 = "_L" + str2;
//         str3 = str1 + str2;
//
//         str4 = str3 + "_CT";
//         PrintHeaderParam(GL_PLELL_FORMAT);
//         PrintResultInt(str4,0,ct_start,0,511,GL_PLELL_FORMAT);
//         if(logena)  
//            TWPDLDataLogVariable(str4,ct_start,TWMinimumData);
//
//          /*meas & erase w/ maxep @ one instance of ct*/
//         str4 = str3 + "_VHVE";
//         TL_Meas_VHV_ER_OvrCT(ct_start,logena,str4,meas_val);
//         
//         TL_EngOvride_VHV_MAXEP_ESTART_ESTEP_CT(ovr_maxep,ct_start,ovr_maxep,ct_start);
//         f021_runtestnumber(etnum,maxtime,tt_timer,tmp_results);
//         PrintHeaderErsProg(0,0,0,maxep,0,0,(not GL_PLELL_FORMAT));
//         Get_TLogSpace_ErsPulse(erspulse);
//         if(logena)  
//         {
//            str4 = str3 + "_EPLS";
//            TWPDLDataLogVariable(str4,erspulse, TWMinimumData);
//         }             
//         PrintResultErsProg(str3,etnum,preconpulse,erspulse,cmptpulse,
//                            0,0,0,maxep,0,0,(not GL_PLELL_FORMAT));
//         PrintResultBool(str3,etnum,tmp_results,GL_PLELL_FORMAT);
//         
//         str5 = str3 + "_FBIT";
//         TL_BitHistogram(SECTTYPE,btnum,vcg_start,vcg_stop,vcg_inc,iref_start,iref_stop,iref_inc,logena,str5);
//
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               if(tmp_results[site] or (ct_start[site] >== ct_stop[site]))  
//               {
//                  activesites[site] = false;
//                  final_ct[site] = ct_start[site];
//               } 
//            } 
//
//         devsetholdstates(activesites);
//
//         if(v_any_dev_active)  
//         {
//            for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//               if(v_dev_active[site])  
//               {
//                  ct_start[site] = ct_start[site]+ONESTEPCT;
//                  if(ct_start[site] > ct_stop[site])  
//                     ct_start[site] = ct_stop[site];
//               } 
//         }
//         else
//         {
//            done = true;
//         } 
//         loop = loop+1;
//      }   /*while*/
//
//      devsetholdstates(savesites);
//      TI_FlashEsdaEna = savebool;
//
//      str4 = str1 + "_ERSCT";
//      PrintHeaderParam(GL_PLELL_FORMAT);
//      PrintResultInt(str4,0,final_ct,0,511,GL_PLELL_FORMAT);
//      if(logena)  
//         TWPDLDataLogVariable(str4,final_ct,TWMinimumData);
//
//      if(tistdscreenprint)  
//      {
//         cout << "TTT == " << timernread(ttimer1) << endl;
//         cout << endl;
//      } 
//         
//   }   /*if v_any_dev_active*/
//}   /* TL_StairStep_Erase */
//      
//void TL_Schmoo_Freq(VCornerType vcorner,
//                         IntS testnumber,
//                           FloatS freqstart, FloatS freqstop, FloatS freqinc,
//                         BoolS EnaPLL,
//                         BoolS UseAutoWaitState,
//                         IntS waitState,
//                         BoolS EnaPipeLine,
//                         BoolS twlogena,
//                         StringS logstr,
//                         StringS dumpToFileName)
//{
//   const  TNUM_ARBFREQ_ENA = 0x0C000000;  /* :MANUAL FIX REQUIRED: Unknown const type */
//   const IntS MAXITER = 512; 
//
//   IntS site,tnum,bank,i,index,j,k;
//   BoolM tmp_results,savesites,FmaxFound;
//   FloatS fstart,fstop,finc,infreq;
//   StringS str1,str2,str3,str4,str5,s;
//   BoolS done,wstate_addr_ena,arbpsaena;
//   FloatS maxtime,ttimer1,tdelay,tfreq;
//   FloatM tt_timer;
//   BoolS dumptofile,lotohi;
//   BoolS PgmInvert;
//   FloatS PgmFRQ,PgmClkVIH,PgmClkVIL;
//   FloatS vdd_vProg,vdd_iprog;
//   IntS2D SchmooResults; /* :MANUAL FIX REQUIRED: array dimensions are : 1..MAXITER,1..NumSites */
//   IntM intdata,FmaxResult;
//   DCSetUp prevDCSU;
//
//   if(v_any_dev_active)  
//   {
//      switch(vcorner) {
//        case  VMN: case VMNO: case VMNE :   
//           PowerUpAtVmin(dcsetup_loosevmin,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vmin],v[vil_loose]);
//         break; 
//        case  VNM: case VNMO: case VNME :   
//           PowerUpAtVnom(dcsetup_loosevnom,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vnom],v[vil_loose]);
//         break; 
//        case  VMX: case VMXO: case VMXE :   
//           PowerUpAtVmax(dcsetup_loosevmax,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vmax],v[vil_loose]);
//         break; 
//        default:  
//           PowerUpAtVnom(dcsetup_loosevnom,norm_fmsu);
//           ClockSet(S_CLOCK1A,false,GL_F021_PLLENA_SPEED1,
//                    v[vih_loose_osc_vnom],v[vil_loose]);
//         break;            
//      }   /* case */
//
//      clockpinset(s_clk_1a,s_clock);
//      TIME.Wait(2ms);
//      patternexecute(i,f021_shell_loadpat);
//      f021_runtestnumber(tnum_always_pass,1s,spare_mstreal1,spare_msbool1);
//      SetupGet(prevDCSU);
//
//      savesites = v_dev_active;
//      tmp_results = v_dev_active;
//      FmaxFound = false;
//      FmaxResult = 0;
//
//      maxtime = 2s;  /*GL_F021_BANK_VT_MAXTIME;*/
//      tdelay = 2ms;
//      wstate_addr_ena = false;
//      
//      fstart = trunc(single(freqstart/1MgHz));
//      fstop  = trunc(single(freqstop/1MgHz));
//      finc   = trunc(single(freqinc/1MgHz));
//      if(finc <== 0)  
//         finc = 1;  /*default 1mghz resolution*/
//      infreq = fstart;
//
//      if(fstart <== fstop)  
//         lotohi = true;
//      else
//         lotohi = false;
//
//      bank = (testnumber & 0x000000F0) >>4;
//      writestring(str4,bank:1);
//      str4 = "B" + str4;
//      str4 = str4 + "_";
//      
//      tnum = testnumber | TNUM_ARBFREQ_ENA;
//      
//      arbpsaena = false;
//      if(((testnumber & 0x00000F00) == TNUM_TARGET_ARB) or (testnumber == (TNUM_EXEC_RANDCODE+(bank<<4))))  
//         arbpsaena = true;
//
//      if(tistdscreenprint)  
//      {
//         PrintDUTSetup;
//         cout << endl;
//         cout << "Schmoo Freq (MGHZ) start == " << fstart:-7:1 << " <<   stop == " << fstop:-7:1 << " <<   resolution == " << finc:-7:1 << endl;
//         cout << "PLLEna == " << EnaPLL:-7 << "  AutoWState == " << UseAutoWaitState:-7 << "  WS == " << waitState:-5 << "  PipeLineEna == " << EnaPipeLine:-7 << endl;
//         if(twlogena)  
//            PrintHeaderBool(GL_PLELL_FORMAT);
//      } 
//
//      if(logstr == "")  
//         str1 = "FREQ_";
//      else
//         str1 = logstr + "_";
//      str1 = str1 + str4;
//
//      Clockget(s_clock1a,pgminvert,pgmfrq,pgmclkvih,pgmclkvil);
//      STDGetVI(VDD,vdd_vProg,vdd_iprog);
//      TrealToStr(vdd_vProg,str4);
//      str1 = str1 + str4;
//      
//      timernstart(ttimer1);
//
//      done = false;
//      index = 0;
//      
//      REPEAT
//         if(TI_FlashDebug)  
//            if(Inkey(s))   done = true;
//         
//         ClockStopFreeRun(s_clock1a);
//         if(not EnaPLL)  
//         {
//            ClockSet(S_CLOCK1A,pgminvert,infreq*1Mghz,pgmclkvih,pgmclkvil);
//            TIME.Wait(tdelay);
//         } 
//
//         if not(arraycompareboolean(savesites,tmp_results,v_sites))  
//         {
//            SetupSelect(prevDCSU,norm_fmsu);
//            patternexecute(i,f021_shell_loadpat);
//         } 
//         
//         TL_SetArbFREQ(infreq,EnaPLL);
//         TL_SetArbWAIT(UseAutoWaitState,waitState,wstate_addr_ena,EnaPipeLine);
//         if(arbpsaena)  
//            MBox_Upload_RCODE_PSA(bank,Random);            
//         tmp_results = v_dev_active;
//         F021_RunTestNumber(tnum,maxtime,tt_timer,tmp_results);
//         index = index+1;
//         
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               if(tmp_results[site])  
//               {
//                  SchmooResults[index][site] = 1;
//                  intdata[site] = 1;
//                  if(not FmaxFound[site])  
//                     FmaxResult[site] = trunc(infreq);
//                  if(not lotohi)  
//                     FmaxFound[site] = true;
//               }
//               else
//               {
//                  SchmooResults[index][site] = 0;
//                  intdata[site] = 0;
//                  if(lotohi)  
//                     if(not FmaxFound[site])  
//                        FmaxFound[site] = true;
//               } 
//            } 
//         
//         tfreq = infreq*1Mghz;
//         TrealToStr(tfreq,str2);
//         str2 = "_" + str2;
//         str3 = str1 + str2;
//         if(tistdscreenprint and twlogena)  
//            PrintResultBool(str3,tnum,tmp_results,GL_PLELL_FORMAT);
//         if(twlogena)  
//            TWPDLDataLogVariable(str3,intdata,TWMinimumData);
//         
//         if(lotohi)  
//         {
//            infreq = infreq + finc;
//            if(infreq > fstop)  
//               done = true;
//         }
//         else
//         {
//            infreq = infreq - finc;
//            if(infreq < fstop)  
//               done = true;
//         } 
//      UNTIL(done);
//
//      if(twlogena)  
//      {
//         str5 = str1 + "_FMAX";
//         TWPDLDataLogVariable(str5,FmaxResult,TWMinimumData);
//         PrintResultInt(str5,tnum,FmaxResult,trunc(fstart),trunc(fstop),GL_PLELL_FORMAT);
//      } 
//      
//      if(tistdscreenprint)  
//      {
//         cout << endl;
//         cout << str1 << "  TNUM == " << tnum:s_hex:-15 << "  1==Pass <<   0==Fail" << endl;
//         cout << "FREQ(MHZ)":-10;
//         k = 0;
//         for (i = 1;i <= index;i++)
//         {
//             /*print every 10th point*/
//            if((i==1) or ((i mod 11)==0))  
//            {
//               if(i==1)  
//                  tfreq = fstart*1Mghz;
//               else if(lotohi)  
//                  tfreq = (fstart+((i-1)*finc))*1Mghz;
//               else
//                  tfreq = (fstart-((i-1)*finc))*1Mghz;
//               TrealToStr(tfreq,str2);
//               j = len(str2);
//               str2 = mid(str2,1,j-4);
//               k = k+len(str2);
//               cout << str2;
//            }
//            else
//            {
//               if(i>k)  
//               {
//                  k = k+1;
//                  cout << " ";
//               } 
//            } 
//         } 
//         cout << endl;
//         
//         cout << " ":-10;
//         for (i = 1;i <= index;i++)
//         {
//            if((i==1) or ((i mod 11) == 0))  
//               cout << "+");
//            else
//               cout << "-";
//         } 
//         cout << endl;
//
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               cout << "Site" << site:-6;
//               for (i = 1;i <= index;i++)
//                  cout << SchmooResults[i][site]:-1;
//               cout << endl;
//            } 
//         cout << endl;
//         cout << "TL_Schmoo_Freq TT " << timernread(ttimer1) << endl;
//      } 
//
//      ClockStopFreeRun(s_clock1a);
//      ClockSet(s_clock1a,pgminvert,pgmfrq,pgmclkvih,pgmclkvil);
//      
//   }   /*if v_any_dev_active*/
//}   /* TL_Schmoo_Freq */
//
//
//void TL_SAMP_ACCY_IV(BoolS dobcc,
//                          StringS logstr,
//                          BoolS twlogena)
//{
//   IntS site,bank,count,tnum,stnum,numread;
//   IntS addrms,addrls,senamp;
//   IntM msw_cpuaddr,lsw_cpuaddr;
//   IntM msw_fdata,lsw_fdata;
//   IntM msw_fdata0,lsw_fdata0;
//   IntM msw_fdata1,lsw_fdata1;
//   IntM msw_mainaddr,lsw_mainaddr;
//   IntM senampnum;
//   FloatM vt_vcg,meas_val;
//   BoolM savesites,logsites,allsitefalse;
//   BoolM tmp_results;
//   PinM cg_pin,bl_pin;
//   FloatS cg_vProg,cg_iProg,bl_vProg,bl_iProg;
//   FloatS vdd_vProg,vdd_iProg;
//   FloatS tdelay1,tdelay2,tdelay3,maxtime;
//   StringS str1,str2,str3,str4,str5,str6,str7;
//   FloatM FloatSval;
//   TWunit unitval;
//   StringM FAddrStr_msw,FAddrStr_lsw;
//   StringM FDataStr_msw,FDataStr_lsw,tmpbinstr;
//   StringM FAddrStr,FDataStr;
//   IntM FAddr,FData;
//   StringS twlogstr;
//
//   if(v_any_dev_active)  
//   {
//      count = 0;
//      tdelay1 = 2ms;
//      tdelay2 = 10ms;
//      tdelay3 = 100ms;
//      maxtime = GL_F021_PARAM_MAXTIME;
//      numread = 5;
//      
//      cg_pin     = FLTP1;
//      cg_iProg   = 100mA;
//      bl_pin     = FLTP2;
//      bl_iProg   = 500uA;
//      stnum      = TNUM_BITLINE_ACCESS+TNUM_TARGET_ARB;
//
//      savesites = v_dev_active;
//      logsites = v_dev_active;
//      allsitefalse = false;
//
//      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//         if(v_dev_active[site])  
//         {
//            STDGetVI(VDD,bl_vProg,vdd_iProg);
//            break;
//         } 
//
//      if(logstr!="")  
//      {
//         twlogstr = logstr;
//         str1 = logstr + "_VCG";
//         str2 = logstr + "_IBL";
//         str5 = logstr + "_FADDR";
//         str6 = logstr + "_FDATA";
//         str7 = logstr + "_SANUM";
//      }
//      else
//      {
//         str1 = "Z_SAACCY_VCG";
//         str2 = "Z_SAACCY_IBL";
//         str5 = "Z_SAACCY_FADDR";
//         str6 = "Z_SAACCY_FDATA";
//         str7 = "Z_SAACCY_SANUM";
//      } 
//
//      PrintHeaderParam(GL_PLELL_FORMAT);
//      
//      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//      {
//         if(dobcc)  
//            vt_vcg = 5.0V;
//         else
//            vt_vcg = FL_SAMP_ACCY_VT[bank][count];
//         msw_cpuaddr = FL_SAMP_ACCY_VT_FADDR_MSW[bank][count];
//         lsw_cpuaddr = FL_SAMP_ACCY_VT_FADDR_LSW[bank][count];
//         msw_fdata0 = FL_SAMP_ACCY_VT_FDATA_MSW[bank][count];
//         lsw_fdata0 = FL_SAMP_ACCY_VT_FDATA_LSW[bank][count];
//         msw_fdata1 = FL_SAMP_ACCY_VT_FDATA1_MSW[bank][count];
//         lsw_fdata1 = FL_SAMP_ACCY_VT_FDATA1_LSW[bank][count];
//         
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(v_dev_active[site])  
//            {
//               if((msw_fdata0[site]!=0) or (lsw_fdata0[site]!=0))  
//               {
//                  msw_fdata[site] = msw_fdata0[site];
//                  lsw_fdata[site] = lsw_fdata0[site];
//               }
//               else
//               {
//                  msw_fdata[site] = msw_fdata1[site];
//                  lsw_fdata[site] = lsw_fdata1[site];
//               } 
//            }   /*v_dev_active*/
//                  
//         TL_Get_SenAmp_From_CpuAddrData_MS(msw_cpuaddr,lsw_cpuaddr,msw_fdata,lsw_fdata,msw_mainaddr,lsw_mainaddr,senampnum);
//         IntToBCD_BinStr(msw_mainaddr,FAddrStr_msw,tmpbinstr,true);
//         IntToBCD_BinStr(lsw_mainaddr,FAddrStr_lsw,tmpbinstr,true);
//         IntToBCD_BinStr(msw_fdata,FDataStr_msw,tmpbinstr,true);
//         IntToBCD_BinStr(lsw_fdata,FDataStr_lsw,tmpbinstr,true);
//
//         F021_TurnOff_AllTPADS;
//         devsetholdstates(allsitefalse);
//         for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//            if(logsites[site])  
//            {
//               devsetholdstate(site,true);
//               senamp = senampnum[site];
//               MBox_Upload_ISenAmp(senamp);
//               addrms = msw_mainaddr[site];
//               addrls = lsw_mainaddr[site];
//               TL_SetArbAddr(addrms,addrls);
//               cg_vProg = vt_vcg[site];
//               STDSetVRange(cg_pin,cg_vProg);
//               STDSetVI(cg_pin,cg_vProg,cg_iProg);
//               STDSetVRange(bl_pin,bl_vProg);
//               STDSetVI(bl_pin,bl_vProg,bl_iProg);
//               FAddrStr[site] = "0x" + FAddrStr_msw[site];
//               FAddrStr[site] = FAddrStr[site] + FAddrStr_lsw[site];
//               FDataStr[site] = "0x" + FDataStr_msw[site];
//               FDataStr[site] = FDataStr[site] + FDataStr_lsw[site];
//
//               FAddr[site] = (msw_mainaddr[site]<<16) + lsw_mainaddr[site];
//               FData[site] = (msw_fdata[site]<<16) + lsw_fdata[site];
//               devsetholdstate(site,false);
//            } 
//         devsetholdstates(logsites);
//               
//         TIME.Wait(tdelay1);
//         tnum = stnum+(bank<<4);
//         F021_RunTestNumber_PMEX(tnum,maxtime,tmp_results);
//         TIME.Wait(tdelay3);
//         ClockStopFreeRun(S_Clock1A);
//         STDMeasI(bl_pin,numread,meas_val);
//         Disable(S_PMEXIT);
//         STDSetVI(cg_pin,0v,1mA);
//         STDSetVI(bl_pin,0v,1mA);
//         TIME.Wait(tdelay1);
//
//         writestring(str3,bank:1);
//         str3 = "_B" + str3;
//         
//         str4 = str1 + str3;
//         PrintResultParam(str4,tnum,tmp_results,0v,6v,vt_vcg,GL_PLELL_FORMAT);
//         if(twlogena)  
//         {
//            TWTRealToRealMS(vt_vcg,realval,unitval);
//            TWPDLDataLogRealVariable(str4,unitval,realval,TWMinimumData);
//         } 
//         
//         str4 = str2 + str3;
//         PrintResultParam(str4,tnum,tmp_results,0uA,50uA,meas_val,GL_PLELL_FORMAT);
//         if(twlogena)  
//         {
//            TWTRealToRealMS(meas_val,realval,unitval);
//            TWPDLDataLogRealVariable(str4,unitval,realval,TWMinimumData);
//         } 
//
//         str4 = str5 + str3;
//         PrintResultIntHex(str4,0,FAddr,0,0,GL_PLELL_FORMAT);
//         if(twlogena)  
//            TWPDLDataLogText(str4,FAddrStr,TWMinimumData);
//         
//         str4 = str6 + str3;
//         PrintResultIntHex(str4,0,FData,0,0,GL_PLELL_FORMAT);
//         if(twlogena)  
//            TWPDLDataLogText(str4,FDataStr,TWMinimumData);
//         
//         str4 = str7 + str3;
//         PrintResultInt(str4,tnum,senampnum,0,143,GL_PLELL_FORMAT);
//         if(twlogena)  
//            TWPDLDataLogVariable(str4,senampnum,TWMinimumData);
//
//      }   /*for bank*/
//         
//   }   /*if v_any_dev_active*/
//}   /* TL_SAMP_ACCY_IV */
//
//void TL_SWEEP_RDM0_NMOS_EF(IntS tdata,
//                                BoolS ovrideEF,
//                                IntS ovrideEF_Index,
//                                IntS ovrideEF_Val,
//                                BoolS doimeas,
//                                BoolS twlogena,
//                                StringS logstr)
//{
//   const IntS EVENNUM = 0; 
//   const IntS ODDNUM = 1; 
//
//   IntS site,bank,tnum,i,j,tnumdata,tnumiref;
//   BoolM final_results,logsites,tmp_results;
//   FloatS maxtime;
//   FloatM ttimer1,meas_value;
//   StringS str1,str2,str3,str4,str5,str6,str7;
//   FloatS llim,ulim;
//   IntS minloop,maxloop,minratio,maxratio,tcrnum;
//   BoolS measall,measena;
//   FloatM FloatSval;
//   TWunit unitval;
//   TPModeType tcrmode;
//   BoolM FoundFail;
//   IntM FailRatio,PFval;
//
//   if(v_any_dev_active)  
//   {
//      logsites = v_dev_active;
//      llim = Bank_Iref_RDM0_LLim;
//      ulim = Bank_Iref_RDM0_ULim;
//      minratio = 19;  /*nmos ratio*/
//      maxratio = 31;
//      measall = true;  /*true=enable measure iref all ratios, false=measure only if fail*/
//      minloop = EVENNUM;
//      maxloop = ODDNUM;
//      if(GL_BANKTYPE==FLESBANK)  
//         maxloop = EVENNUM;
//
//      tcrmode = readmode;
//      tcrnum = 26;
//      CloneTCR_To_TCR128(tcrmode,tcrmode,tcrnum);
//      TCR.TP2_IRange[tcrnum][tcrMode] = 100uA;
//      
//      PrintHeaderBool(GL_PLELL_FORMAT);
//      str7 = "";
//      if(logstr !="")  
//      {
//         str1 = logstr;
//         if(instr(logstr,"Z_RDM0")==1)  
//         {
//            i = len(logstr);
//            if(i>6)  
//            {
//               str1 = mid(logstr,1,6);
//               str7 = mid(logstr,7,i-6);
//            } 
//         } 
//      }
//      else
//         str1 = "Z_RDM0_";
//
//      switch(tdata) {
//        case 0 : tnumdata = 0;
//        case 2 : tnumdata = TNUM_DATA_ECHK;
//        case 3 : tnumdata = TNUM_DATA_OCHK;
//        default: tnumdata = 0;
//      }   /* case */
//      
//      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//      {
//         foundfail = false;
//         FailRatio = 0;
//         tnum = tnum_bank_rdm0s+tnumdata+(bank<<4);
//         for (i= = to;i= <= do;i=++)
//         {
//            PFval = 1;
//            if(ovrideEF)  
//               tl_engovride_rdm0_nmos_ef(i,ovrideEF_Index,ovrideEF_Val);
//            else
//               tl_engovride_rdm0_nmos(i);
//            f021_runtestnumber(tnum,2s,ttimer1,final_results);
//            writestring(str2,bank:1);
//            str2 = "_B" + str2;
//            str4 = str1 + str2;
//            str4 = str4 + str7;
//            writestring(str3,i:1);
//            str3 = "_NMOS" + str3;
//            str4 = str4 + str3;
//            PrintResultBool(str4,tnum,final_results,GL_PLELL_FORMAT);
//            
//            if(not ArrayCompareBoolean(logsites,final_results,v_sites))  
//            {
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site] and (not final_results[site]))  
//                  {
//                     PFval[site] = 0;
//                     if(not FoundFail[site])  
//                     {
//                        FoundFail[site] = true;
//                        FailRatio[site] = i;
//                     } 
//                  } 
//            } 
//
//            if(twlogena)  
//               TWPDLDataLogVariable(str4,PFval, TWMinimumData);
//
//            if(measall)  
//               measena = true;
//            else
//            {
//               if(not ArrayCompareBoolean(logsites,final_results,v_sites))  
//                  measena = true;
//               else
//                  measena = false;
//            } 
//
//            if(measena and doimeas)  
//            {
//               for (j = minloop;j <= maxloop;j++)
//               {
//                  if(j==0)  
//                  {
//                     tnumiref = TNUM_BANK_IREF_RDM0_EVEN + (bank<<4);
//                     str5 = "_IEVEN";
//                  }
//                  else
//                  {
//                     tnumiref = TNUM_BANK_IREF_RDM0_ODD + (bank<<4);
//                     str5 = "_IODD";
//                  } 
//                  F021_TurnOff_AllTpads;
//                  F021_Set_TPADS(tcrnum,tcrmode);
//                  if(ovrideEF)  
//                     tl_engovride_rdm0_nmos_ef(i,ovrideEF_Index,ovrideEF_Val);
//                  else
//                     tl_engovride_rdm0_nmos(i);
//                  F021_RunTestNumber_PMEX(tnumiref,2s,tmp_results);
//                  TIME.Wait(10ms);
//                  F021_Meas_TPAD_PMEX(FLTP2,tcrnum,tcrmode,llim,ulim,meas_value,tmp_results);
//                  Disable(s_pmexit);
//                  str6 = str4 + str5;
//                  PrintResultParam(str6,tnumiref,tmp_results,llim,ulim,meas_value,GL_PLELL_FORMAT);
//                  if(twlogena)  
//                  {
//                     TWTRealToRealMS(meas_value,realval,unitval);
//                     TWPDLDataLogRealVariable(str6,unitval,realval,TWMinimumData);
//                  } 
//               }   /*j*/
//            }   /*measena*/
//         }   /*i*/
//
//         str5 = str1 + str2;
//         str5 = str5 + str7;
//         str5 = str5 + "_FRATIO";
//         PrintResultInt(str5,tnum,FailRatio,0,0,GL_PLELL_FORMAT);
//         if(twlogena)  
//            TWPDLDataLogVariable(str5,FailRatio, TWMinimumData);
//         
//      }   /*bank*/
//      RestoreTCR_Fr_TCR128(tcrmode,tcrmode,tcrnum);
//   } 
//}   /* TL_SWEEP_RDM0_NMOS */
//   
//void TL_SWEEP_RDM0_NMOS(IntS tdata,
//                             BoolS twlogena,
//                             StringS logstr)
//{
//   TL_SWEEP_RDM0_NMOS_EF(tdata,false,0,0,true,twlogena,logstr);
//}   /* TL_SWEEP_RDM0_NMOS */
//
//void TL_PVFY_EF(IntS tdata,
//                     BoolS ovrideEF,
//                     IntS ovrideEF_Index,
//                     IntS ovrideEF_Val,
//                     BoolS twlogena,
//                     StringS logstr)
//{
//   const IntS EVENNUM = 0; 
//   const IntS ODDNUM = 1; 
//
//   IntS site,bank,tnum,i,j,tnumdata,tnumiref;
//   BoolM final_results,logsites,tmp_results;
//   FloatS maxtime;
//   FloatM ttimer1,meas_value;
//   StringS str1,str2,str3,str4,str5,str6,str7;
//   FloatS llim,ulim;
//   IntS minloop,maxloop,minratio,maxratio;
//   BoolS measall,measena;
//   FloatM FloatSval;
//   TWunit unitval;
//   BoolM FoundFail;
//   IntM FailRatio,PFval;
//
//   if(v_any_dev_active)  
//   {
//      logsites = v_dev_active;
//      llim = Bank_Iref_Pvfy_LLim;
//      ulim = Bank_Iref_Pvfy_ULim;
//      measall = false;  /*true=enable measure iref all ratios, false=measure only if fail*/
//      measena = false;
//      minratio = 0;
//      maxratio = 31;
//      minloop = EVENNUM;
//      maxloop = ODDNUM;
//      if(GL_BANKTYPE==FLESBANK)  
//         maxloop = EVENNUM;
//      
//      PrintHeaderBool(GL_PLELL_FORMAT);
//      str7 = "";
//      if(logstr !="")  
//      {
//         str1 = logstr;
//         if(instr(logstr,"Z_PV")==1)  
//         {
//            i = len(logstr);
//            if(i>4)  
//            {
//               str1 = mid(logstr,1,4);
//               str7 = mid(logstr,5,i-4);
//            } 
//         } 
//      }
//      else
//         str1 = "Z_PVFY_";
//
//      switch(tdata) {
//        case 0 : tnumdata = 0;
//        case 2 : tnumdata = TNUM_DATA_ECHK ; /*+TNUM_PBIST_MASK1S*/
//        case 3 : tnumdata = TNUM_DATA_OCHK ; /*+TNUM_PBIST_MASK1S*/
//        default: tnumdata = 0;
//      }   /* case */
//      
//      for (bank = 0;bank <= F021_Flash.MAXBANK;bank++)
//      {
//         foundfail = false;
//         FailRatio = 0;
//
//         if(bank==0)  
//            tnum = 0x41000106+tnumdata ; /*b0s6*/
//         else
//            tnum = 0x41000100+tnumdata+(bank<<4);  /*s0*/
//         
//         for (i = maxratio; i >= minratio; --i)
//         {
//            if(ovrideEF)  
//               TL_EngOvride_RDM0_NMOS_EF_PVCT(i,ovrideEF_Index,ovrideEF_Val,0);
//            else
//               TL_EngOvride_RDM0_NMOS_PVCT(i,0);
//            f021_runtestnumber(tnum,2s,ttimer1,final_results);
//            writestring(str2,bank:1);
//            str2 = "_B" + str2;
//            str4 = str1 + str2;
//            str4 = str4 + str7;
//            writestring(str3,i:1);
//            str3 = "_NMOS" + str3;
//            str4 = str4 + str3;
//            PrintResultBool(str4,tnum,final_results,GL_PLELL_FORMAT);
//
//            if(not ArrayCompareBoolean(logsites,final_results,v_sites))  
//            {
//               for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
//                  if(v_dev_active[site] and (not final_results[site]))  
//                  {
//                     PFval[site] = 0;
//                     if(not FoundFail[site])  
//                     {
//                        FoundFail[site] = true;
//                        FailRatio[site] = i;
//                     } 
//                  } 
//            } 
//
//            if(twlogena)  
//               TWPDLDataLogVariable(str4,PFval, TWMinimumData);
//            
//            if(measena)  
//            {
//               for (j = minloop;j <= maxloop;j++)
//               {
//                  if(j==0)  
//                  {
//                     tnumiref = TNUM_BANK_IREF_PVFY_EVEN + (bank<<4);
//                     str5 = "_IEVEN";
//                  }
//                  else
//                  {
//                     tnumiref = TNUM_BANK_IREF_PVFY_ODD + (bank<<4);
//                     str5 = "_IODD";
//                  } 
//                  F021_TurnOff_AllTpads;
//                  F021_Set_TPADS(25,Pvfymode);
//                  if(ovrideEF)  
//                     TL_EngOvride_RDM0_NMOS_EF(i,ovrideEF_Index,ovrideEF_Val);
//                  F021_RunTestNumber_PMEX(tnumiref,2s,tmp_results);
//                  TIME.Wait(10ms);
//                  F021_Meas_TPAD_PMEX(FLTP2,25,Pvfymode,llim,ulim,meas_value,tmp_results);
//                  Disable(s_pmexit);
//                  str6 = str4 + str5;
//                  PrintResultParam(str6,tnumiref,tmp_results,llim,ulim,meas_value,GL_PLELL_FORMAT);
//                  if(twlogena)  
//                  {
//                     TWTRealToRealMS(meas_value,realval,unitval);
//                     TWPDLDataLogRealVariable(str6,unitval,realval,TWMinimumData);
//                  } 
//               }   /*j*/
//            }   /*measena*/
//         }   /*i*/
//
//         str5 = str1 + str2;
//         str5 = str5 + str7;
//         str5 = str5 + "_FRATIO";
//         PrintResultInt(str5,tnum,FailRatio,0,0,GL_PLELL_FORMAT);
//         if(twlogena)  
//            TWPDLDataLogVariable(str5,FailRatio, TWMinimumData);
//
//      }   /*bank*/
//   } 
//} 

FloatM MeasPinTMU_func(PinM tpin,                       // Pin to measure on
                       StringS tpattern,                // Test pattern - func assumes CPU loop where measure to be made
                       TMU_MEASURE_TYPE meas_option,    // Measure type from standard TMU enums, only PULSE_WIDTH & Frequency supported
                       FloatM maxExpFreq,               // Maximum expected frequency
                       FloatM simResults)               // results to return in simulated mode
{
   FloatM meas_results;
   BoolM timeout;

   if(tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ MeasPinTMU_func +++++" << endl;

   FloatS sampletime = 10ms;
   FloatS tdelay = 100ms;
   FloatM vcmp = 2V;
   
   DIGITAL.SetVoh(tpin, vcmp);
   
   // run pattern to CPU loop, then take measure since 
   // we can't trigger DPIN96 TMU.
   DIGITAL.ExecutePattern(tpattern);
   DIGITAL.WaitForFlag(DIGITAL_FLAG_CPU, true);
   TIME.Wait(tdelay);
   TMU.SetTimeout(sampletime);
   
   switch (meas_option)
   {
      case TMU_MEASURE_PULSE_WIDTH:
         TMU.MeasurePulseWidth(tpin, TMU_RISING_EDGE, TMU_CMP_HIGH, TMU_CMP_HIGH, meas_results, simResults);
         break;
      case TMU_MEASURE_FREQUENCY:
         TMU.MeasureFrequency(tpin, maxExpFreq, TMU_RISING_EDGE, meas_results, simResults);
         break;
      default:
         ERR.ReportError(ERR_GENERIC_CRITICAL, "Unsupported measure option in MeasPinTMU_func in F021_Library.", UTL_VOID, NO_SITES, tpin);
         break;
   }
   timeout = TMU.Wait(tpin);
   DIGITAL.SetFlag(DIGITAL_FLAG_CPU, false);
   DIGITAL.WaitForPattern(); // wait for pattern to stop
   
   // VLCT had this here...I am skipping the logging b/c that will be handled outside this routine, but 
   // this testlog space might be forgotten 
   // I don't understand exactly why this function is here as it looks to be a lot of 
   // overhead since it is reading so much data.
   Get_Flash_TestLogSpace_SCRAM();
   
   return (meas_results);
}   /* MeasPinTMU_func */

#if !$FL_USE_DCC_TRIM_FOSC
TMResultM F021_FOSC_SoftTrim_External_func()
{
   const IntS IND_FOSC = 9; 
   const IntS FOSC_MAXEFUSE = 6; 
   const IntS SLOOP1 = 32; 
   const IntS ELOOP1 = 63; 
   const IntS SLOOP2 = 0; 
   const IntS ELOOP2 = 31; 
   const IntS MIN_CODE = 0;
   const IntS MAX_CODE = 63;

   TMResultM final_results,tmp_results;
   Sites savesites;
   IntS testnum;
   StringS str1,str2,str3, twstr;
   StringS testpattern;
   FloatM tt_timer,freq_value;
   FloatM meas_value;
   IntM trim_val,bgval,irval,foscval,slpct,vsa5ct;
   IntM trim_alarms;
   FloatS freq_llimit,freq_ulimit,freq_target, toler;
   FloatS target_meas_delta;
   PinM tpin;
   IntM msw_tnum,lsw_tnum;

   if(tistdscreenprint and TI_FlashDebug)  
      cout << "+++++ F021_FOSC_SoftTrim_External_func +++++" << endl;
   
   TIME.StartTimer();

   freq_llimit = FOSC_LLimit;
   freq_ulimit = FOSC_ULimit;
   freq_target = FOSC_Target;
   toler = FOSC_Trim_Toler;
   target_meas_delta = freq_target*toler;

   savesites = ActiveSites;
   final_results = TM_NOTEST;
   freq_value = 0Hz;
   
   bgval = MAINBG_TRIMSAVED;
   irval = MAINIREF_TRIMSAVED;
   slpct = VHV_SLPCT_TRIMSAVED;
   vsa5ct = VSA5CT_TRIMSAVED;
   trim_val = MIN_CODE - 1;  // initialize to a failing value in case trim doesn't find solution

   tpin = FL_FOSC_EXTERNAL_PIN;
   testpattern = FL_FOSC_EXTERNAL_PATTERN;

   // pre-trim
   /* dummy run */
   foscval = 0;
   RAM_Upload_SoftTrim(0xAA55,bgval,irval,foscval,slpct,vsa5ct);
   meas_value = MeasPinTMU_func(tpin,testpattern,TMU_MEASURE_FREQUENCY, freq_ulimit, freq_target);
    /*virgin run...yes, VLCT ran it twice. :TODO: check in debug if we need this second run*/
   meas_value = MeasPinTMU_func(tpin,testpattern,TMU_MEASURE_FREQUENCY, freq_ulimit, freq_target);
   Get_TLogSpace_TNUM(msw_tnum,lsw_tnum);
   SITE asite = ActiveSites.Begin().GetValue();
   //VLCT also assumed that all sites were at same testnum
   testnum = (msw_tnum[asite]<<16)+lsw_tnum[asite];
   
   twstr = "FOSC_PRETRIM";
   TIDlog.Value(meas_value, tpin, freq_llimit, freq_ulimit, "MHz", twstr, UTL_VOID, UTL_VOID, true, TWMinimumData);
   
   // We're going to do a linear search on a 
   // non-linear code curve...so create a curve 
   // and use the linear index to look up the code
   IntS1D trim_lookup(MAX_CODE-MIN_CODE+1, 0);
   int j = 0;
   int i;
   for (i = SLOOP1; i <= ELOOP1; ++i, ++j)
      trim_lookup[j] = i;
   for (i = SLOOP2; i <= ELOOP2; ++i, ++j)
      trim_lookup[j] = i;
      
   SearchMod my_search;
   my_search.LinearSearchBegin(0., double(MAX_CODE-MIN_CODE), 1., freq_target, target_meas_delta, MAX_CODE-MIN_CODE+1);
   
   int loop = 0;
   while(my_search.searchNotDone)
   {
      // get proper trim code from the lookup table
      for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
         foscval[*si] = trim_lookup[MATH.LegacyRound(my_search.xForceValueMS[*si])];
         
      RAM_Upload_SoftTrim(0xAA55,bgval,irval,foscval,slpct,vsa5ct);
      meas_value = MeasPinTMU_func(tpin,testpattern,TMU_MEASURE_FREQUENCY, freq_ulimit, freq_target);
      
      loop = loop+1;
      twstr = "FOSC_SOFT_" + loop;
      TIDlog.Value(foscval, tpin, MIN_CODE, MAX_CODE, UTL_VOID, twstr + "CODE",
                   UTL_VOID, UTL_VOID, true, TWMinimumData); 
      TIDlog.Value(meas_value, tpin, freq_llimit, freq_ulimit, meas_value.GetUnits(),
                   twstr, UTL_VOID, UTL_VOID, true, TWMinimumData);
               
      my_search.SearchNext(meas_value);
   }
   
   trim_alarms = my_search.m_searchAlarmMS;
   for (SiteIter si = ActiveSites.Begin(); !si.End(); ++si)
   {
      if (trim_alarms[*si] == SearchMod::TARGET_FOUND)
      {
         // we trimmed properly, save the value 
         // remember that the actual trim code lives in the lookup_table and the 
         // xForceValueMS is just the index
         FOSC_TRIMSAVED[*si] = trim_lookup[MATH.LegacyRound(my_search.xForceValueMS[*si])];
         trim_val[*si] = FOSC_TRIMSAVED[*si];
         freq_value[*si] = meas_value[*si]; // meas_value should still have value last measured on each site
         StringS soft_str = IntToBinStr(trim_val[*si], FOSC_MAXEFUSE, true);
         IntS t_str_length = soft_str.Length();
         
         if (t_str_length > FOSC_MAXEFUSE)
         {
            StringS error_message;
            IO.Print(error_message, "ERROR: FOSC Trim Solution Efuse Bits exceed %d. PROGRAM ISSUE -- NEED TO CONTACT LBE !!!",
                     FOSC_MAXEFUSE);
            ERR.ReportError(ERR_GENERIC_CRITICAL, error_message, t_str_length, *si, UTL_VOID);
         }
            
         MAINBG_EFSTR[*si].Replace(IND_FOSC, FOSC_MAXEFUSE, soft_str);

         if(tistdscreenprint)  
            cout << "Site" << *si << " Final Soft Efuse Pump String : " << MAINBG_EFSTR[*si] << endl;
      }
   }        
    
   RunTime.SetActiveSites(savesites);
   
   tt_timer = TIME.StopTimer();

   str1 = "FOSC_TRIM_TT";
   str2 = "FOSC_TRIM_SOL";
   str3 = "FOSC_TRIM_FREQ";

   tmp_results = TIDlog.Value(trim_val, tpin, MIN_CODE, MAX_CODE, "", str2, UTL_VOID, 
                              UTL_VOID, true, TWMinimumData);
   final_results = TIDlog.Value(freq_value, tpin, freq_llimit, freq_ulimit, "MHz", 
                                str3, UTL_VOID, UTL_VOID, true, TWMinimumData);
   final_results = DLOG.AccumulateResults(final_results, tmp_results);
   TIDlog.Value(tt_timer, UTL_VOID, 0., UTL_VOID, "s", str1, UTL_VOID, UTL_VOID, true, TWMinimumData);

   RAM_Clear_SoftTrim_All();
   FloatM ret_timer;
   F021_RunTestNumber(TNUM_ALWAYS_PASS,1s,ret_timer);

   return (final_results);
}   /* F021_FOSC_SoftTrim_External_func */
#endif

void PbistFailLogout() {
   BoolS doneAsserted = false;
   PinM capPin = "PB2_131";
   StringS capName = "pbistData";
   IntS maxCapCnt = 16384;
   UnsignedM1D capArray(109);
   UnsignedM1D simArray(109,1);
   UnsignedM1D retArray(109);
   UnsignedM1D tmpArray(109);
   TMResultM currResult = TM_NOTEST;
   TMResultM lastResult = TM_NOTEST;
   IntM failCnt = 0;
   
   TIME.Wait(0.0s);
   
   if ( lastResult != TM_PASS ) {
      if (SYS.TesterSimulated()) retArray = simArray;
      else {
         do {
            if (failCnt != 0 ) {
               // Test "FAIL" pin for assertion
               currResult = DIGITAL.TestPattern("pb_pb_test_fail_pin_Thrd");
               // FAIL asserted collect one fail frame
               if ( currResult == TM_FAIL ) {
                  PatternDigitalCapture("pb_pb_fail_logout_Thrd", capPin, capName, maxCapCnt, capArray, simArray);
                  ++failCnt;
               }
               
               // Test "DONE" pin for assertion
               currResult = DIGITAL.TestPattern("pb_pb_test_done_pin_Thrd");
               if ( currResult == TM_FAIL ) {
                  ;
               }
            }
            tmpArray = capArray;
//            retArray = ProcessFailData();
         } while (!doneAsserted);
      }
   }
}
