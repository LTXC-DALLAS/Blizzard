#include "TestwareSupport.h"


BoolS   gVarFileCreated = false;
BoolS   gCloEnable = false;
IntS    gCloFunction = 0;
StringS gCloFileName = "";
BoolM   gFirstFail = true;

BoolS gCloGenerateOk = true; 
BoolS gCorrLockOutPassed = true; 

TIDatalog TIDlog;

TIDatalog::TIDatalog() 
{
}

TIDatalog::~TIDatalog()
{
}

int TIDatalog::PrintVarFileHeader (const IntS &fileHandle) 
{
// :TODO: implement function
    return (0);
}

int TIDatalog::WriteVar (const StringS &varName, const IntS &testId, const SV_TYPE type, 
                         const LimitStruct varLimits) 
////////////////////////////////////
// WriteVar for all test types    //
////////////////////////////////////

{
    IntS var_file;
    FloatM temp_float;
    IntM temp_int;

    StringS prog_path = SYS.GetProgramPath();
    StringS var_file_path = prog_path + "/autogenerated_varfile.vars";
    if (!gVarFileCreated) 
    {
        var_file = IO.Open (var_file_path,"w");
        gVarFileCreated = true;
        PrintVarFileHeader (var_file);
    }
    else 
    {
        var_file = IO.Open (var_file_path, "a");
    }
    if (var_file == 0) 
    {
        std::cout << "Opening file " << var_file_path << " failed! Aborting writing to var file." << std::endl;
        return (1);
    }
    
    
    IO.Print (var_file, "\n");
    IO.Print (var_file, "parm=%s\n", varName);
    
    switch (type) {
      case SV_FLOAT: 
            IO.Print (var_file, "type=FLOAT\n");
            break;
      case SV_INT: 
            IO.Print (var_file, "type=INT\n");
            break;
      case SV_STRING:
            IO.Print (var_file, "type=STRING\n");
            break;
      default:
            break;
    }
    
    if (type == SV_FLOAT) {   // only do units on Float types
        StringS test_units = varLimits.GetUnits();
        StringS tw_units;
        if (test_units != "" or test_units != "=")
        {
            IntS position = test_units.Find("=");
            if (position >= 0)
            {
                IntS substr_length = test_units.Length() - (position + 1); //position is 0-based, length 1-based
                tw_units = test_units.Substring(position, substr_length);
            } else {
                tw_units = test_units;
            }
            IO.Print (var_file, "uom=%s\n", tw_units);
        } 
    }

    if (varLimits.Valid()) 
    {
        switch (type) {
          case SV_FLOAT:
                temp_float = varLimits.GetLowLimit().GetFloatM();
                if (temp_float != UTL_VOID) 
                    // check and make sure it's not void on this site, too
                    if (temp_float[ActiveSites.Begin().GetValue()] != UTL_VOID)
                        IO.Print (var_file, "test_low=%e\n", temp_float[ActiveSites.Begin().GetValue()]);
                temp_float = varLimits.GetHighLimit().GetFloatM();
                if (temp_float != UTL_VOID) 
                    // check and make sure it's not void on this site, too
                    if (temp_float[ActiveSites.Begin().GetValue()] != UTL_VOID)
                        IO.Print (var_file, "test_high=%e\n", temp_float[ActiveSites.Begin().GetValue()]);
                break;
          case SV_INT:
                temp_int = varLimits.GetLowLimit().GetIntM();
                if (temp_int != UTL_VOID) 
                    // check and make sure it's not void on this site, too
                    if (temp_int[ActiveSites.Begin().GetValue()] != UTL_VOID)
                        IO.Print (var_file, "test_low=%d\n", temp_int[ActiveSites.Begin().GetValue()]);
                temp_int = varLimits.GetHighLimit().GetIntM();
                if (temp_int != UTL_VOID) 
                    // check and make sure it's not void on this site, too
                    if (temp_int[ActiveSites.Begin().GetValue()] != UTL_VOID)
                        IO.Print (var_file, "test_high=%d\n", temp_int[ActiveSites.Begin().GetValue()]);
                break;
          default:
                break;
        }
    } 

    StringS local_test_name = RunTime.GetActiveTest().GetName();
    IO.Print (var_file, "test_name=%s\n", local_test_name);
    IO.Print (var_file, "test_number=%d\n", testId);
    IO.Close (var_file);
    return (1);
}

void TIDatalog::FailCLOGenerate () {
    gCloGenerateOk = false;
    std::cout << "CLO Generate has failed." << std::endl;
    if (IO.Exist (gCloFileName)) {
        delete (gCloFileName);
        std::cout << "CLO file " << gCloFileName << " deleted." << std::endl;
    }
    return;
}

TMResultM TIDatalog::ValueLS (const FloatM &dataToTest, const PinML &testPins, LimitStruct &testLimit,
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;

    // no limits means no test
    if (!testLimit.Valid())
    {
        return (test_result);
    }
    
    // only test and do testware stuff if we aren't doing CLO functions
    if (gCloFunction == CLO_NONE)
    {
        if (testPins.Valid() && (testPins.GetNumPins() > 0))
            DLOG.ValueLS (testPins, dataToTest, testLimit);
        else
            DLOG.ValueLS (dataToTest, testLimit);
            
    // :TODO: Add in FAIL_TEST stuff...not sure how to do it using standard
    // TWPDL calls just yet
    
        if (useTestware) 
        {
            FloatM tw_value = dataToTest;
            if (SYS.TesterSimulated())
            {
                if (testLimit.GetSimulateValue().Valid())
                    tw_value = testLimit.GetSimulateValue().GetFloatM();
            }
            StringS test_units = testLimit.GetUnits();
            StringS tw_units;
            StringS tw_name = testLimit.GetName();
            
            if (test_units == "" or test_units == "=")
                tw_units = "";
            else 
            {
                IntS position = test_units.Find("=");
                if (position >= 0)
                {
                    IntS substr_length = test_units.Length() - (position + 1); //position is 0-based, length 1-based
                    tw_units = test_units.Substring(position, substr_length);
                }
                else
                    tw_units = test_units;
            }
            if (WRITE_TW_VARS_FILE) 
            {
                IntS test_id = testLimit.GetTestNumber();
                WriteVar (tw_name, test_id, SV_FLOAT, testLimit);
            }
            TWPDLDataLogRealVariable (tw_name, tw_units, tw_value, testwareDatatype);           
        }
    }
    else if ((gCloFunction == CLO_GENERATE) && gCloGenerateOk && doClo) 
    {
    // :TODO: implement CLO stuff
    }
    else if ((gCloFunction == CLO_VERIFY) && doClo) 
    {
    // :TODO: implement CLO stuff
    }
    // put in extra if statment below to make CLO_NONE fast and skip all the evaluations inside
    if (gCloFunction != CLO_NONE)
    {
        if (doClo && ((gCloFunction == CLO_GENERATE && gCloGenerateOk) || 
                  (gCloFunction == CLO_VERIFY && gCorrLockOutPassed))) 
        {
        // :TODO: implement CLO stuff
        }
        else if (doClo && ((gCloFunction == CLO_GENERATE && (!gCloGenerateOk)) || 
                       (gCloFunction == CLO_VERIFY && (!gCorrLockOutPassed)))) 
        {
        // :TODO: implement CLO stuff
        }
    }
    return (test_result);
}

TMResultM TIDatalog::ValueLS (const FloatM1D &dataToTest, const PinML &testPins, LimitStruct &testLimit,
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    
    if (!testLimit.Valid())
    {
        return(test_result);
    }

    // only test and do testware stuff if we aren't doing CLO functions        
    if (gCloFunction == CLO_NONE)
    {
        if (testPins.Valid() && (testPins.GetNumPins() > 0))
            DLOG.ValueLS (testPins, dataToTest, testLimit);
        else
            DLOG.ValueLS (dataToTest, testLimit);
            
    // :TODO: Add in FAIL_TEST stuff...not sure how to do it using standard
    // TWPDL calls just yet
    
        if (useTestware) 
        {
            FloatM1D tw_value = dataToTest;
            if (SYS.TesterSimulated()) 
            {
                if (testLimit.GetSimulateValue().Valid())
                    tw_value = testLimit.GetSimulateValue().GetFloatM();
            }
                
            StringS test_units = testLimit.GetUnits();
            StringS tw_units;
            StringS tw_name = testLimit.GetName();
            
            if (test_units == "" or test_units == "=")
                tw_units = "";
            else 
            {
                IntS position = test_units.Find("=");
                if (position >= 0)
                {
                    IntS substr_length = test_units.Length() - (position + 1); //position is 0-based, length 1-based
                    tw_units = test_units.Substring(position, substr_length);
                }
                else
                    tw_units = test_units;
            }
           
            if (testPins.GetNumPins() < 2) // don't loop, only one test
            {
                if (WRITE_TW_VARS_FILE) 
                {
                    IntS test_id = testLimit.GetTestNumber();
                    WriteVar (tw_name, test_id, SV_FLOAT, testLimit);
                }
// TIME.StartTimer();
                TWPDLDataLogRealVariable (tw_name, tw_units, tw_value[0], testwareDatatype);  
// std::cout << "TWPDLDataLogRealVariable took: " << TIME.StopTimer() << std::endl;
            }
            else
            {
                IntS index = 0;
                for (PinMLIter pin_iter = testPins.Begin(); !pin_iter.End(); ++pin_iter, ++index)
                {
                    StringS tw_name_plus_pin = tw_name + "_" + (*pin_iter).GetName();
                    // check the name length...it might be possible to correct
                    // for long pin names here by using an index
                    if (tw_name_plus_pin.Length() > TW_MAX_NAME_LENGTH)
                        tw_name_plus_pin = tw_name + "_" + index; 
                    // since TWPDLDataLogRealVariable checks the name length when 
                    // adding the log row, let it do the check to see if the name 
                    // with _index is ok. This way we don't take a double-execution
                    // time penalty on names that are ok
                    
                    if (WRITE_TW_VARS_FILE) 
                    {
                        IntS test_id = testLimit.GetTestNumber() + index;
                        WriteVar (tw_name_plus_pin, test_id, SV_FLOAT, testLimit);
                    }
// TIME.StartTimer();
                    TWPDLDataLogRealVariable (tw_name_plus_pin, tw_units, tw_value[index], testwareDatatype); 
// std::cout << "TWPDLDataLogRealVariable took: " << TIME.StopTimer() << std::endl;
                }
            }
        }
    }
    else if ((gCloFunction == CLO_GENERATE) && gCloGenerateOk && doClo) {
    // :TODO: implement CLO stuff
    }
    else if ((gCloFunction == CLO_VERIFY) && doClo) 
    {
    // :TODO: implement CLO stuff
    }
    // put in extra if statment below to make CLO_NONE fast and skip all the evaluations inside
    if (gCloFunction != CLO_NONE) 
    {
        if (doClo && ((gCloFunction == CLO_GENERATE && gCloGenerateOk) || (gCloFunction == CLO_VERIFY && gCorrLockOutPassed))) 
        {
        // :TODO: implement CLO stuff
        }
        else if (doClo && ((gCloFunction == CLO_GENERATE && (!gCloGenerateOk)) || (gCloFunction == CLO_VERIFY && (!gCorrLockOutPassed))))
        {
        // :TODO: implement CLO stuff
        }
    }
    return (test_result);
}

TMResultM TIDatalog::ValueLS (const FloatM &dataToTest, const PinML &testPins, ObjectS &testLimit,
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    if (!testLimit.Valid())
    {
        return (test_result);
    }
    
    LimitStruct limit_struct(testLimit);
    test_result = ValueLS (dataToTest, testPins, limit_struct, useTestware, testwareDatatype, doClo);
    return (test_result);
    
}

TMResultM TIDatalog::ValueLS (const FloatM1D &dataToTest, const PinML &testPins, ObjectS &testLimit,
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    if (!testLimit.Valid())
    {
        return (test_result);
    }
    
    LimitStruct limit_struct(testLimit);
    test_result = ValueLS (dataToTest, testPins, limit_struct, useTestware, testwareDatatype, doClo);
    return (test_result);
    
}

TMResultM TIDatalog::ValueLS (const IntM &dataToTest, const PinML &testPins, LimitStruct &testLimit,
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    
    if (!testLimit.Valid())
        return(test_result);

    // only test and do testware stuff if we aren't doing CLO functions                
    if (gCloFunction == CLO_NONE)
    {
        if (testPins.Valid() && (testPins.GetNumPins() > 0))
            DLOG.ValueLS (testPins, dataToTest, testLimit);
        else
            DLOG.ValueLS (dataToTest, testLimit);    
            
    // :TODO: Add in FAIL_TEST stuff...not sure how to do it using standard
    // TWPDL calls just yet
     
        if (useTestware) 
        {
            IntM tw_value = dataToTest;
            if (SYS.TesterSimulated())
            {
                if (testLimit.GetSimulateValue().Valid())
                    tw_value = testLimit.GetSimulateValue().GetIntM();
            }        
            StringS tw_name = testLimit.GetName();
            
            if (WRITE_TW_VARS_FILE) 
            {
                IntS test_id = testLimit.GetTestNumber();
                WriteVar (tw_name, test_id, SV_INT, testLimit);
            }
            
            TWPDLDataLogVariable (tw_name, tw_value, testwareDatatype);           
        }
    }
    else if ((gCloFunction == CLO_GENERATE) && gCloGenerateOk && doClo) {
    // :TODO: implement CLO stuff
    }
    else if ((gCloFunction == CLO_VERIFY) && doClo) 
    {
    // :TODO: implement CLO stuff
    }
    // put in extra if statment below to make CLO_NONE fast and skip all the evaluations inside
    if (gCloFunction != CLO_NONE)
    {
        if (doClo && ((gCloFunction == CLO_GENERATE && gCloGenerateOk) || (gCloFunction == CLO_VERIFY && gCorrLockOutPassed)))
        {
        // :TODO: implement CLO stuff
        }
        else if (doClo && ((gCloFunction == CLO_GENERATE && (!gCloGenerateOk)) || (gCloFunction == CLO_VERIFY && (!gCorrLockOutPassed))))
        {
        // :TODO: implement CLO stuff
        }
    }
    return (test_result);
}

TMResultM TIDatalog::ValueLS (const IntM1D &dataToTest, const PinML &testPins, LimitStruct &testLimit,
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    
    if (!testLimit.Valid())
        return(test_result);
        
    // only test and do testware stuff if we aren't doing CLO functions        
    if (gCloFunction == CLO_NONE)
    {
        if (testPins.Valid() && (testPins.GetNumPins() > 0))
            DLOG.ValueLS (testPins, dataToTest, testLimit);
        else
            DLOG.ValueLS (dataToTest, testLimit);
    
    // :TODO: Add in FAIL_TEST stuff...not sure how to do it using standard
    // TWPDL calls just yet
    
        if (useTestware) 
        {
            IntM1D tw_value = dataToTest;
            if (SYS.TesterSimulated()) 
            {
                if (testLimit.GetSimulateValue().Valid())
                    tw_value = testLimit.GetSimulateValue().GetIntM();
            }

            StringS tw_name = testLimit.GetName();
            
            if (testPins.GetNumPins() < 2) // don't loop, only one test
            {
                if (WRITE_TW_VARS_FILE) 
                {
                    IntS test_id = testLimit.GetTestNumber();
                    WriteVar (tw_name, test_id, SV_INT, testLimit);
                }
            
                TWPDLDataLogVariable (tw_name, tw_value[0], testwareDatatype);  
            }
            else
            {
                IntS index = 0;
                for (PinMLIter pin_iter = testPins.Begin(); !pin_iter.End(); ++pin_iter, ++index)
                {
                    StringS tw_name_plus_pin = tw_name + "_" + (*pin_iter).GetName();
                    // check the name length...it might be possible to correct
                    // for long pin names here by using an index
                    if (tw_name_plus_pin.Length() > TW_MAX_NAME_LENGTH)
                        tw_name_plus_pin = tw_name + "_" + index; 
                    // since TWPDLDataLogRealVariable checks the name length when 
                    // adding the log row, let it do the check to see if the name 
                    // with _index is ok. This way we don't take a double-execution
                    // time penalty on names that are ok
                    
                    if (WRITE_TW_VARS_FILE) 
                    {
                        IntS test_id = testLimit.GetTestNumber() + index;
                        WriteVar (tw_name_plus_pin, test_id, SV_INT, testLimit);
                    }
            
                    TWPDLDataLogVariable (tw_name_plus_pin, tw_value[index], testwareDatatype); 
                }
            }
        }
    }
    else if ((gCloFunction == CLO_GENERATE) && gCloGenerateOk && doClo) {
    // :TODO: implement CLO stuff
    }
    else if ((gCloFunction == CLO_VERIFY) && doClo) 
    {
    // :TODO: implement CLO stuff
    }
    // put in extra if statment below to make CLO_NONE fast and skip all the evaluations inside
    if (gCloFunction != CLO_NONE)
    {
        if (doClo && ((gCloFunction == CLO_GENERATE && gCloGenerateOk) || (gCloFunction == CLO_VERIFY && gCorrLockOutPassed)))
        {
        // :TODO: implement CLO stuff
        }
        else if (doClo && ((gCloFunction == CLO_GENERATE && (!gCloGenerateOk)) || (gCloFunction == CLO_VERIFY && (!gCorrLockOutPassed))))
        {
        // :TODO: implement CLO stuff
        }
    }
    return (test_result);
}

TMResultM TIDatalog::ValueLS (const IntM &dataToTest, const PinML &testPins, ObjectS &testLimit,
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    if (!testLimit.Valid())
    {
        return (test_result);
    }
    
    LimitStruct limit_struct(testLimit);
    test_result = ValueLS (dataToTest, testPins, limit_struct, useTestware, testwareDatatype, doClo);
    return (test_result);
    
}

TMResultM TIDatalog::ValueLS (const IntM1D &dataToTest, const PinML &testPins, ObjectS &testLimit,
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    if (!testLimit.Valid())
    {
        return (test_result);
    }
    
    LimitStruct limit_struct(testLimit);
    test_result = ValueLS (dataToTest, testPins, limit_struct, useTestware, testwareDatatype, doClo);
    return (test_result);
    
}

TMResultM TIDatalog::Value (const FloatM &dataToTest, const PinML &testPins, const FloatM &loLim, const FloatM &hiLim,
                            const StringS &units, const StringS &testName, const StringS &failBin, const IntS &minorID, 
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, 
                            const ExpectedResultS &expectedResult, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    
    // only test and do testware stuff if we aren't doing CLO functions
    if (gCloFunction == CLO_NONE)
    {
        if (testPins.Valid() && (testPins.GetNumPins() > 0))
            test_result = DLOG.Value (testPins, dataToTest, loLim, hiLim, units, testName, failBin,
                                      UTL_VOID, minorID, expectedResult);
        else
            test_result = DLOG.Value (testPins, dataToTest, loLim, hiLim, units, testName, failBin,
                                      UTL_VOID, minorID, expectedResult);
    
    // :TODO: Add in FAIL_TEST stuff...not sure how to do it using standard
    // TWPDL calls just yet
    
        if (useTestware) 
        {
            FloatM tw_value = dataToTest;
            if (SYS.TesterSimulated())
            {
                if ((loLim != UTL_VOID) && (hiLim != UTL_VOID)) 
                {
                    tw_value = hiLim - loLim / 2. + loLim;
                } 
                else if (loLim != UTL_VOID)
                {
                    tw_value = loLim + MATH.Abs(loLim) / 10.;
                }
                else
                {
                    tw_value = hiLim - MATH.Abs(hiLim) / 10.;
                }
            }
            StringS tw_units;
            
            if (units == "" or units == "=")
                tw_units = "";
            else 
            {
                IntS position = units.Find("=");
                if (position >= 0)
                {
                    IntS substr_length = units.Length() - (position + 1); //position is 0-based, length 1-based
                    tw_units = units.Substring(position, substr_length);
                }
                else
                    tw_units = units;
            }
            // :TODO: Add write var support for non-LS
//            if (WRITE_TW_VARS_FILE) 
//            {
//                IntS test_id = RunTimeCache.GetTestID(minorID);
//                WriteVar (tw_name, test_id, SV_FLOAT, testLimit);
//            }
            TWPDLDataLogRealVariable (testName, tw_units, tw_value, testwareDatatype);           
        }
    }
    else if ((gCloFunction == CLO_GENERATE) && gCloGenerateOk && doClo) 
    {
    // :TODO: implement CLO stuff
    }
    else if ((gCloFunction == CLO_VERIFY) && doClo) 
    {
    // :TODO: implement CLO stuff
    }
    // put in extra if statment below to make CLO_NONE fast and skip all the evaluations inside
    if (gCloFunction != CLO_NONE)
    {
        if (doClo && ((gCloFunction == CLO_GENERATE && gCloGenerateOk) || 
                  (gCloFunction == CLO_VERIFY && gCorrLockOutPassed))) 
        {
        // :TODO: implement CLO stuff
        }
        else if (doClo && ((gCloFunction == CLO_GENERATE && (!gCloGenerateOk)) || 
                       (gCloFunction == CLO_VERIFY && (!gCorrLockOutPassed)))) 
        {
        // :TODO: implement CLO stuff
        }
    }
    return (test_result);
}

TMResultM TIDatalog::Value (const FloatM1D &dataToTest, const PinML &testPins, const FloatM &loLim, const FloatM &hiLim,
                            const StringS &units, const StringS &testName, const StringS &failBin, const IntS &minorID, 
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, 
                            const ExpectedResultS &expectedResult, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    // In the usage for this function, we are testing multiple measurements against a single limit
    // we aren't doing multiple measure vs multiple limits...that doesn't follow the path we have
    // chosen. However, we need M1D for limits for the DLOG statement.
    FloatM1D lo_lim_m1d(dataToTest.GetSize(), loLim);
    FloatM1D hi_lim_m1d(dataToTest.GetSize(), hiLim);

    // only test and do testware stuff if we aren't doing CLO functions        
    if (gCloFunction == CLO_NONE)
    {
        if (testPins.Valid() && (testPins.GetNumPins() > 0))
            test_result = DLOG.Value (testPins, dataToTest, lo_lim_m1d, hi_lim_m1d, units, testName, failBin,
                                      UTL_VOID, minorID, expectedResult);
        else
            test_result = DLOG.Value (testPins, dataToTest, lo_lim_m1d, hi_lim_m1d, units, testName, failBin,
                                      UTL_VOID, minorID, expectedResult);
                                      
    // :TODO: Add in FAIL_TEST stuff...not sure how to do it using standard
    // TWPDL calls just yet
    
        if (useTestware) 
        {
            FloatM1D tw_value = dataToTest;
            if (SYS.TesterSimulated())
            {
                if ((loLim != UTL_VOID) && (hiLim != UTL_VOID)) 
                {
                    tw_value = hiLim - loLim / 2. + loLim;
                } 
                else if (loLim != UTL_VOID)
                {
                    tw_value = loLim + MATH.Abs(loLim) / 10.;
                }
                else
                {
                    tw_value = hiLim - MATH.Abs(hiLim) / 10.;
                }
            }
            StringS tw_units;
            StringS tw_name = testName;
            
            if (units == "" or units == "=")
                tw_units = "";
            else 
            {
                IntS position = units.Find("=");
                if (position >= 0)
                {
                    IntS substr_length = units.Length() - (position + 1); //position is 0-based, length 1-based
                    tw_units = units.Substring(position, substr_length);
                }
                else
                    tw_units = units;
            }
           
            if (testPins.GetNumPins() < 2) // don't loop, only one test
            {
            // :TODO: Add write var support for non-LS
//                if (WRITE_TW_VARS_FILE) 
//                {
//                    IntS test_id = RunTimeCache.GetTestID(minorID);
//                    WriteVar (tw_name, test_id, SV_FLOAT, testLimit);
//                }
// TIME.StartTimer();
                TWPDLDataLogRealVariable (tw_name, tw_units, tw_value[0], testwareDatatype);  
// std::cout << "TWPDLDataLogRealVariable took: " << TIME.StopTimer() << std::endl;
            }
            else
            {
                IntS index = 0;
                for (PinMLIter pin_iter = testPins.Begin(); !pin_iter.End(); ++pin_iter, ++index)
                {
                    StringS tw_name_plus_pin = tw_name + "_" + (*pin_iter).GetName();
                    // check the name length...it might be possible to correct
                    // for long pin names here by using an index
                    if (tw_name_plus_pin.Length() > TW_MAX_NAME_LENGTH)
                        tw_name_plus_pin = tw_name + "_" + index; 
                    // since TWPDLDataLogRealVariable checks the name length when 
                    // adding the log row, let it do the check to see if the name 
                    // with _index is ok. This way we don't take a double-execution
                    // time penalty on names that are ok
                    
            // :TODO: Add write var support for non-LS
//                    if (WRITE_TW_VARS_FILE) 
//                    {
//                        IntS test_id = RunTimeCache.GetTestID(minorID) + index;
//                        WriteVar (tw_name_plus_pin, test_id, SV_FLOAT, testLimit);
//                    }
// TIME.StartTimer();
                    TWPDLDataLogRealVariable (tw_name_plus_pin, tw_units, tw_value[index], testwareDatatype); 
// std::cout << "TWPDLDataLogRealVariable took: " << TIME.StopTimer() << std::endl;
                }
            }
        }
    }
    else if ((gCloFunction == CLO_GENERATE) && gCloGenerateOk && doClo) {
    // :TODO: implement CLO stuff
    }
    else if ((gCloFunction == CLO_VERIFY) && doClo) 
    {
    // :TODO: implement CLO stuff
    }
    // put in extra if statment below to make CLO_NONE fast and skip all the evaluations inside
    if (gCloFunction != CLO_NONE) 
    {
        if (doClo && ((gCloFunction == CLO_GENERATE && gCloGenerateOk) || (gCloFunction == CLO_VERIFY && gCorrLockOutPassed))) 
        {
        // :TODO: implement CLO stuff
        }
        else if (doClo && ((gCloFunction == CLO_GENERATE && (!gCloGenerateOk)) || (gCloFunction == CLO_VERIFY && (!gCorrLockOutPassed))))
        {
        // :TODO: implement CLO stuff
        }
    }
    return (test_result);
}

TMResultM TIDatalog::Value (const IntM &dataToTest, const PinML &testPins, const IntM &loLim, const IntM &hiLim,
                            const StringS &units, const StringS &testName, const StringS &failBin, const IntS &minorID, 
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, 
                            const ExpectedResultS &expectedResult, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    
    // only test and do testware stuff if we aren't doing CLO functions
    if (gCloFunction == CLO_NONE)
    {
        if (testPins.Valid() && (testPins.GetNumPins() > 0))
            test_result = DLOG.Value (testPins, dataToTest, loLim, hiLim, units, testName, failBin,
                                      UTL_VOID, minorID, expectedResult);
        else
            test_result = DLOG.Value (testPins, dataToTest, loLim, hiLim, units, testName, failBin,
                                      UTL_VOID, minorID, expectedResult);
    
    // :TODO: Add in FAIL_TEST stuff...not sure how to do it using standard
    // TWPDL calls just yet
    
        if (useTestware) 
        {
            IntM tw_value = dataToTest;
            if (SYS.TesterSimulated())
            {
                if ((loLim != UTL_VOID) && (hiLim != UTL_VOID)) 
                {
                    tw_value = hiLim - loLim / 2 + loLim;
                } 
                else if (loLim != UTL_VOID)
                {
                    tw_value = loLim;
                }
                else
                {
                    tw_value = hiLim;
                }
            }

            // :TODO: Add write var support for non-LS
//            if (WRITE_TW_VARS_FILE) 
//            {
//                IntS test_id = RunTimeCache.GetTestID(minorID);
//                WriteVar (tw_name, test_id, SV_INT, testLimit);
//            }
            TWPDLDataLogVariable (testName, tw_value, testwareDatatype);           
        }
    }
    else if ((gCloFunction == CLO_GENERATE) && gCloGenerateOk && doClo) 
    {
    // :TODO: implement CLO stuff
    }
    else if ((gCloFunction == CLO_VERIFY) && doClo) 
    {
    // :TODO: implement CLO stuff
    }
    // put in extra if statment below to make CLO_NONE fast and skip all the evaluations inside
    if (gCloFunction != CLO_NONE)
    {
        if (doClo && ((gCloFunction == CLO_GENERATE && gCloGenerateOk) || 
                  (gCloFunction == CLO_VERIFY && gCorrLockOutPassed))) 
        {
        // :TODO: implement CLO stuff
        }
        else if (doClo && ((gCloFunction == CLO_GENERATE && (!gCloGenerateOk)) || 
                       (gCloFunction == CLO_VERIFY && (!gCorrLockOutPassed)))) 
        {
        // :TODO: implement CLO stuff
        }
    }
    return (test_result);
}

TMResultM TIDatalog::Value (const IntM1D &dataToTest, const PinML &testPins, const IntM &loLim, const IntM &hiLim,
                            const StringS &units, const StringS &testName, const StringS &failBin, const IntS &minorID, 
                            const BoolS &useTestware, const EnumS<TWDataType> &testwareDatatype, 
                            const ExpectedResultS &expectedResult, const BoolS &doClo) 
{
    TMResultM test_result = TM_NOTEST;
    
    // In the usage for this function, we are testing multiple measurements against a single limit
    // we aren't doing multiple measure vs multiple limits...that doesn't follow the path we have
    // chosen. However, we need M1D for limits for the DLOG statement.
    IntM1D lo_lim_m1d(dataToTest.GetSize(), loLim);
    IntM1D hi_lim_m1d(dataToTest.GetSize(), hiLim);

    // only test and do testware stuff if we aren't doing CLO functions        
    if (gCloFunction == CLO_NONE)
    {
        if (testPins.Valid() && (testPins.GetNumPins() > 0))
            test_result = DLOG.Value (testPins, dataToTest, lo_lim_m1d, hi_lim_m1d, units, testName, failBin,
                                      UTL_VOID, minorID, expectedResult);
        else
            test_result = DLOG.Value (testPins, dataToTest, lo_lim_m1d, hi_lim_m1d, units, testName, failBin,
                                      UTL_VOID, minorID, expectedResult);
                                      
    // :TODO: Add in FAIL_TEST stuff...not sure how to do it using standard
    // TWPDL calls just yet
    
        if (useTestware) 
        {
            IntM1D tw_value = dataToTest;
            if (SYS.TesterSimulated())
            {
                if ((loLim != UTL_VOID) && (hiLim != UTL_VOID)) 
                {
                    tw_value = hiLim - loLim / 2 + loLim;
                } 
                else if (loLim != UTL_VOID)
                {
                    tw_value = loLim;
                }
                else
                {
                    tw_value = hiLim;
                }
            }
            StringS tw_name = testName;
           
            if (testPins.GetNumPins() < 2) // don't loop, only one test
            {
            // :TODO: Add write var support for non-LS
//                if (WRITE_TW_VARS_FILE) 
//                {
//                    IntS test_id = RunTimeCache.GetTestID(minorID);
//                    WriteVar (tw_name, test_id, SV_FLOAT, testLimit);
//                }
// TIME.StartTimer();
                TWPDLDataLogVariable (tw_name, tw_value[0], testwareDatatype);  
// std::cout << "TWPDLDataLogRealVariable took: " << TIME.StopTimer() << std::endl;
            }
            else
            {
                IntS index = 0;
                for (PinMLIter pin_iter = testPins.Begin(); !pin_iter.End(); ++pin_iter, ++index)
                {
                    StringS tw_name_plus_pin = tw_name + "_" + (*pin_iter).GetName();
                    // check the name length...it might be possible to correct
                    // for long pin names here by using an index
                    if (tw_name_plus_pin.Length() > TW_MAX_NAME_LENGTH)
                        tw_name_plus_pin = tw_name + "_" + index; 
                    // since TWPDLDataLogRealVariable checks the name length when 
                    // adding the log row, let it do the check to see if the name 
                    // with _index is ok. This way we don't take a double-execution
                    // time penalty on names that are ok
                    
            // :TODO: Add write var support for non-LS
//                    if (WRITE_TW_VARS_FILE) 
//                    {
//                        IntS test_id = RunTimeCache.GetTestID(minorID) + index;
//                        WriteVar (tw_name_plus_pin, test_id, SV_FLOAT, testLimit);
//                    }
// TIME.StartTimer();
                    TWPDLDataLogVariable (tw_name_plus_pin, tw_value[index], testwareDatatype); 
// std::cout << "TWPDLDataLogRealVariable took: " << TIME.StopTimer() << std::endl;
                }
            }
        }
    }
    else if ((gCloFunction == CLO_GENERATE) && gCloGenerateOk && doClo) {
    // :TODO: implement CLO stuff
    }
    else if ((gCloFunction == CLO_VERIFY) && doClo) 
    {
    // :TODO: implement CLO stuff
    }
    // put in extra if statment below to make CLO_NONE fast and skip all the evaluations inside
    if (gCloFunction != CLO_NONE) 
    {
        if (doClo && ((gCloFunction == CLO_GENERATE && gCloGenerateOk) || (gCloFunction == CLO_VERIFY && gCorrLockOutPassed))) 
        {
        // :TODO: implement CLO stuff
        }
        else if (doClo && ((gCloFunction == CLO_GENERATE && (!gCloGenerateOk)) || (gCloFunction == CLO_VERIFY && (!gCorrLockOutPassed))))
        {
        // :TODO: implement CLO stuff
        }
    }
    return (test_result);
}



        // :TODO: Fix FunctionalLS it is not ready yet
//TMResultM TIDatalog::FunctionalLS (const TMResultM &patResult, LimitStruct &testLimit, const BoolS &useTestware, 
//                                const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo, const EnumS<TWPatLogType> &patternLogType) 
//{
//    TMResultM test_result = TM_NOTEST;
//    
//    // No limit means no test
//    if (!testLimit.Valid())
//        return(test_result);
//
//    // only test and do testware stuff if we aren't doing CLO functions                
//    if (gCloFunction == CLO_NONE)
//    {
//        test_result = DLOG.FunctionalLS (patResult, testLimit);
//    
//    // :TODO: Add in FAIL_TEST stuff...not sure how to do it using standard
//    // TWPDL calls just yet
//     
//        if (useTestware) 
//        {
//            StringS tw_name = testLimit.GetName();
//            switch (patternLogType)
//            {
////                case LogPatternSuite:
//                    // :TODO: Need to implement TWPDLDataLogPatternSuite
//                    // TWPDLDataLogPatternSuite (tw_name, testwareDatatype);
////                    break;
////                case LogPatternFail:
//                    // :TODO: Need to implement TWPDLDataLogPatternFail
//                    //TWPDLDataLogPatternFail (tw_name, testwareDatatype);   
////                    break;
//                default:
//                {
//                    TWPDLDataLogPassFailInt(tw_name, patResult, testwareDatatype);
//                } // end default case for switch on the log type
//            } // end switch log type
//        }
//    }
//    else if ((gCloFunction == CLO_GENERATE) && gCloGenerateOk && doClo) {
//    // :TODO: implement CLO stuff
//    }
//    else if ((gCloFunction == CLO_VERIFY) && doClo) 
//    {
//    // :TODO: implement CLO stuff
//    }
//    // put in extra if statment below to make CLO_NONE fast and skip all the evaluations inside
//    if (gCloFunction != CLO_NONE)
//    {
//        if (doClo && ((gCloFunction == CLO_GENERATE && gCloGenerateOk) || (gCloFunction == CLO_VERIFY && gCorrLockOutPassed)))
//        {
//        // :TODO: implement CLO stuff
//        }
//        else if (doClo && ((gCloFunction == CLO_GENERATE && (!gCloGenerateOk)) || (gCloFunction == CLO_VERIFY && (!gCorrLockOutPassed))))
//        {
//        // :TODO: implement CLO stuff
//        }
//    }
//    return (test_result);
//}
//
//TMResultM TIDatalog::FunctionalLS (const TMResultM &patResult, ObjectS &testLimit, const BoolS &useTestware, 
//                                const EnumS<TWDataType> &testwareDatatype, const BoolS &doClo, const EnumS<TWPatLogType> &patternLogType) 
//{
//    TMResultM test_result = TM_NOTEST;
//    if (!testLimit.Valid())
//    {
//        return (test_result);
//    }
//    
//    LimitStruct limit_struct(testLimit);
//    test_result = FunctionalLS (patResult, limit_struct, useTestware, testwareDatatype, doClo, patternLogType);
//    return (test_result);
//    
//}
//
